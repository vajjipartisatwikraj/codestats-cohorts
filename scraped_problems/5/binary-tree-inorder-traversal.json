{
  "title": "Binary Tree Inorder Traversal",
  "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\nInorder traversal visits nodes in the following order: left subtree, current node, right subtree.\n\nInput Format:\n- The first line contains a single integer n, the number of nodes in the binary tree.\n- The second line contains n space-separated integers representing the values of the nodes. A value of -1 indicates a null node.\n- The input represents a level order traversal of the binary tree, where null nodes are represented by -1.\n\nOutput Format:\n- A single line containing space-separated integers representing the inorder traversal of the binary tree.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the tree is in the range [0, 100]",
    "-100 <= Node.val <= 100"
  ],
  "examples": [
    {
      "input": "3\n1 -1 2 3",
      "output": "1 3 2",
      "explanation": "The binary tree is:\n    1\n     \\\n      2\n     /\n    3\nInorder traversal: [1, 3, 2]"
    },
    {
      "input": "0\n",
      "output": "",
      "explanation": "The binary tree is empty.\nInorder traversal: []"
    }
  ],
  "type": "programming",
  "difficultyLevel": "easy",
  "marks": 5,
  "tags": ["Tree", "Depth-First Search", "Binary Tree", "Stack"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "Apple", "Bloomberg", "Oracle"],
  "hints": [
    "Inorder traversal follows Left -> Root -> Right pattern",
    "You can implement this recursively by first traversing the left subtree, then visiting the node, then traversing the right subtree",
    "You can also implement this iteratively using a stack to simulate the recursion",
    "Think about how to keep track of where you are in the traversal when implementing iteratively"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Returns the inorder traversal of the binary tree\n     * @param root The root of the binary tree\n     * @return List of node values in inorder traversal\n     */\n    public List<Integer> inorderTraversal(TreeNode root) {\n        // Implement your solution here\n        return new ArrayList<>(); // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            List<Integer> result = sol.inorderTraversal(root);\n            /*RUNTIME CALC END*/\n            \n            StringBuilder output = new StringBuilder();\n            for (int i = 0; i < result.size(); i++) {\n                output.append(result.get(i));\n                if (i < result.size() - 1) {\n                    output.append(\" \");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Returns the inorder traversal of the binary tree\n     * @param root The root of the binary tree\n     * @return List of node values in inorder traversal\n     */\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        inorderHelper(root, result);\n        return result;\n    }\n    \n    private void inorderHelper(TreeNode node, List<Integer> result) {\n        if (node == null) {\n            return;\n        }\n        \n        // Traverse left subtree\n        inorderHelper(node.left, result);\n        \n        // Visit the node\n        result.add(node.val);\n        \n        // Traverse right subtree\n        inorderHelper(node.right, result);\n    }\n    \n    // Iterative solution using a stack\n    public List<Integer> inorderTraversalIterative(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode current = root;\n        \n        while (current != null || !stack.isEmpty()) {\n            // Traverse to the leftmost node\n            while (current != null) {\n                stack.push(current);\n                current = current.left;\n            }\n            \n            // Current is now null, pop from stack\n            current = stack.pop();\n            \n            // Visit the node\n            result.add(current.val);\n            \n            // Move to the right subtree\n            current = current.right;\n        }\n        \n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            List<Integer> result = sol.inorderTraversal(root);\n            /*RUNTIME CALC END*/\n            \n            StringBuilder output = new StringBuilder();\n            for (int i = 0; i < result.size(); i++) {\n                output.append(result.get(i));\n                if (i < result.size() - 1) {\n                    output.append(\" \");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Returns the inorder traversal of the binary tree\n     * @param root The root of the binary tree\n     * @return Vector of node values in inorder traversal\n     */\n    std::vector<int> inorderTraversal(TreeNode* root) {\n        // Implement your solution here\n        return {}; // Replace with your implementation\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    std::vector<int> result = sol.inorderTraversal(root);\n    /*RUNTIME CALC END*/\n    \n    for (int i = 0; i < result.size(); i++) {\n        std::cout << result[i];\n        if (i < result.size() - 1) {\n            std::cout << \" \";\n        }\n    }\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Returns the inorder traversal of the binary tree\n     * @param root The root of the binary tree\n     * @return Vector of node values in inorder traversal\n     */\n    std::vector<int> inorderTraversal(TreeNode* root) {\n        std::vector<int> result;\n        inorderHelper(root, result);\n        return result;\n    }\n    \n    void inorderHelper(TreeNode* node, std::vector<int>& result) {\n        if (node == nullptr) {\n            return;\n        }\n        \n        // Traverse left subtree\n        inorderHelper(node->left, result);\n        \n        // Visit the node\n        result.push_back(node->val);\n        \n        // Traverse right subtree\n        inorderHelper(node->right, result);\n    }\n    \n    // Iterative solution using a stack\n    std::vector<int> inorderTraversalIterative(TreeNode* root) {\n        std::vector<int> result;\n        std::stack<TreeNode*> stack;\n        TreeNode* current = root;\n        \n        while (current != nullptr || !stack.empty()) {\n            // Traverse to the leftmost node\n            while (current != nullptr) {\n                stack.push(current);\n                current = current->left;\n            }\n            \n            // Current is now nullptr, pop from stack\n            current = stack.top();\n            stack.pop();\n            \n            // Visit the node\n            result.push_back(current->val);\n            \n            // Move to the right subtree\n            current = current->right;\n        }\n        \n        return result;\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    std::vector<int> result = sol.inorderTraversal(root);\n    /*RUNTIME CALC END*/\n    \n    for (int i = 0; i < result.size(); i++) {\n        std::cout << result[i];\n        if (i < result.size() - 1) {\n            std::cout << \" \";\n        }\n    }\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import List, Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        \"\"\"\n        Returns the inorder traversal of the binary tree\n        :param root: The root of the binary tree\n        :return: List of node values in inorder traversal\n        \"\"\"\n        # Implement your solution here\n        return []  # Replace with your implementation\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.inorderTraversal(root)\n        # RUNTIME CALC END\n        \n        print(' '.join(map(str, result)))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\nfrom typing import List, Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        \"\"\"\n        Returns the inorder traversal of the binary tree\n        :param root: The root of the binary tree\n        :return: List of node values in inorder traversal\n        \"\"\"\n        result = []\n        self.inorder_helper(root, result)\n        return result\n    \n    def inorder_helper(self, node, result):\n        if not node:\n            return\n        \n        # Traverse left subtree\n        self.inorder_helper(node.left, result)\n        \n        # Visit the node\n        result.append(node.val)\n        \n        # Traverse right subtree\n        self.inorder_helper(node.right, result)\n    \n    # Iterative solution using a stack\n    def inorderTraversalIterative(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        stack = []\n        current = root\n        \n        while current or stack:\n            # Traverse to the leftmost node\n            while current:\n                stack.append(current)\n                current = current.left\n            \n            # Current is now None, pop from stack\n            current = stack.pop()\n            \n            # Visit the node\n            result.append(current.val)\n            \n            # Move to the right subtree\n            current = current.right\n        \n        return result\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.inorderTraversal(root)\n        # RUNTIME CALC END\n        \n        print(' '.join(map(str, result)))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "3\n1 -1 2 3",
      "output": "1 3 2",
      "hidden": false,
      "explanation": "Basic test case for inorder traversal"
    },
    {
      "input": "0\n",
      "output": "",
      "hidden": false,
      "explanation": "Test case with empty tree"
    },
    {
      "input": "7\n1 2 3 4 5 6 7",
      "output": "4 2 5 1 6 3 7",
      "hidden": true,
      "explanation": "Test case with a complete binary tree"
    }
  ]
} 