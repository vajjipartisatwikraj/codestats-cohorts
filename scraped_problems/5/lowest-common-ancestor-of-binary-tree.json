{
  "title": "Lowest Common Ancestor of a Binary Tree",
  "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\"\n\nInput Format:\n- The first line contains a single integer n, the number of nodes in the binary tree.\n- The second line contains n space-separated integers representing the values of the nodes. A value of -1 indicates a null node.\n- The input represents a level order traversal of the binary tree, where null nodes are represented by -1.\n- The third line contains two integers p and q, the values of the two nodes whose LCA we need to find.\n\nOutput Format:\n- A single integer representing the value of the lowest common ancestor of nodes p and q.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the tree is in the range [2, 10^5]",
    "-10^9 <= Node.val <= 10^9",
    "All Node.val are unique",
    "p != q",
    "p and q will exist in the tree"
  ],
  "examples": [
    {
      "input": "9\n3 5 1 6 2 0 8 -1 -1 7 4\n5 1",
      "output": "3",
      "explanation": "The binary tree is:\n        3\n       / \\\n      5   1\n     / \\ / \\\n    6  2 0  8\n      / \\\n     7   4\nThe LCA of nodes with values 5 and 1 is the node with value 3."
    },
    {
      "input": "9\n3 5 1 6 2 0 8 -1 -1 7 4\n5 4",
      "output": "5",
      "explanation": "The binary tree is:\n        3\n       / \\\n      5   1\n     / \\ / \\\n    6  2 0  8\n      / \\\n     7   4\nThe LCA of nodes with values 5 and 4 is the node with value 5."
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Tree", "Depth-First Search", "Binary Tree"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Facebook", "Amazon", "Microsoft", "Google", "Adobe", "Apple", "LinkedIn"],
  "hints": [
    "Start traversing the tree from the root node",
    "If the current node is one of the given nodes (p or q), then it is part of the LCA",
    "Use a recursive approach to check if p and q are in the left or right subtrees",
    "If p and q are in different subtrees, then the current node is the LCA",
    "If p and q are in the same subtree, then the LCA is in that subtree"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Returns the lowest common ancestor of two nodes\n     * @param root The root of the binary tree\n     * @param p The first node\n     * @param q The second node\n     * @return The lowest common ancestor\n     */\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Implement your solution here\n        return null; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            String[] targets = br.readLine().trim().split(\" \");\n            int p = Integer.parseInt(targets[0]);\n            int q = Integer.parseInt(targets[1]);\n            \n            TreeNode pNode = findNode(root, p);\n            TreeNode qNode = findNode(root, q);\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            TreeNode lca = sol.lowestCommonAncestor(root, pNode, qNode);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(lca.val);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n    \n    private static TreeNode findNode(TreeNode root, int val) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val == val) {\n            return root;\n        }\n        \n        TreeNode left = findNode(root.left, val);\n        if (left != null) {\n            return left;\n        }\n        \n        return findNode(root.right, val);\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Returns the lowest common ancestor of two nodes\n     * @param root The root of the binary tree\n     * @param p The first node\n     * @param q The second node\n     * @return The lowest common ancestor\n     */\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Base case: if root is null or is one of the nodes we're looking for\n        if (root == null || root == p || root == q) {\n            return root;\n        }\n        \n        // Recursively search in left and right subtrees\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        \n        // If both nodes are found in different subtrees\n        if (left != null && right != null) {\n            return root; // Current node is the LCA\n        }\n        \n        // If both nodes are in the left subtree\n        if (left != null) {\n            return left;\n        }\n        \n        // If both nodes are in the right subtree\n        return right;\n    }\n    \n    // Iterative solution using parent pointers\n    public TreeNode lowestCommonAncestorIterative(TreeNode root, TreeNode p, TreeNode q) {\n        // Map to store parent pointers for each node\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\n        parent.put(root, null);\n        \n        // Queue for BFS traversal\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        // Process until we find both p and q\n        while (!parent.containsKey(p) || !parent.containsKey(q)) {\n            TreeNode node = queue.poll();\n            \n            // Set parent pointers for children\n            if (node.left != null) {\n                parent.put(node.left, node);\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                parent.put(node.right, node);\n                queue.offer(node.right);\n            }\n        }\n        \n        // Set to keep track of ancestors of p\n        Set<TreeNode> ancestors = new HashSet<>();\n        \n        // Add all ancestors of p to the set\n        while (p != null) {\n            ancestors.add(p);\n            p = parent.get(p);\n        }\n        \n        // Find the first ancestor of q that is also an ancestor of p\n        while (!ancestors.contains(q)) {\n            q = parent.get(q);\n        }\n        \n        return q; // This is the LCA\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            String[] targets = br.readLine().trim().split(\" \");\n            int p = Integer.parseInt(targets[0]);\n            int q = Integer.parseInt(targets[1]);\n            \n            TreeNode pNode = findNode(root, p);\n            TreeNode qNode = findNode(root, q);\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            TreeNode lca = sol.lowestCommonAncestor(root, pNode, qNode);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(lca.val);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n    \n    private static TreeNode findNode(TreeNode root, int val) {\n        if (root == null) {\n            return null;\n        }\n        if (root.val == val) {\n            return root;\n        }\n        \n        TreeNode left = findNode(root.left, val);\n        if (left != null) {\n            return left;\n        }\n        \n        return findNode(root.right, val);\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Returns the lowest common ancestor of two nodes\n     * @param root The root of the binary tree\n     * @param p The first node\n     * @param q The second node\n     * @return The lowest common ancestor\n     */\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // Implement your solution here\n        return nullptr; // Replace with your implementation\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\nTreeNode* findNode(TreeNode* root, int val) {\n    if (root == nullptr) {\n        return nullptr;\n    }\n    if (root->val == val) {\n        return root;\n    }\n    \n    TreeNode* left = findNode(root->left, val);\n    if (left != nullptr) {\n        return left;\n    }\n    \n    return findNode(root->right, val);\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    int p, q;\n    std::cin >> p >> q;\n    \n    TreeNode* pNode = findNode(root, p);\n    TreeNode* qNode = findNode(root, q);\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    TreeNode* lca = sol.lowestCommonAncestor(root, pNode, qNode);\n    /*RUNTIME CALC END*/\n    \n    std::cout << lca->val << std::endl;\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <unordered_set>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Returns the lowest common ancestor of two nodes\n     * @param root The root of the binary tree\n     * @param p The first node\n     * @param q The second node\n     * @return The lowest common ancestor\n     */\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // Base case: if root is null or is one of the nodes we're looking for\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n        \n        // Recursively search in left and right subtrees\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\n        \n        // If both nodes are found in different subtrees\n        if (left != nullptr && right != nullptr) {\n            return root; // Current node is the LCA\n        }\n        \n        // If both nodes are in the left subtree\n        if (left != nullptr) {\n            return left;\n        }\n        \n        // If both nodes are in the right subtree\n        return right;\n    }\n    \n    // Iterative solution using parent pointers\n    TreeNode* lowestCommonAncestorIterative(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // Map to store parent pointers for each node\n        std::unordered_map<TreeNode*, TreeNode*> parent;\n        parent[root] = nullptr;\n        \n        // Queue for BFS traversal\n        std::queue<TreeNode*> queue;\n        queue.push(root);\n        \n        // Process until we find both p and q\n        while (parent.find(p) == parent.end() || parent.find(q) == parent.end()) {\n            TreeNode* node = queue.front();\n            queue.pop();\n            \n            // Set parent pointers for children\n            if (node->left != nullptr) {\n                parent[node->left] = node;\n                queue.push(node->left);\n            }\n            if (node->right != nullptr) {\n                parent[node->right] = node;\n                queue.push(node->right);\n            }\n        }\n        \n        // Set to keep track of ancestors of p\n        std::unordered_set<TreeNode*> ancestors;\n        \n        // Add all ancestors of p to the set\n        while (p != nullptr) {\n            ancestors.insert(p);\n            p = parent[p];\n        }\n        \n        // Find the first ancestor of q that is also an ancestor of p\n        while (ancestors.find(q) == ancestors.end()) {\n            q = parent[q];\n        }\n        \n        return q; // This is the LCA\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\nTreeNode* findNode(TreeNode* root, int val) {\n    if (root == nullptr) {\n        return nullptr;\n    }\n    if (root->val == val) {\n        return root;\n    }\n    \n    TreeNode* left = findNode(root->left, val);\n    if (left != nullptr) {\n        return left;\n    }\n    \n    return findNode(root->right, val);\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    int p, q;\n    std::cin >> p >> q;\n    \n    TreeNode* pNode = findNode(root, p);\n    TreeNode* qNode = findNode(root, q);\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    TreeNode* lca = sol.lowestCommonAncestor(root, pNode, qNode);\n    /*RUNTIME CALC END*/\n    \n    std::cout << lca->val << std::endl;\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> Optional[TreeNode]:\n        \"\"\"\n        Returns the lowest common ancestor of two nodes\n        :param root: The root of the binary tree\n        :param p: The first node\n        :param q: The second node\n        :return: The lowest common ancestor\n        \"\"\"\n        # Implement your solution here\n        return None  # Replace with your implementation\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef find_node(root, val):\n    if not root:\n        return None\n    if root.val == val:\n        return root\n    \n    left = find_node(root.left, val)\n    if left:\n        return left\n    \n    return find_node(root.right, val)\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        p, q = map(int, input().strip().split())\n        p_node = find_node(root, p)\n        q_node = find_node(root, q)\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        lca = sol.lowestCommonAncestor(root, p_node, q_node)\n        # RUNTIME CALC END\n        \n        print(lca.val)\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\nfrom typing import Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> Optional[TreeNode]:\n        \"\"\"\n        Returns the lowest common ancestor of two nodes\n        :param root: The root of the binary tree\n        :param p: The first node\n        :param q: The second node\n        :return: The lowest common ancestor\n        \"\"\"\n        # Base case: if root is null or is one of the nodes we're looking for\n        if not root or root == p or root == q:\n            return root\n        \n        # Recursively search in left and right subtrees\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        \n        # If both nodes are found in different subtrees\n        if left and right:\n            return root  # Current node is the LCA\n        \n        # If both nodes are in the left subtree\n        if left:\n            return left\n        \n        # If both nodes are in the right subtree\n        return right\n    \n    # Iterative solution using parent pointers\n    def lowestCommonAncestorIterative(self, root: TreeNode, p: TreeNode, q: TreeNode) -> Optional[TreeNode]:\n        # Map to store parent pointers for each node\n        parent = {root: None}\n        \n        # Queue for BFS traversal\n        queue = deque([root])\n        \n        # Process until we find both p and q\n        while p not in parent or q not in parent:\n            node = queue.popleft()\n            \n            # Set parent pointers for children\n            if node.left:\n                parent[node.left] = node\n                queue.append(node.left)\n            if node.right:\n                parent[node.right] = node\n                queue.append(node.right)\n        \n        # Set to keep track of ancestors of p\n        ancestors = set()\n        \n        # Add all ancestors of p to the set\n        while p:\n            ancestors.add(p)\n            p = parent[p]\n        \n        # Find the first ancestor of q that is also an ancestor of p\n        while q not in ancestors:\n            q = parent[q]\n        \n        return q  # This is the LCA\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef find_node(root, val):\n    if not root:\n        return None\n    if root.val == val:\n        return root\n    \n    left = find_node(root.left, val)\n    if left:\n        return left\n    \n    return find_node(root.right, val)\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        p, q = map(int, input().strip().split())\n        p_node = find_node(root, p)\n        q_node = find_node(root, q)\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        lca = sol.lowestCommonAncestor(root, p_node, q_node)\n        # RUNTIME CALC END\n        \n        print(lca.val)\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "9\n3 5 1 6 2 0 8 -1 -1 7 4\n5 1",
      "output": "3",
      "hidden": false,
      "explanation": "Test case where LCA is the root node"
    },
    {
      "input": "9\n3 5 1 6 2 0 8 -1 -1 7 4\n5 4",
      "output": "5",
      "hidden": false,
      "explanation": "Test case where one node is in the subtree of the other"
    },
    {
      "input": "9\n3 5 1 6 2 0 8 -1 -1 7 4\n6 4",
      "output": "5",
      "hidden": true,
      "explanation": "Test case where LCA is neither of the two nodes"
    },
    {
      "input": "9\n3 5 1 6 2 0 8 -1 -1 7 4\n2 7",
      "output": "2",
      "hidden": true,
      "explanation": "Test case where one node is the parent of the other"
    }
  ]
} 