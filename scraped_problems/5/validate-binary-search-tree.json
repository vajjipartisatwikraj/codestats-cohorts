{
  "title": "Validate Binary Search Tree",
  "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.\n\nInput Format:\n- The first line contains a single integer n, the number of nodes in the binary tree.\n- The second line contains n space-separated integers representing the values of the nodes. A value of -1 indicates a null node.\n- The input represents a level order traversal of the binary tree, where null nodes are represented by -1.\n\nOutput Format:\n- \"true\" if the binary tree is a valid BST, \"false\" otherwise.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the tree is in the range [1, 10^4]",
    "-2^31 <= Node.val <= 2^31 - 1"
  ],
  "examples": [
    {
      "input": "3\n2 1 3",
      "output": "true",
      "explanation": "The binary tree is:\n    2\n   / \\\n  1   3\nThe tree is a valid BST since the values in the left subtree are less than 2, and the values in the right subtree are greater than 2."
    },
    {
      "input": "5\n5 1 4 -1 -1 3 6",
      "output": "false",
      "explanation": "The binary tree is:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\nThe tree is not a valid BST because the value 4 is in the right subtree of 5, but it has a left child 3, which is less than 5."
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Tree", "Depth-First Search", "Binary Search Tree", "Binary Tree"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "Apple", "Twitter", "LinkedIn"],
  "hints": [
    "A common mistake is to check if the value of each node is greater than its left child and less than its right child",
    "Think about the valid range of values for each node based on its position in the tree",
    "For a node in the right subtree, its value must be greater than all nodes in the parent's left subtree",
    "Consider using an inorder traversal - in a valid BST, the inorder traversal yields values in ascending order",
    "You can solve this using recursion by passing the valid range of values for each subtree"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Determines if the binary tree is a valid binary search tree\n     * @param root The root of the binary tree\n     * @return true if the tree is a valid BST, false otherwise\n     */\n    public boolean isValidBST(TreeNode root) {\n        // Implement your solution here\n        return false; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            boolean result = sol.isValidBST(root);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(result ? \"true\" : \"false\");\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Determines if the binary tree is a valid binary search tree\n     * @param root The root of the binary tree\n     * @return true if the tree is a valid BST, false otherwise\n     */\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    private boolean isValidBST(TreeNode node, long min, long max) {\n        // Base case: an empty tree is a valid BST\n        if (node == null) {\n            return true;\n        }\n        \n        // Check if the current node's value is in the valid range\n        if (node.val <= min || node.val >= max) {\n            return false;\n        }\n        \n        // Check if the left and right subtrees are valid BSTs\n        return isValidBST(node.left, min, node.val) && isValidBST(node.right, node.val, max);\n    }\n    \n    // Inorder traversal approach\n    public boolean isValidBSTInorder(TreeNode root) {\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode prev = null;\n        TreeNode curr = root;\n        \n        while (curr != null || !stack.isEmpty()) {\n            // Traverse to the leftmost node\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            \n            // Visit the current node\n            curr = stack.pop();\n            \n            // In a valid BST, the nodes visited in inorder should have increasing values\n            if (prev != null && curr.val <= prev.val) {\n                return false;\n            }\n            \n            prev = curr;\n            curr = curr.right;\n        }\n        \n        return true;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            boolean result = sol.isValidBST(root);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(result ? \"true\" : \"false\");\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n#include <climits>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Determines if the binary tree is a valid binary search tree\n     * @param root The root of the binary tree\n     * @return true if the tree is a valid BST, false otherwise\n     */\n    bool isValidBST(TreeNode* root) {\n        // Implement your solution here\n        return false; // Replace with your implementation\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    bool result = sol.isValidBST(root);\n    /*RUNTIME CALC END*/\n    \n    std::cout << (result ? \"true\" : \"false\") << std::endl;\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <climits>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Determines if the binary tree is a valid binary search tree\n     * @param root The root of the binary tree\n     * @return true if the tree is a valid BST, false otherwise\n     */\n    bool isValidBST(TreeNode* root) {\n        return isValidBST(root, LONG_MIN, LONG_MAX);\n    }\n    \n    bool isValidBST(TreeNode* node, long long min, long long max) {\n        // Base case: an empty tree is a valid BST\n        if (node == nullptr) {\n            return true;\n        }\n        \n        // Check if the current node's value is in the valid range\n        if (node->val <= min || node->val >= max) {\n            return false;\n        }\n        \n        // Check if the left and right subtrees are valid BSTs\n        return isValidBST(node->left, min, node->val) && isValidBST(node->right, node->val, max);\n    }\n    \n    // Inorder traversal approach\n    bool isValidBSTInorder(TreeNode* root) {\n        std::stack<TreeNode*> stack;\n        TreeNode* prev = nullptr;\n        TreeNode* curr = root;\n        \n        while (curr != nullptr || !stack.empty()) {\n            // Traverse to the leftmost node\n            while (curr != nullptr) {\n                stack.push(curr);\n                curr = curr->left;\n            }\n            \n            // Visit the current node\n            curr = stack.top();\n            stack.pop();\n            \n            // In a valid BST, the nodes visited in inorder should have increasing values\n            if (prev != nullptr && curr->val <= prev->val) {\n                return false;\n            }\n            \n            prev = curr;\n            curr = curr->right;\n        }\n        \n        return true;\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    bool result = sol.isValidBST(root);\n    /*RUNTIME CALC END*/\n    \n    std::cout << (result ? \"true\" : \"false\") << std::endl;\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Determines if the binary tree is a valid binary search tree\n        :param root: The root of the binary tree\n        :return: True if the tree is a valid BST, False otherwise\n        \"\"\"\n        # Implement your solution here\n        return False  # Replace with your implementation\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.isValidBST(root)\n        # RUNTIME CALC END\n        \n        print(\"true\" if result else \"false\")\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\nfrom typing import Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Determines if the binary tree is a valid binary search tree\n        :param root: The root of the binary tree\n        :return: True if the tree is a valid BST, False otherwise\n        \"\"\"\n        def validate(node, min_val=float('-inf'), max_val=float('inf')):\n            # Base case: an empty tree is a valid BST\n            if not node:\n                return True\n            \n            # Check if the current node's value is in the valid range\n            if node.val <= min_val or node.val >= max_val:\n                return False\n            \n            # Check if the left and right subtrees are valid BSTs\n            return (validate(node.left, min_val, node.val) and \n                    validate(node.right, node.val, max_val))\n        \n        return validate(root)\n    \n    # Inorder traversal approach\n    def isValidBSTInorder(self, root: Optional[TreeNode]) -> bool:\n        stack = []\n        prev = None\n        curr = root\n        \n        while curr or stack:\n            # Traverse to the leftmost node\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            \n            # Visit the current node\n            curr = stack.pop()\n            \n            # In a valid BST, the nodes visited in inorder should have increasing values\n            if prev is not None and curr.val <= prev.val:\n                return False\n            \n            prev = curr\n            curr = curr.right\n        \n        return True\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.isValidBST(root)\n        # RUNTIME CALC END\n        \n        print(\"true\" if result else \"false\")\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "3\n2 1 3",
      "output": "true",
      "hidden": false,
      "explanation": "Basic valid BST test case"
    },
    {
      "input": "5\n5 1 4 -1 -1 3 6",
      "output": "false",
      "hidden": false,
      "explanation": "Invalid BST where a node in the right subtree has a value less than the root"
    },
    {
      "input": "7\n10 5 15 3 7 -1 20",
      "output": "true",
      "hidden": true,
      "explanation": "Valid BST with multiple levels"
    },
    {
      "input": "5\n10 5 15 -1 -1 6 20",
      "output": "false",
      "hidden": true,
      "explanation": "Invalid BST: 6 is in the right subtree of 10 but is less than 10"
    }
  ]
} 