{
  "title": "Maximum Depth of Binary Tree",
  "description": "Given the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\nInput Format:\n- The first line contains a single integer n, the number of nodes in the binary tree.\n- The second line contains n space-separated integers representing the values of the nodes. A value of -1 indicates a null node.\n- The input represents a level order traversal of the binary tree, where null nodes are represented by -1.\n\nOutput Format:\n- A single integer representing the maximum depth of the binary tree.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the tree is in the range [0, 10^4]",
    "-100 <= Node.val <= 100"
  ],
  "examples": [
    {
      "input": "5\n3 9 20 -1 -1 15 7",
      "output": "3",
      "explanation": "The binary tree is:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nThe maximum depth is 3."
    },
    {
      "input": "1\n1",
      "output": "1",
      "explanation": "The binary tree is:\n    1\nThe maximum depth is 1."
    }
  ],
  "type": "programming",
  "difficultyLevel": "easy",
  "marks": 5,
  "tags": ["Tree", "Depth-First Search", "Binary Tree", "Breadth-First Search"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "Apple", "Adobe", "Bloomberg"],
  "hints": [
    "The maximum depth can be calculated recursively",
    "The maximum depth is 1 (for the root) plus the maximum of the depths of the left and right subtrees",
    "For an empty tree, the depth is 0",
    "You can also solve this iteratively using breadth-first search or depth-first search"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Returns the maximum depth of the binary tree\n     * @param root The root of the binary tree\n     * @return The maximum depth\n     */\n    public int maxDepth(TreeNode root) {\n        // Implement your solution here\n        return 0; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            int result = sol.maxDepth(root);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(result);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Returns the maximum depth of the binary tree\n     * @param root The root of the binary tree\n     * @return The maximum depth\n     */\n    public int maxDepth(TreeNode root) {\n        // Base case: if the tree is empty\n        if (root == null) {\n            return 0;\n        }\n        \n        // Calculate the maximum depth of the left and right subtrees\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        \n        // The maximum depth is 1 (for the root) plus the greater of the two depths\n        return 1 + Math.max(leftDepth, rightDepth);\n    }\n    \n    // Iterative solution using BFS\n    public int maxDepthBFS(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int depth = 0;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size(); // Number of nodes at the current level\n            \n            // Process all nodes at the current level\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                \n                // Add children to the queue\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            \n            // Increment depth after processing all nodes at the current level\n            depth++;\n        }\n        \n        return depth;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            int result = sol.maxDepth(root);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(result);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Returns the maximum depth of the binary tree\n     * @param root The root of the binary tree\n     * @return The maximum depth\n     */\n    int maxDepth(TreeNode* root) {\n        // Implement your solution here\n        return 0; // Replace with your implementation\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    int result = sol.maxDepth(root);\n    /*RUNTIME CALC END*/\n    \n    std::cout << result << std::endl;\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Returns the maximum depth of the binary tree\n     * @param root The root of the binary tree\n     * @return The maximum depth\n     */\n    int maxDepth(TreeNode* root) {\n        // Base case: if the tree is empty\n        if (root == nullptr) {\n            return 0;\n        }\n        \n        // Calculate the maximum depth of the left and right subtrees\n        int leftDepth = maxDepth(root->left);\n        int rightDepth = maxDepth(root->right);\n        \n        // The maximum depth is 1 (for the root) plus the greater of the two depths\n        return 1 + std::max(leftDepth, rightDepth);\n    }\n    \n    // Iterative solution using BFS\n    int maxDepthBFS(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        \n        std::queue<TreeNode*> queue;\n        queue.push(root);\n        int depth = 0;\n        \n        while (!queue.empty()) {\n            int size = queue.size(); // Number of nodes at the current level\n            \n            // Process all nodes at the current level\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = queue.front();\n                queue.pop();\n                \n                // Add children to the queue\n                if (node->left != nullptr) {\n                    queue.push(node->left);\n                }\n                if (node->right != nullptr) {\n                    queue.push(node->right);\n                }\n            }\n            \n            // Increment depth after processing all nodes at the current level\n            depth++;\n        }\n        \n        return depth;\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    int result = sol.maxDepth(root);\n    /*RUNTIME CALC END*/\n    \n    std::cout << result << std::endl;\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Returns the maximum depth of the binary tree\n        :param root: The root of the binary tree\n        :return: The maximum depth\n        \"\"\"\n        # Implement your solution here\n        return 0  # Replace with your implementation\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.maxDepth(root)\n        # RUNTIME CALC END\n        \n        print(result)\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\nfrom typing import Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Returns the maximum depth of the binary tree\n        :param root: The root of the binary tree\n        :return: The maximum depth\n        \"\"\"\n        # Base case: if the tree is empty\n        if not root:\n            return 0\n        \n        # Calculate the maximum depth of the left and right subtrees\n        left_depth = self.maxDepth(root.left)\n        right_depth = self.maxDepth(root.right)\n        \n        # The maximum depth is 1 (for the root) plus the greater of the two depths\n        return 1 + max(left_depth, right_depth)\n    \n    # Iterative solution using BFS\n    def maxDepthBFS(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        queue = deque([root])\n        depth = 0\n        \n        while queue:\n            size = len(queue)  # Number of nodes at the current level\n            \n            # Process all nodes at the current level\n            for _ in range(size):\n                node = queue.popleft()\n                \n                # Add children to the queue\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            # Increment depth after processing all nodes at the current level\n            depth += 1\n        \n        return depth\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.maxDepth(root)\n        # RUNTIME CALC END\n        \n        print(result)\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "5\n3 9 20 -1 -1 15 7",
      "output": "3",
      "hidden": false,
      "explanation": "Basic test case for maximum depth"
    },
    {
      "input": "1\n1",
      "output": "1",
      "hidden": false,
      "explanation": "Test case with a single node"
    },
    {
      "input": "9\n1 2 3 4 5 -1 6 -1 -1 7 8",
      "output": "4",
      "hidden": true,
      "explanation": "Test case with an unbalanced binary tree"
    }
  ]
} 