{
  "title": "Binary Tree Zigzag Level Order Traversal",
  "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\n\nInput Format:\n- The first line contains a single integer n, the number of nodes in the binary tree.\n- The second line contains n space-separated integers representing the values of the nodes. A value of -1 indicates a null node.\n- The input represents a level order traversal of the binary tree, where null nodes are represented by -1.\n\nOutput Format:\n- The output should contain multiple lines, each line representing a level in the binary tree.\n- Each line should contain space-separated integers representing the values of the nodes at that level.\n- The even-numbered levels (0-indexed) should be traversed from left to right, while the odd-numbered levels should be traversed from right to left.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the tree is in the range [0, 2000]",
    "-100 <= Node.val <= 100"
  ],
  "examples": [
    {
      "input": "5\n3 9 20 -1 -1 15 7",
      "output": "3\n20 9\n15 7",
      "explanation": "The binary tree is:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nZigzag level order traversal: [[3], [20, 9], [15, 7]]"
    },
    {
      "input": "1\n1",
      "output": "1",
      "explanation": "The binary tree is:\n    1\nZigzag level order traversal: [[1]]"
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Tree", "Breadth-First Search", "Binary Tree"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Microsoft", "Amazon", "Facebook", "Google", "LinkedIn"],
  "hints": [
    "Use a breadth-first search (BFS) approach to traverse the tree level by level",
    "Keep track of the current level number to determine the traversal direction",
    "For even-numbered levels, traverse from left to right; for odd-numbered levels, traverse from right to left",
    "Consider using a deque (double-ended queue) to efficiently handle the zigzag pattern",
    "You can also reverse the list for odd-numbered levels after collecting all nodes at that level"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Returns the zigzag level order traversal of the binary tree\n     * @param root The root of the binary tree\n     * @return List of lists, where each inner list contains node values at the same level in zigzag order\n     */\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        // Implement your solution here\n        return new ArrayList<>(); // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            List<List<Integer>> result = sol.zigzagLevelOrder(root);\n            /*RUNTIME CALC END*/\n            \n            StringBuilder output = new StringBuilder();\n            for (int i = 0; i < result.size(); i++) {\n                List<Integer> level = result.get(i);\n                for (int j = 0; j < level.size(); j++) {\n                    output.append(level.get(j));\n                    if (j < level.size() - 1) {\n                        output.append(\" \");\n                    }\n                }\n                if (i < result.size() - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    /**\n     * Returns the zigzag level order traversal of the binary tree\n     * @param root The root of the binary tree\n     * @return List of lists, where each inner list contains node values at the same level in zigzag order\n     */\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        \n        if (root == null) {\n            return result;\n        }\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        boolean leftToRight = true; // Flag to track zigzag direction\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List<Integer> currentLevel = new ArrayList<>();\n            \n            // Process all nodes at the current level\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                \n                // If traversing left to right, add to end of list\n                // If traversing right to left, add to beginning of list\n                if (leftToRight) {\n                    currentLevel.add(node.val);\n                } else {\n                    currentLevel.add(0, node.val); // Insert at the beginning\n                }\n                \n                // Add children to queue for next level\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            \n            result.add(currentLevel);\n            leftToRight = !leftToRight; // Flip the direction for the next level\n        }\n        \n        return result;\n    }\n    \n    // Alternative implementation using LinkedList\n    public List<List<Integer>> zigzagLevelOrderAlt(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        \n        if (root == null) {\n            return result;\n        }\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        boolean leftToRight = true;\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            LinkedList<Integer> currentLevel = new LinkedList<>(); // Using LinkedList for O(1) insertion at both ends\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                \n                // Add to the appropriate end of the list based on traversal direction\n                if (leftToRight) {\n                    currentLevel.addLast(node.val);\n                } else {\n                    currentLevel.addFirst(node.val);\n                }\n                \n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            \n            result.add(currentLevel);\n            leftToRight = !leftToRight;\n        }\n        \n        return result;\n    }\n    \n    // Implementation using ArrayList with Collections.reverse()\n    public List<List<Integer>> zigzagLevelOrderReverse(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        \n        if (root == null) {\n            return result;\n        }\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        boolean leftToRight = true;\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List<Integer> currentLevel = new ArrayList<>();\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                currentLevel.add(node.val); // Always add to the end\n                \n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            \n            // If traversing right to left, reverse the list\n            if (!leftToRight) {\n                Collections.reverse(currentLevel);\n            }\n            \n            result.add(currentLevel);\n            leftToRight = !leftToRight;\n        }\n        \n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            List<List<Integer>> result = sol.zigzagLevelOrder(root);\n            /*RUNTIME CALC END*/\n            \n            StringBuilder output = new StringBuilder();\n            for (int i = 0; i < result.size(); i++) {\n                List<Integer> level = result.get(i);\n                for (int j = 0; j < level.size(); j++) {\n                    output.append(level.get(j));\n                    if (j < level.size() - 1) {\n                        output.append(\" \");\n                    }\n                }\n                if (i < result.size() - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Returns the zigzag level order traversal of the binary tree\n     * @param root The root of the binary tree\n     * @return Vector of vectors, where each inner vector contains node values at the same level in zigzag order\n     */\n    std::vector<std::vector<int>> zigzagLevelOrder(TreeNode* root) {\n        // Implement your solution here\n        return {}; // Replace with your implementation\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    std::vector<std::vector<int>> result = sol.zigzagLevelOrder(root);\n    /*RUNTIME CALC END*/\n    \n    for (int i = 0; i < result.size(); i++) {\n        const auto& level = result[i];\n        for (int j = 0; j < level.size(); j++) {\n            std::cout << level[j];\n            if (j < level.size() - 1) {\n                std::cout << \" \";\n            }\n        }\n        if (i < result.size() - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Returns the zigzag level order traversal of the binary tree\n     * @param root The root of the binary tree\n     * @return Vector of vectors, where each inner vector contains node values at the same level in zigzag order\n     */\n    std::vector<std::vector<int>> zigzagLevelOrder(TreeNode* root) {\n        std::vector<std::vector<int>> result;\n        \n        if (root == nullptr) {\n            return result;\n        }\n        \n        std::queue<TreeNode*> queue;\n        queue.push(root);\n        bool leftToRight = true; // Flag to track zigzag direction\n        \n        while (!queue.empty()) {\n            int levelSize = queue.size();\n            std::vector<int> currentLevel(levelSize, 0); // Pre-allocate with the correct size\n            \n            // Process all nodes at the current level\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* node = queue.front();\n                queue.pop();\n                \n                // If traversing left to right, add normally\n                // If traversing right to left, add in reverse order\n                int index = leftToRight ? i : (levelSize - 1 - i);\n                currentLevel[index] = node->val;\n                \n                // Add children to queue for next level\n                if (node->left != nullptr) {\n                    queue.push(node->left);\n                }\n                if (node->right != nullptr) {\n                    queue.push(node->right);\n                }\n            }\n            \n            result.push_back(currentLevel);\n            leftToRight = !leftToRight; // Flip the direction for the next level\n        }\n        \n        return result;\n    }\n    \n    // Alternative implementation using deque\n    std::vector<std::vector<int>> zigzagLevelOrderAlt(TreeNode* root) {\n        std::vector<std::vector<int>> result;\n        \n        if (root == nullptr) {\n            return result;\n        }\n        \n        std::queue<TreeNode*> queue;\n        queue.push(root);\n        bool leftToRight = true;\n        \n        while (!queue.empty()) {\n            int levelSize = queue.size();\n            std::deque<int> currentLevel; // Using deque for O(1) insertion at both ends\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* node = queue.front();\n                queue.pop();\n                \n                // Add to the appropriate end of the deque based on traversal direction\n                if (leftToRight) {\n                    currentLevel.push_back(node->val);\n                } else {\n                    currentLevel.push_front(node->val);\n                }\n                \n                if (node->left != nullptr) {\n                    queue.push(node->left);\n                }\n                if (node->right != nullptr) {\n                    queue.push(node->right);\n                }\n            }\n            \n            // Convert deque to vector and add to result\n            result.push_back(std::vector<int>(currentLevel.begin(), currentLevel.end()));\n            leftToRight = !leftToRight;\n        }\n        \n        return result;\n    }\n    \n    // Implementation using vector with reverse()\n    std::vector<std::vector<int>> zigzagLevelOrderReverse(TreeNode* root) {\n        std::vector<std::vector<int>> result;\n        \n        if (root == nullptr) {\n            return result;\n        }\n        \n        std::queue<TreeNode*> queue;\n        queue.push(root);\n        bool leftToRight = true;\n        \n        while (!queue.empty()) {\n            int levelSize = queue.size();\n            std::vector<int> currentLevel;\n            currentLevel.reserve(levelSize); // Reserve space for efficiency\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* node = queue.front();\n                queue.pop();\n                currentLevel.push_back(node->val); // Always add to the end\n                \n                if (node->left != nullptr) {\n                    queue.push(node->left);\n                }\n                if (node->right != nullptr) {\n                    queue.push(node->right);\n                }\n            }\n            \n            // If traversing right to left, reverse the vector\n            if (!leftToRight) {\n                std::reverse(currentLevel.begin(), currentLevel.end());\n            }\n            \n            result.push_back(currentLevel);\n            leftToRight = !leftToRight;\n        }\n        \n        return result;\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    std::vector<std::vector<int>> result = sol.zigzagLevelOrder(root);\n    /*RUNTIME CALC END*/\n    \n    for (int i = 0; i < result.size(); i++) {\n        const auto& level = result[i];\n        for (int j = 0; j < level.size(); j++) {\n            std::cout << level[j];\n            if (j < level.size() - 1) {\n                std::cout << \" \";\n            }\n        }\n        if (i < result.size() - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    // Clean up memory\n    deleteTree(root);\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import List, Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \"\"\"\n        Returns the zigzag level order traversal of the binary tree\n        :param root: The root of the binary tree\n        :return: List of lists, where each inner list contains node values at the same level in zigzag order\n        \"\"\"\n        # Implement your solution here\n        return []  # Replace with your implementation\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.zigzagLevelOrder(root)\n        # RUNTIME CALC END\n        \n        for i, level in enumerate(result):\n            print(' '.join(map(str, level)), end='' if i == len(result) - 1 else '\\n')\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\nfrom typing import List, Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \"\"\"\n        Returns the zigzag level order traversal of the binary tree\n        :param root: The root of the binary tree\n        :return: List of lists, where each inner list contains node values at the same level in zigzag order\n        \"\"\"\n        result = []\n        \n        if not root:\n            return result\n        \n        queue = deque([root])\n        left_to_right = True  # Flag to track zigzag direction\n        \n        while queue:\n            level_size = len(queue)\n            current_level = deque()  # Using deque for O(1) insertion at both ends\n            \n            # Process all nodes at the current level\n            for _ in range(level_size):\n                node = queue.popleft()\n                \n                # Add to the appropriate end of the deque based on traversal direction\n                if left_to_right:\n                    current_level.append(node.val)\n                else:\n                    current_level.appendleft(node.val)\n                \n                # Add children to queue for next level\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(list(current_level))\n            left_to_right = not left_to_right  # Flip the direction for the next level\n        \n        return result\n    \n    # Implementation using list with reverse()\n    def zigzagLevelOrderAlt(self, root: Optional[TreeNode]) -> List[List[int]]:\n        result = []\n        \n        if not root:\n            return result\n        \n        queue = deque([root])\n        left_to_right = True\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)  # Always add to the end\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            # If traversing right to left, reverse the list\n            if not left_to_right:\n                current_level.reverse()\n            \n            result.append(current_level)\n            left_to_right = not left_to_right\n        \n        return result\n\ndef create_node(val):\n    if val == \"-1\":\n        return None\n    return TreeNode(int(val))\n\ndef build_tree(values):\n    if not values:\n        return None\n    \n    root = create_node(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values):\n            node.left = create_node(values[i])\n            i += 1\n            if node.left:\n                queue.append(node.left)\n        \n        # Right child\n        if i < len(values):\n            node.right = create_node(values[i])\n            i += 1\n            if node.right:\n                queue.append(node.right)\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        root = None\n        if n > 0:\n            values = input().strip().split()\n            root = build_tree(values)\n        else:\n            input()  # Read empty line\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.zigzagLevelOrder(root)\n        # RUNTIME CALC END\n        \n        for i, level in enumerate(result):\n            print(' '.join(map(str, level)), end='' if i == len(result) - 1 else '\\n')\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "5\n3 9 20 -1 -1 15 7",
      "output": "3\n20 9\n15 7",
      "hidden": false,
      "explanation": "Basic test case for zigzag level order traversal"
    },
    {
      "input": "1\n1",
      "output": "1",
      "hidden": false,
      "explanation": "Test case with a single node"
    },
    {
      "input": "7\n1 2 3 4 5 6 7",
      "output": "1\n3 2\n4 5 6 7",
      "hidden": true,
      "explanation": "Test case with a complete binary tree"
    },
    {
      "input": "0\n",
      "output": "",
      "hidden": true,
      "explanation": "Test case with an empty tree"
    }
  ]
} 