{
  "title": "Serialize and Deserialize Binary Tree",
  "description": "Design an algorithm to serialize and deserialize a binary tree. Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nYour serialization and deserialization algorithm should ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\nInput Format:\n- The first line contains a single integer n, the number of nodes in the binary tree.\n- The second line contains n space-separated integers representing the values of the nodes. A value of -1 indicates a null node.\n- The input represents a level order traversal of the binary tree, where null nodes are represented by -1.\n\nOutput Format:\n- The output should be the serialized form of the binary tree, followed by the deserialized form to show that the original tree was reconstructed correctly.\n- The serialized form is a string representation of the tree.\n- The deserialized form is the level order traversal of the reconstructed tree, with null nodes represented by -1.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the tree is in the range [0, 10^4]",
    "-1000 <= Node.val <= 1000",
    "The input tree is guaranteed to be a binary tree"
  ],
  "examples": [
    {
      "input": "7\n1 2 3 -1 -1 4 5",
      "output": "1,2,#,#,3,4,#,#,5,#,#\n1 2 3 -1 -1 4 5",
      "explanation": "The binary tree is:\n    1\n   / \\\n  2   3\n     / \\\n    4   5\nThe serialized form uses ',' to separate values and '#' to represent null nodes.\nThe deserialized form shows the level order traversal of the reconstructed tree."
    },
    {
      "input": "1\n1",
      "output": "1,#,#\n1",
      "explanation": "The binary tree is:\n    1\nThe serialized form uses ',' to separate values and '#' to represent null nodes.\nThe deserialized form shows the level order traversal of the reconstructed tree."
    }
  ],
  "type": "programming",
  "difficultyLevel": "hard",
  "marks": 15,
  "tags": ["Tree", "Depth-First Search", "Breadth-First Search", "Design", "Binary Tree"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Facebook", "Amazon", "Microsoft", "Google", "LinkedIn", "Uber", "Bloomberg"],
  "hints": [
    "Consider using a pre-order traversal (root, left, right) for serialization",
    "Use special markers to represent null nodes in the serialized string",
    "For deserialization, parse the serialized string and reconstruct the tree using the same traversal order",
    "Recursion can simplify both the serialization and deserialization processes",
    "You can also use a level-order traversal (BFS) for serialization and deserialization"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Codec {\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        // Implement your serialization logic here\n        return \"\"; // Replace with your implementation\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        // Implement your deserialization logic here\n        return null; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Codec codec = new Codec();\n            String serialized = codec.serialize(root);\n            TreeNode deserialized = codec.deserialize(serialized);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(serialized);\n            printLevelOrder(deserialized);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n    \n    private static void printLevelOrder(TreeNode root) {\n        if (root == null) {\n            System.out.println();\n            return;\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                \n                if (node == null) {\n                    sb.append(\"-1 \");\n                } else {\n                    sb.append(node.val).append(\" \");\n                    queue.offer(node.left);\n                    queue.offer(node.right);\n                }\n            }\n        }\n        \n        // Remove trailing nulls and spaces\n        String output = sb.toString().trim();\n        while (output.endsWith(\"-1 -1\")) {\n            output = output.substring(0, output.lastIndexOf(\"-1 -1\")).trim();\n        }\n        \n        System.out.println(output);\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode() {}\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n    \n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Codec {\n    private static final String NULL_SYMBOL = \"#\";\n    private static final String DELIMITER = \",\";\n    \n    // Encodes a tree to a single string using pre-order traversal.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n    \n    private void serializeHelper(TreeNode node, StringBuilder sb) {\n        // Use pre-order traversal: root, left, right\n        if (node == null) {\n            sb.append(NULL_SYMBOL).append(DELIMITER);\n            return;\n        }\n        \n        // Append the current node's value\n        sb.append(node.val).append(DELIMITER);\n        \n        // Recursively serialize left and right subtrees\n        serializeHelper(node.left, sb);\n        serializeHelper(node.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data == null || data.isEmpty()) {\n            return null;\n        }\n        \n        Queue<String> nodes = new LinkedList<>(Arrays.asList(data.split(DELIMITER)));\n        return deserializeHelper(nodes);\n    }\n    \n    private TreeNode deserializeHelper(Queue<String> nodes) {\n        // Get the next value from the queue\n        String val = nodes.poll();\n        \n        // If it's a null marker, return null\n        if (val.equals(NULL_SYMBOL)) {\n            return null;\n        }\n        \n        // Create a new node with the current value\n        TreeNode node = new TreeNode(Integer.parseInt(val));\n        \n        // Recursively deserialize left and right subtrees\n        node.left = deserializeHelper(nodes);\n        node.right = deserializeHelper(nodes);\n        \n        return node;\n    }\
    \n    // Alternative implementation using level-order traversal (BFS)\n    public String serializeBFS(TreeNode root) {\n        if (root == null) {\n            return \"\";\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            \n            if (node == null) {\n                sb.append(NULL_SYMBOL).append(DELIMITER);\n            } else {\n                sb.append(node.val).append(DELIMITER);\n                queue.offer(node.left);\n                queue.offer(node.right);\n            }\n        }\n        \n        return sb.toString();\n    }\n    \n    public TreeNode deserializeBFS(String data) {\n        if (data == null || data.isEmpty()) {\n            return null;\n        }\n        \n        String[] values = data.split(DELIMITER);\n        TreeNode root = new TreeNode(Integer.parseInt(values[0]));\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode current = queue.poll();\n            \n            // Left child\n            if (!values[i].equals(NULL_SYMBOL)) {\n                current.left = new TreeNode(Integer.parseInt(values[i]));\n                queue.offer(current.left);\n            }\n            i++;\n            \n            // Right child (if there are still values left)\n            if (i < values.length && !values[i].equals(NULL_SYMBOL)) {\n                current.right = new TreeNode(Integer.parseInt(values[i]));\n                queue.offer(current.right);\n            }\n            i++;\n        }\n        \n        return root;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            TreeNode root = null;\n            if (n > 0) {\n                String[] values = br.readLine().trim().split(\" \");\n                root = buildTree(values);\n            } else {\n                br.readLine(); // Read empty line\n            }\n            \n            /*RUNTIME CALC START*/\n            Codec codec = new Codec();\n            String serialized = codec.serialize(root);\n            TreeNode deserialized = codec.deserialize(serialized);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(serialized);\n            printLevelOrder(deserialized);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0) {\n            return null;\n        }\n        \n        TreeNode root = createNode(values[0]);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (!queue.isEmpty() && i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length) {\n                curr.left = createNode(values[i++]);\n                if (curr.left != null) {\n                    queue.offer(curr.left);\n                }\n            }\n            \n            // Right child\n            if (i < values.length) {\n                curr.right = createNode(values[i++]);\n                if (curr.right != null) {\n                    queue.offer(curr.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n    \n    private static TreeNode createNode(String val) {\n        if (val.equals(\"-1\")) {\n            return null;\n        }\n        return new TreeNode(Integer.parseInt(val));\n    }\n    \n    private static void printLevelOrder(TreeNode root) {\n        if (root == null) {\n            System.out.println();\n            return;\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        boolean hasNonNullNode = true;\n        \n        while (hasNonNullNode) {\n            int levelSize = queue.size();\n            hasNonNullNode = false;\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                \n                if (node == null) {\n                    sb.append(\"-1 \");\n                    queue.offer(null);\n                    queue.offer(null);\n                } else {\n                    sb.append(node.val).append(\" \");\n                    queue.offer(node.left);\n                    queue.offer(node.right);\n                    \n                    // Check if we have more non-null nodes\n                    if (node.left != null || node.right != null) {\n                        hasNonNullNode = true;\n                    }\n                }\n            }\n        }\n        \n        // Remove trailing nulls and spaces\n        String output = sb.toString().trim();\n        while (output.endsWith(\"-1\")) {\n            output = output.substring(0, output.lastIndexOf(\"-1\")).trim();\n        }\n        \n        System.out.println(output);\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Codec {\npublic:\n    // Encodes a tree to a single string.\n    std::string serialize(TreeNode* root) {\n        // Implement your serialization logic here\n        return \"\"; // Replace with your implementation\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(std::string data) {\n        // Implement your deserialization logic here\n        return nullptr; // Replace with your implementation\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\nvoid printLevelOrder(TreeNode* root) {\n    if (root == nullptr) {\n        std::cout << std::endl;\n        return;\n    }\n    \n    std::queue<TreeNode*> q;\n    q.push(root);\n    bool hasNonNullNode = true;\n    \n    std::string output;\n    \n    while (hasNonNullNode) {\n        int levelSize = q.size();\n        hasNonNullNode = false;\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode* node = q.front();\n            q.pop();\n            \n            if (node == nullptr) {\n                output += \"-1 \";\n                q.push(nullptr);\n                q.push(nullptr);\n            } else {\n                output += std::to_string(node->val) + \" \";\n                q.push(node->left);\n                q.push(node->right);\n                \n                // Check if we have more non-null nodes\n                if (node->left != nullptr || node->right != nullptr) {\n                    hasNonNullNode = true;\n                }\n            }\n        }\n    }\n    \n    // Remove trailing nulls and spaces\n    while (output.ends_with(\"-1 \")) {\n        output = output.substr(0, output.rfind(\"-1 \"));\n    }\n    \n    // Remove last space if exists\n    if (output.ends_with(\" \")) {\n        output = output.substr(0, output.length() - 1);\n    }\n    \n    std::cout << output << std::endl;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Codec codec;\n    std::string serialized = codec.serialize(root);\n    TreeNode* deserialized = codec.deserialize(serialized);\n    /*RUNTIME CALC END*/\n    \n    std::cout << serialized << std::endl;\n    printLevelOrder(deserialized);\n    \n    // Clean up memory\n    deleteTree(root);\n    deleteTree(deserialized);\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Codec {\npublic:\n    const std::string NULL_SYMBOL = \"#\";\n    const std::string DELIMITER = \",\";\n    \n    // Encodes a tree to a single string using pre-order traversal.\n    std::string serialize(TreeNode* root) {\n        std::string result;\n        serializeHelper(root, result);\n        return result;\n    }\n    \n    void serializeHelper(TreeNode* node, std::string& result) {\n        // Use pre-order traversal: root, left, right\n        if (node == nullptr) {\n            result += NULL_SYMBOL + DELIMITER;\n            return;\n        }\n        \n        // Append the current node's value\n        result += std::to_string(node->val) + DELIMITER;\n        \n        // Recursively serialize left and right subtrees\n        serializeHelper(node->left, result);\n        serializeHelper(node->right, result);\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(std::string data) {\n        if (data.empty()) {\n            return nullptr;\n        }\n        \n        std::queue<std::string> nodes;\n        std::stringstream ss(data);\n        std::string item;\n        \n        // Split by delimiter\n        while (std::getline(ss, item, ',')) {\n            nodes.push(item);\n        }\n        \n        return deserializeHelper(nodes);\n    }\n    \n    TreeNode* deserializeHelper(std::queue<std::string>& nodes) {\n        // Get the next value from the queue\n        std::string val = nodes.front();\n        nodes.pop();\n        \n        // If it's a null marker, return null\n        if (val == NULL_SYMBOL) {\n            return nullptr;\n        }\n        \n        // Create a new node with the current value\n        TreeNode* node = new TreeNode(std::stoi(val));\n        \n        // Recursively deserialize left and right subtrees\n        node->left = deserializeHelper(nodes);\n        node->right = deserializeHelper(nodes);\n        \n        return node;\n    }\
    \n    // Alternative implementation using level-order traversal (BFS)\n    std::string serializeBFS(TreeNode* root) {\n        if (root == nullptr) {\n            return \"\";\n        }\n        \n        std::string result;\n        std::queue<TreeNode*> queue;\n        queue.push(root);\n        \n        while (!queue.empty()) {\n            TreeNode* node = queue.front();\n            queue.pop();\n            \n            if (node == nullptr) {\n                result += NULL_SYMBOL + DELIMITER;\n            } else {\n                result += std::to_string(node->val) + DELIMITER;\n                queue.push(node->left);\n                queue.push(node->right);\n            }\n        }\n        \n        return result;\n    }\n    \n    TreeNode* deserializeBFS(std::string data) {\n        if (data.empty()) {\n            return nullptr;\n        }\n        \n        std::vector<std::string> values;\n        std::stringstream ss(data);\n        std::string item;\n        \n        // Split by delimiter\n        while (std::getline(ss, item, ',')) {\n            values.push_back(item);\n        }\n        \n        TreeNode* root = new TreeNode(std::stoi(values[0]));\n        \n        std::queue<TreeNode*> queue;\n        queue.push(root);\n        \n        int i = 1;\n        while (!queue.empty() && i < values.size()) {\n            TreeNode* current = queue.front();\n            queue.pop();\n            \n            // Left child\n            if (values[i] != NULL_SYMBOL) {\n                current->left = new TreeNode(std::stoi(values[i]));\n                queue.push(current->left);\n            }\n            i++;\n            \n            // Right child (if there are still values left)\n            if (i < values.size() && values[i] != NULL_SYMBOL) {\n                current->right = new TreeNode(std::stoi(values[i]));\n                queue.push(current->right);\n            }\n            i++;\n        }\n        \n        return root;\n    }\n};\n\nTreeNode* createNode(const std::string& val) {\n    if (val == \"-1\") {\n        return nullptr;\n    }\n    return new TreeNode(std::stoi(val));\n}\n\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty()) {\n        return nullptr;\n    }\n    \n    TreeNode* root = createNode(values[0]);\n    std::queue<TreeNode*> q;\n    q.push(root);\n    \n    int i = 1;\n    while (!q.empty() && i < values.size()) {\n        TreeNode* curr = q.front();\n        q.pop();\n        \n        // Left child\n        if (i < values.size()) {\n            curr->left = createNode(values[i++]);\n            if (curr->left) {\n                q.push(curr->left);\n            }\n        }\n        \n        // Right child\n        if (i < values.size()) {\n            curr->right = createNode(values[i++]);\n            if (curr->right) {\n                q.push(curr->right);\n            }\n        }\n    }\n    \n    return root;\n}\n\nvoid printLevelOrder(TreeNode* root) {\n    if (root == nullptr) {\n        std::cout << std::endl;\n        return;\n    }\n    \n    std::queue<TreeNode*> q;\n    q.push(root);\n    bool hasNonNullNode = true;\n    \n    std::string output;\n    \n    while (hasNonNullNode) {\n        int levelSize = q.size();\n        hasNonNullNode = false;\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode* node = q.front();\n            q.pop();\n            \n            if (node == nullptr) {\n                output += \"-1 \";\n                q.push(nullptr);\n                q.push(nullptr);\n            } else {\n                output += std::to_string(node->val) + \" \";\n                q.push(node->left);\n                q.push(node->right);\n                \n                // Check if we have more non-null nodes\n                if (node->left != nullptr || node->right != nullptr) {\n                    hasNonNullNode = true;\n                }\n            }\n        }\n    }\n    \n    // Remove trailing nulls and spaces\n    while (output.size() > 3 && output.substr(output.size() - 3) == \"-1 \") {\n        output = output.substr(0, output.rfind(\"-1 \"));\n    }\n    \n    // Remove last space if exists\n    if (!output.empty() && output.back() == ' ') {\n        output.pop_back();\n    }\n    \n    std::cout << output << std::endl;\n}\n\n// Function to free memory of the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    TreeNode* root = nullptr;\n    std::vector<std::string> values;\n    \n    if (n > 0) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string val;\n        \n        while (iss >> val) {\n            values.push_back(val);\n        }\n        \n        root = buildTree(values);\n    } else {\n        std::string line;\n        std::getline(std::cin, line);\n    }\n    \n    /*RUNTIME CALC START*/\n    Codec codec;\n    std::string serialized = codec.serialize(root);\n    TreeNode* deserialized = codec.deserialize(serialized);\n    /*RUNTIME CALC END*/\n    \n    std::cout << serialized << std::endl;\n    printLevelOrder(deserialized);\n    \n    // Clean up memory\n    deleteTree(root);\n    deleteTree(deserialized);\n    \n    return 0;\n}"
    }
  ]
} 