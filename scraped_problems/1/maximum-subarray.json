{
  "title": "Maximum Subarray",
  "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\nA subarray is a contiguous part of an array.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - A single line containing an array of integers in the format [x1,x2,...,xn].\n\nOutput Format:\n- For each test case, print a single integer representing the sum of the subarray with the largest sum.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "examples": [
    {
      "input": "2\n[-2,1,-3,4,-1,2,1,-5,4]\n[5,4,-1,7,8]",
      "output": "6\n23",
      "explanation": "For test case 1: The subarray [4,-1,2,1] has the largest sum = 6.\nFor test case 2: The subarray [5,4,-1,7,8] has the largest sum = 23."
    }
  ],
  "type": "programming",
  "difficultyLevel": "easy",
  "marks": 5,
  "tags": ["Array", "Divide and Conquer", "Dynamic Programming"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Bloomberg", "Adobe", "Oracle"],
  "hints": [
    "If we know the maximum subarray sum ending at position i-1, can we use it to compute the maximum subarray sum ending at position i?",
    "Kadane's algorithm: At each position, we decide whether to start a new subarray or extend the existing one",
    "For each element, we need to choose between adding it to the current subarray or starting a new subarray from it"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the sum of the contiguous subarray with the largest sum.\n     * @param nums The input array of integers.\n     * @return The sum of the subarray with the largest sum.\n     */\n    public int maxSubArray(int[] nums) {\n        // Implement your solution here\n        return 0; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim()); // Read number of test cases\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the array\n                String line = br.readLine().trim();\n                int[] nums;\n                if (line.length() <= 2) { // [], [, ] or empty string\n                    nums = new int[0];\n                } else {\n                    // Remove brackets\n                    String content = line.substring(1, line.length() - 1).trim();\n                    String[] strNums = content.split(\",\");\n                    nums = new int[strNums.length];\n                    for (int j = 0; j < strNums.length; j++) {\n                        nums[j] = Integer.parseInt(strNums[j].trim());\n                    }\n                }\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                int result = sol.maxSubArray(nums);\n                /*RUNTIME CALC END*/\n                \n                output.append(result);\n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the sum of the contiguous subarray with the largest sum.\n     * @param nums The input array of integers.\n     * @return The sum of the subarray with the largest sum.\n     */\n    public int maxSubArray(int[] nums) {\n        // Implementation of Kadane's algorithm\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int currentMax = nums[0];\n        int globalMax = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            // Either extend previous subarray or start a new one from current element\n            currentMax = Math.max(nums[i], currentMax + nums[i]);\n            \n            // Update global maximum if current subarray has larger sum\n            globalMax = Math.max(globalMax, currentMax);\n        }\n        \n        return globalMax;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim()); // Read number of test cases\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the array\n                String line = br.readLine().trim();\n                int[] nums;\n                if (line.length() <= 2) { // [], [, ] or empty string\n                    nums = new int[0];\n                } else {\n                    // Remove brackets\n                    String content = line.substring(1, line.length() - 1).trim();\n                    String[] strNums = content.split(\",\");\n                    nums = new int[strNums.length];\n                    for (int j = 0; j < strNums.length; j++) {\n                        nums[j] = Integer.parseInt(strNums[j].trim());\n                    }\n                }\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                int result = sol.maxSubArray(nums);\n                /*RUNTIME CALC END*/\n                \n                output.append(result);\n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nclass Solution {\npublic:\n    int maxSubArray(std::vector<int>& nums) {\n        // Implement your solution here\n        return 0;  // Replace with your implementation\n    }\n};\n\n// Helper function to parse array from string\nstd::vector<int> parseArray(const std::string& str) {\n    std::vector<int> result;\n    std::string num;\n    for (char ch : str) {\n        if ((ch >= '0' && ch <= '9') || ch == '-') {\n            num += ch;\n        } else if (!num.empty()) {\n            result.push_back(std::stoi(num));\n            num.clear();\n        }\n    }\n    if (!num.empty()) {\n        result.push_back(std::stoi(num));\n    }\n    return result;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int t;\n    std::cin >> t;\n    std::cin.ignore();\n\n    for (int i = 0; i < t; ++i) {\n        // Parse input array\n        std::string line;\n        std::getline(std::cin, line);\n        std::vector<int> nums = parseArray(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        int result = sol.maxSubArray(nums);\n        /*RUNTIME CALC END*/\n        \n        // Print output\n        std::cout << result;\n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nclass Solution {\npublic:\n    int maxSubArray(std::vector<int>& nums) {\n        // Implementation of Kadane's algorithm\n        if (nums.empty()) {\n            return 0;\n        }\n        \n        int currentMax = nums[0];\n        int globalMax = nums[0];\n        \n        for (int i = 1; i < nums.size(); i++) {\n            // Either extend previous subarray or start a new one from current element\n            currentMax = std::max(nums[i], currentMax + nums[i]);\n            \n            // Update global maximum if current subarray has larger sum\n            globalMax = std::max(globalMax, currentMax);\n        }\n        \n        return globalMax;\n    }\n};\n\n// Helper function to parse array from string\nstd::vector<int> parseArray(const std::string& str) {\n    std::vector<int> result;\n    std::string num;\n    for (char ch : str) {\n        if ((ch >= '0' && ch <= '9') || ch == '-') {\n            num += ch;\n        } else if (!num.empty()) {\n            result.push_back(std::stoi(num));\n            num.clear();\n        }\n    }\n    if (!num.empty()) {\n        result.push_back(std::stoi(num));\n    }\n    return result;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int t;\n    std::cin >> t;\n    std::cin.ignore();\n\n    for (int i = 0; i < t; ++i) {\n        // Parse input array\n        std::string line;\n        std::getline(std::cin, line);\n        std::vector<int> nums = parseArray(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        int result = sol.maxSubArray(nums);\n        /*RUNTIME CALC END*/\n        \n        // Print output\n        std::cout << result;\n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import List\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        # Implement your solution here\n        return 0  # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the array\n                line = input().strip()\n                if line in [\"[]\", \"[\", \"]\", \"\"]:\n                    nums = []\n                else:\n                    # Remove brackets and split by comma\n                    content = line[1:-1].strip()\n                    nums = [int(x.strip()) for x in content.split(',')]\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.maxSubArray(nums)\n                # RUNTIME CALC END\n                \n                results.append(str(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import List\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        # Implementation of Kadane's algorithm\n        if not nums:\n            return 0\n            \n        current_max = nums[0]\n        global_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            # Either extend previous subarray or start a new one from current element\n            current_max = max(nums[i], current_max + nums[i])\n            \n            # Update global maximum if current subarray has larger sum\n            global_max = max(global_max, current_max)\n            \n        return global_max\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the array\n                line = input().strip()\n                if line in [\"[]\", \"[\", \"]\", \"\"]:\n                    nums = []\n                else:\n                    # Remove brackets and split by comma\n                    content = line[1:-1].strip()\n                    nums = [int(x.strip()) for x in content.split(',')]\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.maxSubArray(nums)\n                # RUNTIME CALC END\n                \n                results.append(str(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "2\n[-2,1,-3,4,-1,2,1,-5,4]\n[5,4,-1,7,8]",
      "output": "6\n23",
      "hidden": false,
      "explanation": "Basic test cases for maximum subarrays"
    },
    {
      "input": "3\n[1]\n[-1]\n[-2,-5,-1,-8,-3,-9]",
      "output": "1\n-1\n-1",
      "hidden": true,
      "explanation": "Edge cases including single-element arrays and arrays with only negative numbers"
    }
  ]
} 