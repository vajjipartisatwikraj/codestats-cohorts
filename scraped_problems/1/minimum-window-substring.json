{
  "title": "Minimum Window Substring",
  "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nThe testcases will be generated such that the answer is unique.\n\nA substring is a contiguous sequence of characters within the string.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains the string s.\n  - The second line contains the string t.\n\nOutput Format:\n- For each test case, print the minimum window substring. If no such substring exists, print \"\".",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= s.length, t.length <= 10^5",
    "s and t consist of uppercase and lowercase English letters"
  ],
  "examples": [
    {
      "input": "3\nADOBECODEBANC\nABC\na\na\na\nb",
      "output": "BANC\na\n\"\"",
      "explanation": "Test case 1: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\nTest case 2: The entire string s is the minimum window.\nTest case 3: There is no substring in s that contains all characters in t."
    }
  ],
  "type": "programming",
  "difficultyLevel": "hard",
  "marks": 15,
  "tags": ["Hash Table", "String", "Sliding Window"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Facebook", "Microsoft", "Apple", "Google", "Uber", "Bloomberg"],
  "hints": [
    "Use the sliding window technique to find a valid substring",
    "Keep track of the frequency of characters from string t that you need to match",
    "Expand the window to the right until all characters in t are covered, then contract from the left to find the minimum window",
    "Use two hash maps or arrays to track character frequencies in t and the current window"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the minimum window substring of s that contains all characters in t.\n     * @param s The source string.\n     * @param t The target string containing characters to be included.\n     * @return The minimum window substring, or empty string if not found.\n     */\n    public String minWindow(String s, String t) {\n        // Implement your solution here\n        return \"\"; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int testCases = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < testCases; i++) {\n                String s = br.readLine().trim();\n                String t = br.readLine().trim();\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                String result = sol.minWindow(s, t);\n                /*RUNTIME CALC END*/\n                \n                output.append(result.isEmpty() ? \"\\\"\\\"\" : result);\n                \n                if (i < testCases - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the minimum window substring of s that contains all characters in t.\n     * @param s The source string.\n     * @param t The target string containing characters to be included.\n     * @return The minimum window substring, or empty string if not found.\n     */\n    public String minWindow(String s, String t) {\n        if (s.isEmpty() || t.isEmpty()) {\n            return \"\";\n        }\n        \n        // Character frequency map for string t\n        Map<Character, Integer> targetFreq = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            targetFreq.put(c, targetFreq.getOrDefault(c, 0) + 1);\n        }\n        \n        // Variables for sliding window\n        int required = targetFreq.size(); // Number of unique characters in t\n        int formed = 0; // Number of unique characters in current window that match the requirement\n        Map<Character, Integer> windowFreq = new HashMap<>();\n        \n        // Variables to track the minimum window\n        int[] ans = {-1, 0, 0}; // [window_length, left, right]\n        int left = 0, right = 0;\n        \n        while (right < s.length()) {\n            // Add current character to window\n            char c = s.charAt(right);\n            windowFreq.put(c, windowFreq.getOrDefault(c, 0) + 1);\n            \n            // Check if we've matched a character from t with the required frequency\n            if (targetFreq.containsKey(c) && windowFreq.get(c).intValue() == targetFreq.get(c).intValue()) {\n                formed++;\n            }\n            \n            // Try to contract the window from the left\n            while (left <= right && formed == required) {\n                c = s.charAt(left);\n                \n                // Save the smallest window so far\n                if (ans[0] == -1 || right - left + 1 < ans[0]) {\n                    ans[0] = right - left + 1;\n                    ans[1] = left;\n                    ans[2] = right;\n                }\n                \n                // Remove the leftmost character from the window\n                windowFreq.put(c, windowFreq.get(c) - 1);\n                \n                // If removing this character breaks our window, decrement formed\n                if (targetFreq.containsKey(c) && windowFreq.get(c).intValue() < targetFreq.get(c).intValue()) {\n                    formed--;\n                }\n                \n                left++;\n            }\n            \n            right++;\n        }\n        \n        return ans[0] == -1 ? \"\" : s.substring(ans[1], ans[2] + 1);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int testCases = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < testCases; i++) {\n                String s = br.readLine().trim();\n                String t = br.readLine().trim();\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                String result = sol.minWindow(s, t);\n                /*RUNTIME CALC END*/\n                \n                output.append(result.isEmpty() ? \"\\\"\\\"\" : result);\n                \n                if (i < testCases - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <climits>\n\nclass Solution {\npublic:\n    std::string minWindow(std::string s, std::string t) {\n        // Your code here\n        return \"\"; // Replace with your implementation\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n\n    for (int i = 0; i < t; ++i) {\n        std::string s, pattern;\n        std::getline(std::cin, s);\n        std::getline(std::cin, pattern);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        std::string result = sol.minWindow(s, pattern);\n        /*RUNTIME CALC END*/\n        \n        if (result.empty()) {\n            std::cout << \"\\\"\\\"\";\n        } else {\n            std::cout << result;\n        }\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <climits>\n\nclass Solution {\npublic:\n    std::string minWindow(std::string s, std::string t) {\n        if (s.empty() || t.empty()) {\n            return \"\";\n        }\n        \n        // Character frequency map for string t\n        std::unordered_map<char, int> targetFreq;\n        for (char c : t) {\n            targetFreq[c]++;\n        }\n        \n        // Variables for sliding window\n        int required = targetFreq.size(); // Number of unique characters in t\n        int formed = 0; // Number of unique characters in current window that match the requirement\n        std::unordered_map<char, int> windowFreq;\n        \n        // Variables to track the minimum window\n        int minLen = INT_MAX;\n        int startIdx = 0;\n        \n        int left = 0, right = 0;\n        \n        while (right < s.length()) {\n            // Add current character to window\n            char c = s[right];\n            windowFreq[c]++;\n            \n            // Check if we've matched a character from t with the required frequency\n            if (targetFreq.count(c) && windowFreq[c] == targetFreq[c]) {\n                formed++;\n            }\n            \n            // Try to contract the window from the left\n            while (left <= right && formed == required) {\n                c = s[left];\n                \n                // Save the smallest window so far\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1;\n                    startIdx = left;\n                }\n                \n                // Remove the leftmost character from the window\n                windowFreq[c]--;\n                \n                // If removing this character breaks our window, decrement formed\n                if (targetFreq.count(c) && windowFreq[c] < targetFreq[c]) {\n                    formed--;\n                }\n                \n                left++;\n            }\n            \n            right++;\n        }\n        \n        return minLen == INT_MAX ? \"\" : s.substr(startIdx, minLen);\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n\n    for (int i = 0; i < t; ++i) {\n        std::string s, pattern;\n        std::getline(std::cin, s);\n        std::getline(std::cin, pattern);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        std::string result = sol.minWindow(s, pattern);\n        /*RUNTIME CALC END*/\n        \n        if (result.empty()) {\n            std::cout << \"\\\"\\\"\";\n        } else {\n            std::cout << result;\n        }\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        # Your code here\n        return \"\" # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            test_cases = int(input().strip())\n            \n            results = []\n            for _ in range(test_cases):\n                s = input().strip()\n                t = input().strip()\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.minWindow(s, t)\n                # RUNTIME CALC END\n                \n                results.append('\"\"' if not result else result)\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n        \n        # Character frequency map for string t\n        target_counter = Counter(t)\n        required = len(target_counter)  # Number of unique characters in t\n        \n        # Variables for sliding window\n        window_counter = {}  # Current character frequency in window\n        formed = 0  # Number of unique characters in window that match the requirement\n        \n        # Variables to track the minimum window\n        min_len = float('inf')\n        start_idx = 0\n        \n        left = right = 0\n        \n        while right < len(s):\n            # Add current character to window\n            char = s[right]\n            window_counter[char] = window_counter.get(char, 0) + 1\n            \n            # Check if we've matched a character from t with the required frequency\n            if char in target_counter and window_counter[char] == target_counter[char]:\n                formed += 1\n            \n            # Try to contract the window from the left\n            while left <= right and formed == required:\n                char = s[left]\n                \n                # Save the smallest window so far\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    start_idx = left\n                \n                # Remove the leftmost character from the window\n                window_counter[char] -= 1\n                \n                # If removing this character breaks our window, decrement formed\n                if char in target_counter and window_counter[char] < target_counter[char]:\n                    formed -= 1\n                \n                left += 1\n            \n            right += 1\n        \n        return \"\" if min_len == float('inf') else s[start_idx:start_idx + min_len]\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            test_cases = int(input().strip())\n            \n            results = []\n            for _ in range(test_cases):\n                s = input().strip()\n                t = input().strip()\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.minWindow(s, t)\n                # RUNTIME CALC END\n                \n                results.append('\"\"' if not result else result)\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "3\nADOBECODEBANC\nABC\na\na\na\nb",
      "output": "BANC\na\n\"\"",
      "hidden": false,
      "explanation": "Combined test cases with valid minimum window, exact match, and no valid window"
    },
    {
      "input": "3\naaaaaaaaaa\naaa\nbbbaabaa\naba\nabcdabcd\nacccc",
      "output": "aaa\nabaa\n\"\"",
      "hidden": true,
      "explanation": "Edge cases with repeated characters and multiple possible windows"
    }
  ]
} 