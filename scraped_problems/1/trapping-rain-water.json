{
  "title": "Trapping Rain Water",
  "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - A single line containing an array of integers in the format [x1,x2,...,xn] representing the elevation map.\n\nOutput Format:\n- For each test case, print a single integer representing the amount of rainwater trapped.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= n <= 2 * 10^4",
    "0 <= height[i] <= 10^5"
  ],
  "examples": [
    {
      "input": "5\n[0,1,0,2,1,0,1,3,2,1,2,1]\n[4,2,0,3,2,5]\n[1,2,3,4,5]\n[5,4,3,2,1]\n[0,0,0,0]",
      "output": "6\n9\n0\n0\n0",
      "explanation": "Test case 1: The elevation map is [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water are trapped.\nTest case 2: The elevation map is [4,2,0,3,2,5]. In this case, 9 units of rain water are trapped.\nTest case 3: The elevation map is [1,2,3,4,5]. No water can be trapped as it is strictly increasing.\nTest case 4: The elevation map is [5,4,3,2,1]. No water can be trapped as it is strictly decreasing.\nTest case 5: The elevation map is [0,0,0,0]. No water can be trapped as there are no elevations."
    }
  ],
  "type": "programming",
  "difficultyLevel": "hard",
  "marks": 15,
  "tags": ["Array", "Two Pointers", "Dynamic Programming", "Stack"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Goldman Sachs", "Microsoft", "Facebook", "Google", "Apple", "ByteDance"],
  "hints": [
    "For each element in the array, we need to find the maximum level of water it can trap",
    "The water level at each position depends on the maximum height to its left and right",
    "Consider using two pointers to track the maximum height from both directions",
    "Alternatively, you can use dynamic programming to precompute left max and right max arrays"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Computes how much water can be trapped after raining.\n     * @param height Array of heights representing the elevation map.\n     * @return The amount of rainwater trapped.\n     */\n    public int trap(int[] height) {\n        // Implement your solution here\n        return 0; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim()); // Read number of test cases\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the array\n                String line = br.readLine().trim();\n                int[] height;\n                if (line.length() <= 2) { // [], [, ] or empty string\n                    height = new int[0];\n                } else {\n                    // Remove brackets\n                    String content = line.substring(1, line.length() - 1).trim();\n                    String[] strHeight = content.split(\",\");\n                    height = new int[strHeight.length];\n                    for (int j = 0; j < strHeight.length; j++) {\n                        height[j] = Integer.parseInt(strHeight[j].trim());\n                    }\n                }\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                int result = sol.trap(height);\n                /*RUNTIME CALC END*/\n                \n                output.append(result);\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Computes how much water can be trapped after raining.\n     * @param height Array of heights representing the elevation map.\n     * @return The amount of rainwater trapped.\n     */\n    public int trap(int[] height) {\n        if (height == null || height.length <= 2) {\n            return 0;\n        }\n        \n        int n = height.length;\n        int left = 0, right = n - 1;\n        int leftMax = 0, rightMax = 0;\n        int result = 0;\n        \n        // Two pointers approach\n        while (left < right) {\n            // Update the maximum height seen from left and right\n            leftMax = Math.max(leftMax, height[left]);\n            rightMax = Math.max(rightMax, height[right]);\n            \n            // If left height is smaller, process left side\n            if (height[left] < height[right]) {\n                result += leftMax - height[left];\n                left++;\n            } else { // Otherwise, process right side\n                result += rightMax - height[right];\n                right--;\n            }\n        }\n        \n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim()); // Read number of test cases\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the array\n                String line = br.readLine().trim();\n                int[] height;\n                if (line.length() <= 2) { // [], [, ] or empty string\n                    height = new int[0];\n                } else {\n                    // Remove brackets\n                    String content = line.substring(1, line.length() - 1).trim();\n                    String[] strHeight = content.split(\",\");\n                    height = new int[strHeight.length];\n                    for (int j = 0; j < strHeight.length; j++) {\n                        height[j] = Integer.parseInt(strHeight[j].trim());\n                    }\n                }\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                int result = sol.trap(height);\n                /*RUNTIME CALC END*/\n                \n                output.append(result);\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int trap(std::vector<int>& height) {\n        // Your code here\n        return 0; // Replace with your implementation\n    }\n};\n\n// Helper function to parse array from string\nstd::vector<int> parseArray(const std::string& str) {\n    std::vector<int> result;\n    std::string num;\n    for (char ch : str) {\n        if (ch >= '0' && ch <= '9') {\n            num += ch;\n        } else if (!num.empty()) {\n            result.push_back(std::stoi(num));\n            num.clear();\n        }\n    }\n    if (!num.empty()) {\n        result.push_back(std::stoi(num));\n    }\n    return result;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n\n    for (int i = 0; i < t; ++i) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::vector<int> height = parseArray(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        int result = sol.trap(height);\n        /*RUNTIME CALC END*/\n        \n        std::cout << result;\n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int trap(std::vector<int>& height) {\n        if (height.size() <= 2) {\n            return 0;\n        }\n        \n        int n = height.size();\n        int left = 0, right = n - 1;\n        int leftMax = 0, rightMax = 0;\n        int result = 0;\n        \n        // Two pointers approach\n        while (left < right) {\n            // Update the maximum height seen from left and right\n            leftMax = std::max(leftMax, height[left]);\n            rightMax = std::max(rightMax, height[right]);\n            \n            // If left height is smaller, process left side\n            if (height[left] < height[right]) {\n                result += leftMax - height[left];\n                left++;\n            } else { // Otherwise, process right side\n                result += rightMax - height[right];\n                right--;\n            }\n        }\n        \n        return result;\n    }\n};\n\n// Helper function to parse array from string\nstd::vector<int> parseArray(const std::string& str) {\n    std::vector<int> result;\n    std::string num;\n    for (char ch : str) {\n        if (ch >= '0' && ch <= '9') {\n            num += ch;\n        } else if (!num.empty()) {\n            result.push_back(std::stoi(num));\n            num.clear();\n        }\n    }\n    if (!num.empty()) {\n        result.push_back(std::stoi(num));\n    }\n    return result;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n\n    for (int i = 0; i < t; ++i) {\n        std::string line;\n        std::getline(std::cin, line);\n        std::vector<int> height = parseArray(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        int result = sol.trap(height);\n        /*RUNTIME CALC END*/\n        \n        std::cout << result;\n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import List\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        # Your code here\n        return 0 # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the array\n                line = input().strip()\n                if line in [\"[]\", \"[\", \"]\", \"\"]:\n                    height = []\n                else:\n                    # Remove brackets and split by comma\n                    content = line[1:-1].strip()\n                    height = [int(x.strip()) for x in content.split(',')]\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.trap(height)\n                # RUNTIME CALC END\n                \n                results.append(str(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import List\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height or len(height) <= 2:\n            return 0\n        \n        n = len(height)\n        left, right = 0, n - 1\n        left_max = right_max = 0\n        result = 0\n        \n        # Two pointers approach\n        while left < right:\n            # Update the maximum height seen from left and right\n            left_max = max(left_max, height[left])\n            right_max = max(right_max, height[right])\n            \n            # If left height is smaller, process left side\n            if height[left] < height[right]:\n                result += left_max - height[left]\n                left += 1\n            else: # Otherwise, process right side\n                result += right_max - height[right]\n                right -= 1\n        \n        return result\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the array\n                line = input().strip()\n                if line in [\"[]\", \"[\", \"]\", \"\"]:\n                    height = []\n                else:\n                    # Remove brackets and split by comma\n                    content = line[1:-1].strip()\n                    height = [int(x.strip()) for x in content.split(',')]\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.trap(height)\n                # RUNTIME CALC END\n                \n                results.append(str(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "5\n[0,1,0,2,1,0,1,3,2,1,2,1]\n[4,2,0,3,2,5]\n[1,2,3,4,5]\n[5,4,3,2,1]\n[0,0,0,0]",
      "output": "6\n9\n0\n0\n0",
      "hidden": false,
      "explanation": "Combined test cases including regular trap patterns, increasing heights, decreasing heights, and flat ground"
    },
    {
      "input": "4\n[]\n[3]\n[3,3,3,3,3]\n[5,2,1,2,1,5]",
      "output": "0\n0\n0\n14",
      "hidden": true,
      "explanation": "Edge cases including empty array, single element, flat ground with height, and symmetrical pattern"
    }
  ]
} 