{
  "title": "Intersection of Two Linked Lists",
  "description": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\n\nNote that the linked lists must retain their original structure after the function returns.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains an array representing the nodes of linked list A.\n  - The second line contains an array representing the nodes of linked list B.\n  - The third line contains a single integer indicating the index where the intersection starts (0-indexed). If it's -1, there is no intersection.\n  - The fourth line contains a single integer indicating the index in A where the intersection node is located (0-indexed). This is only used for creating the test case.\n\nOutput Format:\n- For each test case, print the value of the node where the two lists intersect, or \"null\" if they don't intersect.\n\nNote: In the provided code template, the linked lists and intersection are created for you. You just need to implement the algorithm to find the intersection.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in each linked list is in the range [1, 10^4]",
    "-10^5 <= Node.val <= 10^5",
    "0 <= intersectVal <= 10^5",
    "At most one of the linked lists can be empty"
  ],
  "examples": [
    {
      "input": "2\n[4,1,8,4,5]\n[5,6,1,8,4,5]\n2\n2\n[1,9,1,2,4]\n[3,2,4]\n3\n3",
      "output": "8\n2",
      "explanation": "Test case 1: The two lists intersect at the node with value 8.\nTest case 2: The two lists intersect at the node with value 2."
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Linked List", "Two Pointers", "Hash Table"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg"],
  "hints": [
    "The brute force approach is to check every node in list A against every node in list B, but this is inefficient",
    "You can use a hash set to store all nodes from one list, then check if any node in the other list is in the set",
    "A more elegant approach uses two pointers that walk through both lists, switching to the head of the other list when they reach the end",
    "If there is an intersection, the pointers will meet at the intersection node"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Find the node where two linked lists intersect.\n     * @param headA The head of the first linked list.\n     * @param headB The head of the second linked list.\n     * @return The intersection node, or null if there is no intersection.\n     */\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // Implement your solution here\n        return null; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse lists A and B\n                String lineA = br.readLine().trim();\n                String lineB = br.readLine().trim();\n                \n                // Parse intersection indices\n                int intersectVal = Integer.parseInt(br.readLine().trim()); // Value at intersection\n                int skipA = Integer.parseInt(br.readLine().trim()); // Skip A nodes before intersection\n                \n                // Create linked lists with intersection\n                Pair<ListNode, ListNode> lists = createIntersectedLists(lineA, lineB, intersectVal, skipA);\n                ListNode headA = lists.first;\n                ListNode headB = lists.second;\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.getIntersectionNode(headA, headB);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                if (result != null) {\n                    output.append(result.val);\n                } else {\n                    output.append(\"null\");\n                }\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static class Pair<T, U> {\n        public final T first;\n        public final U second;\n        \n        public Pair(T first, U second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n    \n    private static Pair<ListNode, ListNode> createIntersectedLists(String lineA, String lineB, int intersectVal, int skipA) {\n        if (lineA.equals(\"[]\") || lineB.equals(\"[]\")) {\n            return new Pair<>(null, null);\n        }\n        \n        // Parse list A\n        String[] valuesA = lineA.substring(1, lineA.length() - 1).split(\",\");\n        ListNode[] nodesA = new ListNode[valuesA.length];\n        \n        for (int i = 0; i < valuesA.length; i++) {\n            nodesA[i] = new ListNode(Integer.parseInt(valuesA[i].trim()));\n        }\n        \n        // Link list A\n        for (int i = 0; i < valuesA.length - 1; i++) {\n            nodesA[i].next = nodesA[i + 1];\n        }\n        \n        // Parse list B\n        String[] valuesB = lineB.substring(1, lineB.length() - 1).split(\",\");\n        ListNode[] nodesB = new ListNode[valuesB.length];\n        \n        for (int i = 0; i < valuesB.length; i++) {\n            nodesB[i] = new ListNode(Integer.parseInt(valuesB[i].trim()));\n        }\n        \n        // If intersection exists\n        if (intersectVal != -1 && skipA < valuesA.length) {\n            // Link list B up to intersection point\n            int skipB = valuesB.length - (valuesA.length - skipA);\n            \n            for (int i = 0; i < skipB - 1; i++) {\n                nodesB[i].next = nodesB[i + 1];\n            }\n            \n            // Connect B to the intersection point in A\n            if (skipB > 0) {\n                nodesB[skipB - 1].next = nodesA[skipA];\n            } else {\n                // B starts at the intersection\n                nodesB[0] = nodesA[skipA];\n            }\n        } else {\n            // No intersection, just link B normally\n            for (int i = 0; i < valuesB.length - 1; i++) {\n                nodesB[i].next = nodesB[i + 1];\n            }\n        }\n        \n        return new Pair<>(nodesA[0], nodesB[0]);\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Find the node where two linked lists intersect.\n     * @param headA The head of the first linked list.\n     * @param headB The head of the second linked list.\n     * @return The intersection node, or null if there is no intersection.\n     */\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // Elegant two-pointer approach\n        if (headA == null || headB == null) {\n            return null; // No intersection possible\n        }\n        \n        // Initialize pointers for both lists\n        ListNode pointerA = headA;\n        ListNode pointerB = headB;\n        \n        // Loop until pointers meet or both reach the end (null)\n        while (pointerA != pointerB) {\n            // When pointer A reaches end, switch to head of list B\n            // If no intersection, both will eventually become null and exit loop\n            pointerA = (pointerA == null) ? headB : pointerA.next;\n            \n            // When pointer B reaches end, switch to head of list A\n            pointerB = (pointerB == null) ? headA : pointerB.next;\n        }\n        \n        // Either found intersection or both are null (no intersection)\n        return pointerA;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse lists A and B\n                String lineA = br.readLine().trim();\n                String lineB = br.readLine().trim();\n                \n                // Parse intersection indices\n                int intersectVal = Integer.parseInt(br.readLine().trim()); // Value at intersection\n                int skipA = Integer.parseInt(br.readLine().trim()); // Skip A nodes before intersection\n                \n                // Create linked lists with intersection\n                Pair<ListNode, ListNode> lists = createIntersectedLists(lineA, lineB, intersectVal, skipA);\n                ListNode headA = lists.first;\n                ListNode headB = lists.second;\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.getIntersectionNode(headA, headB);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                if (result != null) {\n                    output.append(result.val);\n                } else {\n                    output.append(\"null\");\n                }\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static class Pair<T, U> {\n        public final T first;\n        public final U second;\n        \n        public Pair(T first, U second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n    \n    private static Pair<ListNode, ListNode> createIntersectedLists(String lineA, String lineB, int intersectVal, int skipA) {\n        if (lineA.equals(\"[]\") || lineB.equals(\"[]\")) {\n            return new Pair<>(null, null);\n        }\n        \n        // Parse list A\n        String[] valuesA = lineA.substring(1, lineA.length() - 1).split(\",\");\n        ListNode[] nodesA = new ListNode[valuesA.length];\n        \n        for (int i = 0; i < valuesA.length; i++) {\n            nodesA[i] = new ListNode(Integer.parseInt(valuesA[i].trim()));\n        }\n        \n        // Link list A\n        for (int i = 0; i < valuesA.length - 1; i++) {\n            nodesA[i].next = nodesA[i + 1];\n        }\n        \n        // Parse list B\n        String[] valuesB = lineB.substring(1, lineB.length() - 1).split(\",\");\n        ListNode[] nodesB = new ListNode[valuesB.length];\n        \n        for (int i = 0; i < valuesB.length; i++) {\n            nodesB[i] = new ListNode(Integer.parseInt(valuesB[i].trim()));\n        }\n        \n        // If intersection exists\n        if (intersectVal != -1 && skipA < valuesA.length) {\n            // Link list B up to intersection point\n            int skipB = valuesB.length - (valuesA.length - skipA);\n            \n            for (int i = 0; i < skipB - 1; i++) {\n                nodesB[i].next = nodesB[i + 1];\n            }\n            \n            // Connect B to the intersection point in A\n            if (skipB > 0) {\n                nodesB[skipB - 1].next = nodesA[skipA];\n            } else {\n                // B starts at the intersection\n                nodesB[0] = nodesA[skipA];\n            }\n        } else {\n            // No intersection, just link B normally\n            for (int i = 0; i < valuesB.length - 1; i++) {\n                nodesB[i].next = nodesB[i + 1];\n            }\n        }\n        \n        return new Pair<>(nodesA[0], nodesB[0]);\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_set>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // Implement your solution here\n        return nullptr; // Replace with your implementation\n    }\n};\n\n// Helper functions to create intersected linked lists\nstd::pair<ListNode*, ListNode*> createIntersectedLists(const std::string& lineA, const std::string& lineB, int intersectVal, int skipA) {\n    if (lineA == \"[]\" || lineB == \"[]\") {\n        return {nullptr, nullptr};\n    }\n    \n    // Parse list A\n    std::string contentA = lineA.substr(1, lineA.length() - 2);\n    std::istringstream ssA(contentA);\n    std::string token;\n    \n    std::vector<ListNode*> nodesA;\n    \n    while (std::getline(ssA, token, ',')) {\n        nodesA.push_back(new ListNode(std::stoi(token)));\n    }\n    \n    // Link list A\n    for (size_t i = 0; i < nodesA.size() - 1; i++) {\n        nodesA[i]->next = nodesA[i + 1];\n    }\n    \n    // Parse list B\n    std::string contentB = lineB.substr(1, lineB.length() - 2);\n    std::istringstream ssB(contentB);\n    \n    std::vector<ListNode*> nodesB;\n    \n    while (std::getline(ssB, token, ',')) {\n        nodesB.push_back(new ListNode(std::stoi(token)));\n    }\n    \n    // If intersection exists\n    if (intersectVal != -1 && skipA < static_cast<int>(nodesA.size())) {\n        // Link list B up to intersection point\n        int skipB = nodesB.size() - (nodesA.size() - skipA);\n        \n        for (int i = 0; i < skipB - 1; i++) {\n            nodesB[i]->next = nodesB[i + 1];\n        }\n        \n        // Connect B to the intersection point in A\n        if (skipB > 0) {\n            nodesB[skipB - 1]->next = nodesA[skipA];\n        } else {\n            // B starts at the intersection\n            delete nodesB[0]; // Avoid memory leak\n            nodesB[0] = nodesA[skipA];\n        }\n    } else {\n        // No intersection, just link B normally\n        for (size_t i = 0; i < nodesB.size() - 1; i++) {\n            nodesB[i]->next = nodesB[i + 1];\n        }\n    }\n    \n    return {nodesA.empty() ? nullptr : nodesA[0], nodesB.empty() ? nullptr : nodesB[0]};\n}\n\n// Free memory allocated for the linked lists with possible intersection\nvoid cleanupIntersectedLists(ListNode* headA, ListNode* headB) {\n    std::unordered_set<ListNode*> visited;\n    \n    // Clean up list A and mark all nodes as visited\n    while (headA) {\n        visited.insert(headA);\n        headA = headA->next;\n    }\n    \n    // Clean up list B, but only delete nodes not already in list A\n    while (headB) {\n        if (visited.find(headB) == visited.end()) {\n            ListNode* temp = headB;\n            headB = headB->next;\n            delete temp;\n        } else {\n            // This node is part of list A, so we don't delete it again\n            break;\n        }\n    }\n    \n    // Now delete all the nodes we collected from list A\n    for (ListNode* node : visited) {\n        delete node;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string lineA, lineB;\n        std::getline(std::cin, lineA);\n        std::getline(std::cin, lineB);\n        \n        int intersectVal, skipA;\n        std::cin >> intersectVal >> skipA;\n        std::cin.ignore(); // Consume newline\n        \n        auto [headA, headB] = createIntersectedLists(lineA, lineB, intersectVal, skipA);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        ListNode* result = sol.getIntersectionNode(headA, headB);\n        /*RUNTIME CALC END*/\n        \n        if (result) {\n            std::cout << result->val;\n        } else {\n            std::cout << \"null\";\n        }\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupIntersectedLists(headA, headB);\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_set>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // Elegant two-pointer approach\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr; // No intersection possible\n        }\n        \n        // Initialize pointers for both lists\n        ListNode* pointerA = headA;\n        ListNode* pointerB = headB;\n        \n        // Loop until pointers meet or both reach the end (nullptr)\n        while (pointerA != pointerB) {\n            // When pointer A reaches end, switch to head of list B\n            // If no intersection, both will eventually become nullptr and exit loop\n            pointerA = (pointerA == nullptr) ? headB : pointerA->next;\n            \n            // When pointer B reaches end, switch to head of list A\n            pointerB = (pointerB == nullptr) ? headA : pointerB->next;\n        }\n        \n        // Either found intersection or both are nullptr (no intersection)\n        return pointerA;\n    }\n};\n\n// Helper functions to create intersected linked lists\nstd::pair<ListNode*, ListNode*> createIntersectedLists(const std::string& lineA, const std::string& lineB, int intersectVal, int skipA) {\n    if (lineA == \"[]\" || lineB == \"[]\") {\n        return {nullptr, nullptr};\n    }\n    \n    // Parse list A\n    std::string contentA = lineA.substr(1, lineA.length() - 2);\n    std::istringstream ssA(contentA);\n    std::string token;\n    \n    std::vector<ListNode*> nodesA;\n    \n    while (std::getline(ssA, token, ',')) {\n        nodesA.push_back(new ListNode(std::stoi(token)));\n    }\n    \n    // Link list A\n    for (size_t i = 0; i < nodesA.size() - 1; i++) {\n        nodesA[i]->next = nodesA[i + 1];\n    }\n    \n    // Parse list B\n    std::string contentB = lineB.substr(1, lineB.length() - 2);\n    std::istringstream ssB(contentB);\n    \n    std::vector<ListNode*> nodesB;\n    \n    while (std::getline(ssB, token, ',')) {\n        nodesB.push_back(new ListNode(std::stoi(token)));\n    }\n    \n    // If intersection exists\n    if (intersectVal != -1 && skipA < static_cast<int>(nodesA.size())) {\n        // Link list B up to intersection point\n        int skipB = nodesB.size() - (nodesA.size() - skipA);\n        \n        for (int i = 0; i < skipB - 1; i++) {\n            nodesB[i]->next = nodesB[i + 1];\n        }\n        \n        // Connect B to the intersection point in A\n        if (skipB > 0) {\n            nodesB[skipB - 1]->next = nodesA[skipA];\n        } else {\n            // B starts at the intersection\n            delete nodesB[0]; // Avoid memory leak\n            nodesB[0] = nodesA[skipA];\n        }\n    } else {\n        // No intersection, just link B normally\n        for (size_t i = 0; i < nodesB.size() - 1; i++) {\n            nodesB[i]->next = nodesB[i + 1];\n        }\n    }\n    \n    return {nodesA.empty() ? nullptr : nodesA[0], nodesB.empty() ? nullptr : nodesB[0]};\n}\n\n// Free memory allocated for the linked lists with possible intersection\nvoid cleanupIntersectedLists(ListNode* headA, ListNode* headB) {\n    std::unordered_set<ListNode*> visited;\n    \n    // Clean up list A and mark all nodes as visited\n    while (headA) {\n        visited.insert(headA);\n        headA = headA->next;\n    }\n    \n    // Clean up list B, but only delete nodes not already in list A\n    while (headB) {\n        if (visited.find(headB) == visited.end()) {\n            ListNode* temp = headB;\n            headB = headB->next;\n            delete temp;\n        } else {\n            // This node is part of list A, so we don't delete it again\n            break;\n        }\n    }\n    \n    // Now delete all the nodes we collected from list A\n    for (ListNode* node : visited) {\n        delete node;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string lineA, lineB;\n        std::getline(std::cin, lineA);\n        std::getline(std::cin, lineB);\n        \n        int intersectVal, skipA;\n        std::cin >> intersectVal >> skipA;\n        std::cin.ignore(); // Consume newline\n        \n        auto [headA, headB] = createIntersectedLists(lineA, lineB, intersectVal, skipA);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        ListNode* result = sol.getIntersectionNode(headA, headB);\n        /*RUNTIME CALC END*/\n        \n        if (result) {\n            std::cout << result->val;\n        } else {\n            std::cout << \"null\";\n        }\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupIntersectedLists(headA, headB);\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional, List, Tuple\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        # Implement your solution here\n        return None # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse lists A and B\n                lineA = input().strip()\n                lineB = input().strip()\n                \n                # Parse intersection indices\n                intersectVal = int(input().strip()) # Value at intersection\n                skipA = int(input().strip()) # Skip A nodes before intersection\n                \n                # Create linked lists with intersection\n                headA, headB = Main.create_intersected_lists(lineA, lineB, intersectVal, skipA)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.getIntersectionNode(headA, headB)\n                # RUNTIME CALC END\n                \n                if result:\n                    results.append(str(result.val))\n                else:\n                    results.append(\"null\")\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_intersected_lists(lineA: str, lineB: str, intersectVal: int, skipA: int) -> Tuple[Optional[ListNode], Optional[ListNode]]:\n        if lineA == \"[]\" or lineB == \"[]\":\n            return None, None\n        \n        # Parse list A\n        valuesA = lineA[1:-1].split(',')\n        nodesA = []\n        \n        for val in valuesA:\n            nodesA.append(ListNode(int(val.strip())))\n        \n        # Link list A\n        for i in range(len(nodesA) - 1):\n            nodesA[i].next = nodesA[i + 1]\n        \n        # Parse list B\n        valuesB = lineB[1:-1].split(',')\n        nodesB = []\n        \n        for val in valuesB:\n            nodesB.append(ListNode(int(val.strip())))\n        \n        # If intersection exists\n        if intersectVal != -1 and skipA < len(nodesA):\n            # Link list B up to intersection point\n            skipB = len(nodesB) - (len(nodesA) - skipA)\n            \n            for i in range(skipB - 1):\n                if i < len(nodesB) - 1:\n                    nodesB[i].next = nodesB[i + 1]\n            \n            # Connect B to the intersection point in A\n            if skipB > 0 and skipB - 1 < len(nodesB):\n                nodesB[skipB - 1].next = nodesA[skipA]\n            else:\n                # B starts at the intersection\n                if len(nodesB) > 0:\n                    nodesB[0] = nodesA[skipA]\n        else:\n            # No intersection, just link B normally\n            for i in range(len(nodesB) - 1):\n                nodesB[i].next = nodesB[i + 1]\n        \n        return nodesA[0] if nodesA else None, nodesB[0] if nodesB else None\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional, List, Tuple\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        # Elegant two-pointer approach\n        if not headA or not headB:\n            return None  # No intersection possible\n        \n        # Initialize pointers for both lists\n        pointerA = headA\n        pointerB = headB\n        \n        # Loop until pointers meet or both reach the end (None)\n        while pointerA != pointerB:\n            # When pointer A reaches end, switch to head of list B\n            # If no intersection, both will eventually become None and exit loop\n            pointerA = headB if pointerA is None else pointerA.next\n            \n            # When pointer B reaches end, switch to head of list A\n            pointerB = headA if pointerB is None else pointerB.next\n        \n        # Either found intersection or both are None (no intersection)\n        return pointerA\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse lists A and B\n                lineA = input().strip()\n                lineB = input().strip()\n                \n                # Parse intersection indices\n                intersectVal = int(input().strip()) # Value at intersection\n                skipA = int(input().strip()) # Skip A nodes before intersection\n                \n                # Create linked lists with intersection\n                headA, headB = Main.create_intersected_lists(lineA, lineB, intersectVal, skipA)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.getIntersectionNode(headA, headB)\n                # RUNTIME CALC END\n                \n                if result:\n                    results.append(str(result.val))\n                else:\n                    results.append(\"null\")\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_intersected_lists(lineA: str, lineB: str, intersectVal: int, skipA: int) -> Tuple[Optional[ListNode], Optional[ListNode]]:\n        if lineA == \"[]\" or lineB == \"[]\":\n            return None, None\n        \n        # Parse list A\n        valuesA = lineA[1:-1].split(',')\n        nodesA = []\n        \n        for val in valuesA:\n            nodesA.append(ListNode(int(val.strip())))\n        \n        # Link list A\n        for i in range(len(nodesA) - 1):\n            nodesA[i].next = nodesA[i + 1]\n        \n        # Parse list B\n        valuesB = lineB[1:-1].split(',')\n        nodesB = []\n        \n        for val in valuesB:\n            nodesB.append(ListNode(int(val.strip())))\n        \n        # If intersection exists\n        if intersectVal != -1 and skipA < len(nodesA):\n            # Link list B up to intersection point\n            skipB = len(nodesB) - (len(nodesA) - skipA)\n            \n            for i in range(skipB - 1):\n                if i < len(nodesB) - 1:\n                    nodesB[i].next = nodesB[i + 1]\n            \n            # Connect B to the intersection point in A\n            if skipB > 0 and skipB - 1 < len(nodesB):\n                nodesB[skipB - 1].next = nodesA[skipA]\n            else:\n                # B starts at the intersection\n                if len(nodesB) > 0:\n                    nodesB[0] = nodesA[skipA]\n        else:\n            # No intersection, just link B normally\n            for i in range(len(nodesB) - 1):\n                nodesB[i].next = nodesB[i + 1]\n        \n        return nodesA[0] if nodesA else None, nodesB[0] if nodesB else None\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "2\n[4,1,8,4,5]\n[5,6,1,8,4,5]\n2\n2\n[1,9,1,2,4]\n[3,2,4]\n3\n3",
      "output": "8\n2",
      "hidden": false,
      "explanation": "Basic test cases with intersections at different positions"
    },
    {
      "input": "3\n[1,2,3,4,5]\n[6,7,8,9,10]\n-1\n0\n[2,6,4]\n[1,5]\n-1\n0\n[1,2,3,4,5]\n[1,2,3,4,5]\n0\n0",
      "output": "null\nnull\n1",
      "hidden": true,
      "explanation": "Edge cases: no intersection, and lists that have the same head node"
    }
  ]
} 