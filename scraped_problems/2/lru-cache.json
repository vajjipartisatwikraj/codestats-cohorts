{
  "title": "LRU Cache",
  "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n- LRUCache(int capacity) Initialize the LRU cache with positive size capacity.\n- int get(int key) Return the value of the key if the key exists, otherwise return -1.\n- void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains two space-separated integers: an operation count n and the cache capacity capacity.\n  - The next n lines each contain an operation in one of these formats:\n    - \"get key\" - Call the get method with the given key\n    - \"put key value\" - Call the put method with the given key and value\n\nOutput Format:\n- For each test case, print the return values of all get operations and null for all put operations, one per line.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= capacity <= 3000",
    "0 <= key <= 10^4",
    "0 <= value <= 10^5",
    "1 <= n <= 10^5"
  ],
  "examples": [
    {
      "input": "1\n8 2\nput 1 1\nput 2 2\nget 1\nput 3 3\nget 2\nput 4 4\nget 1\nget 3",
      "output": "null\nnull\n1\nnull\n-1\nnull\n-1\n3",
      "explanation": "LRUCache lRUCache = new LRUCache(2); // capacity = 2\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3"
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 15,
  "tags": ["Linked List", "Hash Table", "Design", "Doubly Linked List"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg", "Twitter", "Uber", "LinkedIn"],
  "hints": [
    "To achieve O(1) operations, you need a combination of data structures",
    "Consider using a hash map for fast key-value lookup",
    "A doubly linked list can help you keep track of the order of usage",
    "When you access a key, you'll need to move it to the front of the list to mark it as most recently used"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass LRUCache {\n    /**\n     * Initialize the LRU cache with the specified capacity.\n     * @param capacity The capacity of the cache.\n     */\n    public LRUCache(int capacity) {\n        // Implement your solution here\n    }\n    \n    /**\n     * Get the value of the key if it exists in the cache, otherwise return -1.\n     * @param key The key to lookup.\n     * @return The value associated with the key, or -1 if the key is not in the cache.\n     */\n    public int get(int key) {\n        // Implement your solution here\n        return -1;\n    }\n    \n    /**\n     * Update the value of the key if it exists, or add a new key-value pair if it doesn't.\n     * If the number of keys exceeds capacity, evict the least recently used key.\n     * @param key The key to update or add.\n     * @param value The value to associate with the key.\n     */\n    public void put(int key, int value) {\n        // Implement your solution here\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the operation count and capacity\n                String[] params = br.readLine().trim().split(\" \");\n                int n = Integer.parseInt(params[0]);\n                int capacity = Integer.parseInt(params[1]);\n                \n                LRUCache cache = new LRUCache(capacity);\n                \n                for (int j = 0; j < n; j++) {\n                    String[] operation = br.readLine().trim().split(\" \");\n                    String op = operation[0];\n                    int key = Integer.parseInt(operation[1]);\n                    \n                    if (op.equals(\"get\")) {\n                        /*RUNTIME CALC START*/\n                        int result = cache.get(key);\n                        /*RUNTIME CALC END*/\n                        output.append(result);\n                    } else if (op.equals(\"put\")) {\n                        int value = Integer.parseInt(operation[2]);\n                        /*RUNTIME CALC START*/\n                        cache.put(key, value);\n                        /*RUNTIME CALC END*/\n                        output.append(\"null\");\n                    }\n                    \n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.print(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass LRUCache {\n    private int capacity;\n    private Map<Integer, Node> cache;\n    private Node head; // Most recently used\n    private Node tail; // Least recently used\n    \n    // Doubly linked list node\n    private class Node {\n        int key;\n        int value;\n        Node prev;\n        Node next;\n        \n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n    \n    /**\n     * Initialize the LRU cache with the specified capacity.\n     * @param capacity The capacity of the cache.\n     */\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.cache = new HashMap<>();\n        \n        // Initialize dummy head and tail nodes\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        \n        // Connect head and tail\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    /**\n     * Get the value of the key if it exists in the cache, otherwise return -1.\n     * @param key The key to lookup.\n     * @return The value associated with the key, or -1 if the key is not in the cache.\n     */\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1; // Key doesn't exist\n        }\n        \n        // Key exists, get the node and move it to the front (most recently used)\n        Node node = cache.get(key);\n        moveToHead(node); // Update usage\n        \n        return node.value;\n    }\n    \n    /**\n     * Update the value of the key if it exists, or add a new key-value pair if it doesn't.\n     * If the number of keys exceeds capacity, evict the least recently used key.\n     * @param key The key to update or add.\n     * @param value The value to associate with the key.\n     */\n    public void put(int key, int value) {\n        // Check if key already exists\n        if (cache.containsKey(key)) {\n            // Update existing key\n            Node node = cache.get(key);\n            node.value = value;\n            moveToHead(node); // Update usage\n            return;\n        }\n        \n        // Key doesn't exist, create a new node\n        Node newNode = new Node(key, value);\n        cache.put(key, newNode);\n        addToHead(newNode); // Add to front as most recently used\n        \n        // Check if capacity is exceeded\n        if (cache.size() > capacity) {\n            // Remove least recently used node (from tail)\n            Node removed = removeTail();\n            cache.remove(removed.key);\n        }\n    }\n    \n    /**\n     * Move an existing node to the head of the list (mark as most recently used).\n     */\n    private void moveToHead(Node node) {\n        // Remove from current position\n        removeNode(node);\n        // Add to head\n        addToHead(node);\n    }\n    \n    /**\n     * Add a node right after the dummy head.\n     */\n    private void addToHead(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    /**\n     * Remove a node from the doubly linked list.\n     */\n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    \n    /**\n     * Remove and return the node right before the dummy tail (the LRU node).\n     */\n    private Node removeTail() {\n        Node removed = tail.prev;\n        removeNode(removed);\n        return removed;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the operation count and capacity\n                String[] params = br.readLine().trim().split(\" \");\n                int n = Integer.parseInt(params[0]);\n                int capacity = Integer.parseInt(params[1]);\n                \n                LRUCache cache = new LRUCache(capacity);\n                \n                for (int j = 0; j < n; j++) {\n                    String[] operation = br.readLine().trim().split(\" \");\n                    String op = operation[0];\n                    int key = Integer.parseInt(operation[1]);\n                    \n                    if (op.equals(\"get\")) {\n                        /*RUNTIME CALC START*/\n                        int result = cache.get(key);\n                        /*RUNTIME CALC END*/\n                        output.append(result);\n                    } else if (op.equals(\"put\")) {\n                        int value = Integer.parseInt(operation[2]);\n                        /*RUNTIME CALC START*/\n                        cache.put(key, value);\n                        /*RUNTIME CALC END*/\n                        output.append(\"null\");\n                    }\n                    \n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.print(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n\nclass LRUCache {\npublic:\n    /**\n     * Initialize the LRU cache with the specified capacity.\n     * @param capacity The capacity of the cache.\n     */\n    LRUCache(int capacity) {\n        // Implement your solution here\n    }\n    \n    /**\n     * Get the value of the key if it exists in the cache, otherwise return -1.\n     * @param key The key to lookup.\n     * @return The value associated with the key, or -1 if the key is not in the cache.\n     */\n    int get(int key) {\n        // Implement your solution here\n        return -1;\n    }\n    \n    /**\n     * Update the value of the key if it exists, or add a new key-value pair if it doesn't.\n     * If the number of keys exceeds capacity, evict the least recently used key.\n     * @param key The key to update or add.\n     * @param value The value to associate with the key.\n     */\n    void put(int key, int value) {\n        // Implement your solution here\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    for (int i = 0; i < t; i++) {\n        // Parse the operation count and capacity\n        int n, capacity;\n        std::cin >> n >> capacity;\n        \n        LRUCache cache(capacity);\n        \n        for (int j = 0; j < n; j++) {\n            std::string op;\n            std::cin >> op;\n            \n            if (op == \"get\") {\n                int key;\n                std::cin >> key;\n                \n                /*RUNTIME CALC START*/\n                int result = cache.get(key);\n                /*RUNTIME CALC END*/\n                \n                std::cout << result << std::endl;\n            } else if (op == \"put\") {\n                int key, value;\n                std::cin >> key >> value;\n                \n                /*RUNTIME CALC START*/\n                cache.put(key, value);\n                /*RUNTIME CALC END*/\n                \n                std::cout << \"null\" << std::endl;\n            }\n        }\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <list>\n\nclass LRUCache {\nprivate:\n    int capacity;\n    // list to store key-value pairs, used for O(1) insertion and deletion\n    std::list<std::pair<int, int>> cache; // (key, value) pairs\n    // map to store key -> iterator for O(1) lookup\n    std::unordered_map<int, std::list<std::pair<int, int>>::iterator> map;\n    \npublic:\n    /**\n     * Initialize the LRU cache with the specified capacity.\n     * @param capacity The capacity of the cache.\n     */\n    LRUCache(int capacity) : capacity(capacity) {}\n    \n    /**\n     * Get the value of the key if it exists in the cache, otherwise return -1.\n     * @param key The key to lookup.\n     * @return The value associated with the key, or -1 if the key is not in the cache.\n     */\n    int get(int key) {\n        // Check if key exists\n        auto it = map.find(key);\n        if (it == map.end()) {\n            return -1; // Key doesn't exist\n        }\n        \n        // Move the accessed item to the front (mark as most recently used)\n        cache.splice(cache.begin(), cache, it->second);\n        return it->second->second; // Return the value\n    }\n    \n    /**\n     * Update the value of the key if it exists, or add a new key-value pair if it doesn't.\n     * If the number of keys exceeds capacity, evict the least recently used key.\n     * @param key The key to update or add.\n     * @param value The value to associate with the key.\n     */\n    void put(int key, int value) {\n        // Check if key already exists\n        auto it = map.find(key);\n        \n        if (it != map.end()) {\n            // Update existing key\n            it->second->second = value; // Update value\n            // Move to front (mark as most recently used)\n            cache.splice(cache.begin(), cache, it->second);\n            return;\n        }\n        \n        // Key doesn't exist\n        \n        // Check if cache is full\n        if (cache.size() == capacity) {\n            // Remove the least recently used item (at the end of the list)\n            int lruKey = cache.back().first;\n            cache.pop_back(); // Remove from list\n            map.erase(lruKey); // Remove from map\n        }\n        \n        // Add new key-value pair to the front of the list\n        cache.emplace_front(key, value);\n        // Store iterator in map for O(1) lookup\n        map[key] = cache.begin();\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    for (int i = 0; i < t; i++) {\n        // Parse the operation count and capacity\n        int n, capacity;\n        std::cin >> n >> capacity;\n        \n        LRUCache cache(capacity);\n        \n        for (int j = 0; j < n; j++) {\n            std::string op;\n            std::cin >> op;\n            \n            if (op == \"get\") {\n                int key;\n                std::cin >> key;\n                \n                /*RUNTIME CALC START*/\n                int result = cache.get(key);\n                /*RUNTIME CALC END*/\n                \n                std::cout << result << std::endl;\n            } else if (op == \"put\") {\n                int key, value;\n                std::cin >> key >> value;\n                \n                /*RUNTIME CALC START*/\n                cache.put(key, value);\n                /*RUNTIME CALC END*/\n                \n                std::cout << \"null\" << std::endl;\n            }\n        }\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional, List\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        \"\"\"\n        Initialize the LRU cache with the specified capacity.\n        \"\"\"\n        # Implement your solution here\n        pass\n\n    def get(self, key: int) -> int:\n        \"\"\"\n        Get the value of the key if it exists in the cache, otherwise return -1.\n        \"\"\"\n        # Implement your solution here\n        return -1\n        \n    def put(self, key: int, value: int) -> None:\n        \"\"\"\n        Update the value of the key if it exists, or add a new key-value pair if it doesn't.\n        If the number of keys exceeds capacity, evict the least recently used key.\n        \"\"\"\n        # Implement your solution here\n        pass\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            for _ in range(t):\n                # Parse operation count and capacity\n                n, capacity = map(int, input().strip().split())\n                \n                cache = LRUCache(capacity)\n                \n                for _ in range(n):\n                    operation = input().strip().split()\n                    op = operation[0]\n                    key = int(operation[1])\n                    \n                    if op == \"get\":\n                        # RUNTIME CALC START\n                        result = cache.get(key)\n                        # RUNTIME CALC END\n                        print(result)\n                    elif op == \"put\":\n                        value = int(operation[2])\n                        # RUNTIME CALC START\n                        cache.put(key, value)\n                        # RUNTIME CALC END\n                        print(\"null\")\n        \n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional, List\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        \"\"\"\n        Initialize the LRU cache with the specified capacity.\n        \"\"\"\n        self.capacity = capacity\n        # Using OrderedDict which maintains insertion order and provides O(1) operations\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        \"\"\"\n        Get the value of the key if it exists in the cache, otherwise return -1.\n        \"\"\"\n        if key not in self.cache:\n            return -1\n        \n        # Move the accessed item to the end (mark as most recently used)\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n        \n    def put(self, key: int, value: int) -> None:\n        \"\"\"\n        Update the value of the key if it exists, or add a new key-value pair if it doesn't.\n        If the number of keys exceeds capacity, evict the least recently used key.\n        \"\"\"\n        # Remove the key if it exists to update its position\n        if key in self.cache:\n            self.cache.pop(key)\n        # If at capacity, remove the first item (least recently used)\n        elif len(self.cache) >= self.capacity:\n            self.cache.popitem(last=False)  # Remove from the beginning (LRU)\n            \n        # Add new key-value pair (will be at the end as most recently used)\n        self.cache[key] = value\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            for _ in range(t):\n                # Parse operation count and capacity\n                n, capacity = map(int, input().strip().split())\n                \n                cache = LRUCache(capacity)\n                \n                for _ in range(n):\n                    operation = input().strip().split()\n                    op = operation[0]\n                    key = int(operation[1])\n                    \n                    if op == \"get\":\n                        # RUNTIME CALC START\n                        result = cache.get(key)\n                        # RUNTIME CALC END\n                        print(result)\n                    elif op == \"put\":\n                        value = int(operation[2])\n                        # RUNTIME CALC START\n                        cache.put(key, value)\n                        # RUNTIME CALC END\n                        print(\"null\")\n        \n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "1\n8 2\nput 1 1\nput 2 2\nget 1\nput 3 3\nget 2\nput 4 4\nget 1\nget 3",
      "output": "null\nnull\n1\nnull\n-1\nnull\n-1\n3",
      "hidden": false,
      "explanation": "LRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1);\nlRUCache.put(2, 2);\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // evicts key 2\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // evicts key 1\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3"
    },
    {
      "input": "1\n6 1\nput 2 1\nget 2\nput 3 2\nget 2\nget 3\nput 4 3",
      "output": "null\n1\nnull\n-1\n2\nnull",
      "hidden": true,
      "explanation": "LRUCache lRUCache = new LRUCache(1);\nlRUCache.put(2, 1); // cache is {2=1}\nlRUCache.get(2);    // return 1\nlRUCache.put(3, 2); // LRU key was 2, evicts key 2, cache is {3=2}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.get(3);    // return 2\nlRUCache.put(4, 3); // LRU key was 3, evicts key 3, cache is {4=3}"
    }
  ]
} 