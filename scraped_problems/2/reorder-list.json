{
  "title": "Reorder List",
  "description": "You are given the head of a singly linked list. The list can be represented as L0 → L1 → … → Ln-1 → Ln.\n\nReorder the list to be on the following form: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case, one line contains an array of integers representing the linked list nodes in order.\n\nOutput Format:\n- For each test case, print an array of integers representing the reordered linked list.\n\nNote: You may not modify the values in the list's nodes. Only nodes themselves may be changed.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the list is in the range [1, 5 * 10^4]",
    "1 <= Node.val <= 1000"
  ],
  "examples": [
    {
      "input": "2\n[1,2,3,4]\n[1,2,3,4,5]",
      "output": "[1,4,2,3]\n[1,5,2,4,3]",
      "explanation": "Test case 1: The original list is 1->2->3->4, after reordering, it becomes 1->4->2->3.\nTest case 2: The original list is 1->2->3->4->5, after reordering, it becomes 1->5->2->4->3."
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Linked List", "Two Pointers", "Stack", "Recursion"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg"],
  "hints": [
    "The problem can be broken down into three steps",
    "First, find the middle of the linked list",
    "Second, reverse the second half of the linked list",
    "Third, merge the first half and the reversed second half alternately"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Reorder the linked list as specified: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …\n     * @param head The head of the linked list.\n     */\n    public void reorderList(ListNode head) {\n        // Implement your solution here\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                ListNode head = createLinkedList(line);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                sol.reorderList(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(head));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Reorder the linked list as specified: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …\n     * @param head The head of the linked list.\n     */\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null || head.next.next == null) {\n            return; // No need to reorder if list has 0, 1, or 2 nodes\n        }\n        \n        // Step 1: Find the middle of the linked list\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        // Step 2: Reverse the second half of the linked list\n        ListNode secondHalf = reverseList(slow.next);\n        slow.next = null; // Break the list into two halves\n        \n        // Step 3: Merge the first half and the reversed second half alternately\n        ListNode firstHalf = head;\n        \n        while (firstHalf != null && secondHalf != null) {\n            ListNode firstNext = firstHalf.next;\n            ListNode secondNext = secondHalf.next;\n            \n            firstHalf.next = secondHalf;\n            secondHalf.next = firstNext;\n            \n            firstHalf = firstNext;\n            secondHalf = secondNext;\n        }\n    }\n    \n    private ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n        \n        while (current != null) {\n            ListNode next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n        \n        return prev;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                ListNode head = createLinkedList(line);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                sol.reorderList(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(head));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        // Implement your solution here\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\nstd::string linkedListToString(ListNode* head) {\n    std::string result = \"[\";\n    \n    while (head) {\n        result += std::to_string(head->val);\n        if (head->next) {\n            result += \",\";\n        }\n        head = head->next;\n    }\n    \n    result += \"]\";\n    return result;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        ListNode* head = createLinkedList(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        sol.reorderList(head);\n        /*RUNTIME CALC END*/\n        \n        std::cout << linkedListToString(head);\
        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(head);\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr || head->next->next == nullptr) {\n            return; // No need to reorder if list has 0, 1, or 2 nodes\n        }\n        \n        // Step 1: Find the middle of the linked list\n        ListNode* slow = head;\n        ListNode* fast = head;\n        \n        while (fast->next != nullptr && fast->next->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        // Step 2: Reverse the second half of the linked list\n        ListNode* secondHalf = reverseList(slow->next);\n        slow->next = nullptr; // Break the list into two halves\n        \n        // Step 3: Merge the first half and the reversed second half alternately\n        ListNode* firstHalf = head;\n        \n        while (firstHalf != nullptr && secondHalf != nullptr) {\n            ListNode* firstNext = firstHalf->next;\n            ListNode* secondNext = secondHalf->next;\n            \n            firstHalf->next = secondHalf;\n            secondHalf->next = firstNext;\n            \n            firstHalf = firstNext;\n            secondHalf = secondNext;\n        }\n    }\n    \nprivate:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* current = head;\n        \n        while (current != nullptr) {\n            ListNode* next = current->next;\n            current->next = prev;\n            prev = current;\n            current = next;\n        }\n        \n        return prev;\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\nstd::string linkedListToString(ListNode* head) {\n    std::string result = \"[\";\n    \n    while (head) {\n        result += std::to_string(head->val);\n        if (head->next) {\n            result += \",\";\n        }\n        head = head->next;\n    }\n    \n    result += \"]\";\n    return result;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        ListNode* head = createLinkedList(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        sol.reorderList(head);\n        /*RUNTIME CALC END*/\n        \n        std::cout << linkedListToString(head);\
        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(head);\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Reorder the linked list as specified: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        # Implement your solution here\n        pass\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                head = Main.create_linked_list(line)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                sol.reorderList(head)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(head))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Reorder the linked list as specified: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        if not head or not head.next or not head.next.next:\n            return  # No need to reorder if list has 0, 1, or 2 nodes\n        \n        # Step 1: Find the middle of the linked list\n        slow = head\n        fast = head\n        \n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Step 2: Reverse the second half of the linked list\n        second_half = self.reverse_list(slow.next)\n        slow.next = None  # Break the list into two halves\n        \n        # Step 3: Merge the first half and the reversed second half alternately\n        first_half = head\n        \n        while first_half and second_half:\n            first_next = first_half.next\n            second_next = second_half.next\n            \n            first_half.next = second_half\n            second_half.next = first_next\n            \n            first_half = first_next\n            second_half = second_next\n    \n    def reverse_list(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        current = head\n        \n        while current:\n            next_temp = current.next\n            current.next = prev\n            prev = current\n            current = next_temp\n        \n        return prev\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                head = Main.create_linked_list(line)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                sol.reorderList(head)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(head))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "2\n[1,2,3,4]\n[1,2,3,4,5]",
      "output": "[1,4,2,3]\n[1,5,2,4,3]",
      "hidden": false,
      "explanation": "Basic test cases with even and odd length lists"
    },
    {
      "input": "3\n[1]\n[1,2]\n[1,2,3,4,5,6,7,8]",
      "output": "[1]\n[1,2]\n[1,8,2,7,3,6,4,5]",
      "hidden": true,
      "explanation": "Edge cases: single node, two nodes, and a long list"
    }
  ]
} 