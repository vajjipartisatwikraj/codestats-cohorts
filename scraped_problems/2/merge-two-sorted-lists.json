{
  "title": "Merge Two Sorted Lists",
  "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains an array of integers representing the first linked list nodes in order.\n  - The second line contains an array of integers representing the second linked list nodes in order.\n\nOutput Format:\n- For each test case, print an array of integers representing the merged linked list.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in both lists is in the range [0, 50]",
    "-100 <= Node.val <= 100",
    "Both list1 and list2 are sorted in non-decreasing order"
  ],
  "examples": [
    {
      "input": "3\n[1,2,4]\n[1,3,4]\n[]\n[]\n[]\n[0]",
      "output": "[1,1,2,3,4,4]\n[]\n[0]",
      "explanation": "Test case 1: Merging [1,2,4] and [1,3,4] results in [1,1,2,3,4,4].\nTest case 2: Merging two empty lists results in an empty list.\nTest case 3: Merging an empty list and [0] results in [0]."
    }
  ],
  "type": "programming",
  "difficultyLevel": "easy",
  "marks": 5,
  "tags": ["Linked List", "Two Pointers", "Recursion"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg"],
  "hints": [
    "Use a dummy head node to simplify edge cases",
    "Maintain a current pointer to build the result list",
    "Compare values from both lists and always attach the smaller one",
    "Don't forget to attach the remaining nodes when one list is exhausted"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Merges two sorted linked lists.\n     * @param list1 The head of the first linked list.\n     * @param list2 The head of the second linked list.\n     * @return The head of the merged linked list.\n     */\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        // Implement your solution here\n        return null; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the first linked list\n                String line1 = br.readLine().trim();\n                ListNode list1 = createLinkedList(line1);\n                \n                // Parse the second linked list\n                String line2 = br.readLine().trim();\n                ListNode list2 = createLinkedList(line2);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.mergeTwoLists(list1, list2);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Merges two sorted linked lists.\n     * @param list1 The head of the first linked list.\n     * @param list2 The head of the second linked list.\n     * @return The head of the merged linked list.\n     */\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        // Create a dummy head to simplify edge cases\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        // Traverse both lists and compare values\n        while (list1 != null && list2 != null) {\n            if (list1.val <= list2.val) {\n                current.next = list1;\n                list1 = list1.next;\n            } else {\n                current.next = list2;\n                list2 = list2.next;\n            }\n            current = current.next;\n        }\n        \n        // Attach remaining nodes from either list\n        if (list1 != null) {\n            current.next = list1;\n        } else {\n            current.next = list2;\n        }\n        \n        return dummy.next;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the first linked list\n                String line1 = br.readLine().trim();\n                ListNode list1 = createLinkedList(line1);\n                \n                // Parse the second linked list\n                String line2 = br.readLine().trim();\n                ListNode list2 = createLinkedList(line2);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.mergeTwoLists(list1, list2);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        // Implement your solution here\n        return nullptr; // Replace with your implementation\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\nstd::string linkedListToString(ListNode* head) {\n    std::string result = \"[\";\n    \n    while (head) {\n        result += std::to_string(head->val);\n        if (head->next) {\n            result += \",\";\n        }\n        head = head->next;\n    }\n    \n    result += \"]\";\n    return result;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line1, line2;\n        std::getline(std::cin, line1);\n        std::getline(std::cin, line2);\n        \n        ListNode* list1 = createLinkedList(line1);\n        ListNode* list2 = createLinkedList(line2);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        ListNode* result = sol.mergeTwoLists(list1, list2);\n        /*RUNTIME CALC END*/\n        \n        std::cout << linkedListToString(result);\
        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(result);\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        // Create a dummy head to simplify edge cases\n        ListNode dummy(0);\n        ListNode* current = &dummy;\n        \n        // Traverse both lists and compare values\n        while (list1 != nullptr && list2 != nullptr) {\n            if (list1->val <= list2->val) {\n                current->next = list1;\n                list1 = list1->next;\n            } else {\n                current->next = list2;\n                list2 = list2->next;\n            }\n            current = current->next;\n        }\n        \n        // Attach remaining nodes from either list\n        if (list1 != nullptr) {\n            current->next = list1;\n        } else {\n            current->next = list2;\n        }\n        \n        return dummy.next;\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\nstd::string linkedListToString(ListNode* head) {\n    std::string result = \"[\";\n    \n    while (head) {\n        result += std::to_string(head->val);\n        if (head->next) {\n            result += \",\";\n        }\n        head = head->next;\n    }\n    \n    result += \"]\";\n    return result;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line1, line2;\n        std::getline(std::cin, line1);\n        std::getline(std::cin, line2);\n        \n        ListNode* list1 = createLinkedList(line1);\n        ListNode* list2 = createLinkedList(line2);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        ListNode* result = sol.mergeTwoLists(list1, list2);\n        /*RUNTIME CALC END*/\n        \n        std::cout << linkedListToString(result);\
        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(result);\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        # Implement your solution here\n        return None # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the first linked list\n                line1 = input().strip()\n                list1 = Main.create_linked_list(line1)\n                \n                # Parse the second linked list\n                line2 = input().strip()\n                list2 = Main.create_linked_list(line2)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.mergeTwoLists(list1, list2)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        # Create a dummy head to simplify edge cases\n        dummy = ListNode(0)\n        current = dummy\n        \n        # Traverse both lists and compare values\n        while list1 and list2:\n            if list1.val <= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n        \n        # Attach remaining nodes from either list\n        if list1:\n            current.next = list1\n        else:\n            current.next = list2\n        \n        return dummy.next\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the first linked list\n                line1 = input().strip()\n                list1 = Main.create_linked_list(line1)\n                \n                # Parse the second linked list\n                line2 = input().strip()\n                list2 = Main.create_linked_list(line2)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.mergeTwoLists(list1, list2)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "3\n[1,2,4]\n[1,3,4]\n[]\n[]\n[]\n[0]",
      "output": "[1,1,2,3,4,4]\n[]\n[0]",
      "hidden": false,
      "explanation": "Combined test cases with various list combinations including empty lists"
    },
    {
      "input": "2\n[1,3,5,7,9]\n[2,4,6,8,10]\n[-10,-5,0,5,10]\n[-8,-3,2,7,12]",
      "output": "[1,2,3,4,5,6,7,8,9,10]\n[-10,-8,-5,-3,0,2,5,7,10,12]",
      "hidden": true,
      "explanation": "Alternating sorted lists and lists with negative values"
    }
  ]
} 