{
  "title": "Reverse Linked List",
  "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains an array of integers representing the linked list nodes in order.\n\nOutput Format:\n- For each test case, print an array of integers representing the reversed linked list.\n\nNote: In the provided code template, the linked list is implemented for you. You just need to implement the reversal algorithm.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the list is in the range [0, 5000]",
    "-5000 <= Node.val <= 5000"
  ],
  "examples": [
    {
      "input": "3\n[1,2,3,4,5]\n[1,2]\n[]",
      "output": "[5,4,3,2,1]\n[2,1]\n[]",
      "explanation": "Test case 1: Original list: 1->2->3->4->5, Reversed: 5->4->3->2->1.\nTest case 2: Original list: 1->2, Reversed: 2->1.\nTest case 3: Original list: empty, Reversed: empty."
    }
  ],
  "type": "programming",
  "difficultyLevel": "easy",
  "marks": 5,
  "tags": ["Linked List", "Recursion"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg"],
  "hints": [
    "You can solve this iteratively by using three pointers: current, prev, and next",
    "Be careful about handling the pointers properly to avoid losing parts of the list",
    "A recursive approach is also possible, where each call returns the new head of the reversed list"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Reverses a linked list.\n     * @param head The head of the linked list.\n     * @return The head of the reversed linked list.\n     */\n    public ListNode reverseList(ListNode head) {\n        // Implement your solution here\n        return null; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                ListNode head = createLinkedList(line);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.reverseList(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Reverses a linked list.\n     * @param head The head of the linked list.\n     * @return The head of the reversed linked list.\n     */\n    public ListNode reverseList(ListNode head) {\n        // Iterative approach with three pointers\n        ListNode prev = null;\n        ListNode current = head;\n        ListNode next = null;\n        \n        while (current != null) {\n            // Save the next node before we change current.next\n            next = current.next;\n            \n            // Reverse the pointer\n            current.next = prev;\n            \n            // Move pointers forward\n            prev = current;\n            current = next;\n        }\n        \n        // prev will be the new head of the reversed list\n        return prev;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                ListNode head = createLinkedList(line);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.reverseList(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        // Implement your solution here\n        return nullptr; // Replace with your implementation\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\nstd::string linkedListToString(ListNode* head) {\n    std::string result = \"[\";\n    \n    while (head) {\n        result += std::to_string(head->val);\n        if (head->next) {\n            result += \",\";\n        }\n        head = head->next;\n    }\n    \n    result += \"]\";\n    return result;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        ListNode* head = createLinkedList(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        ListNode* result = sol.reverseList(head);\n        /*RUNTIME CALC END*/\n        \n        std::cout << linkedListToString(result);\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(result);\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        // Iterative approach with three pointers\n        ListNode* prev = nullptr;\n        ListNode* current = head;\n        ListNode* next = nullptr;\n        \n        while (current != nullptr) {\n            // Save the next node before we change current->next\n            next = current->next;\n            \n            // Reverse the pointer\n            current->next = prev;\n            \n            // Move pointers forward\n            prev = current;\n            current = next;\n        }\n        \n        // prev will be the new head of the reversed list\n        return prev;\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\nstd::string linkedListToString(ListNode* head) {\n    std::string result = \"[\";\n    \n    while (head) {\n        result += std::to_string(head->val);\n        if (head->next) {\n            result += \",\";\n        }\n        head = head->next;\n    }\n    \n    result += \"]\";\n    return result;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        ListNode* head = createLinkedList(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        ListNode* result = sol.reverseList(head);\n        /*RUNTIME CALC END*/\n        \n        std::cout << linkedListToString(result);\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(result);\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Implement your solution here\n        return None # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                head = Main.create_linked_list(line)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.reverseList(head)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        current = head\n        \n        while current:\n            # Save the next node before we change current.next\n            next_temp = current.next\n            \n            # Reverse the pointer\n            current.next = prev\n            \n            # Move pointers forward\n            prev = current\n            current = next_temp\n        \n        # prev will be the new head of the reversed list\n        return prev\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                head = Main.create_linked_list(line)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.reverseList(head)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "3\n[1,2,3,4,5]\n[1,2]\n[]",
      "output": "[5,4,3,2,1]\n[2,1]\n[]",
      "hidden": false,
      "explanation": "Combined test cases with various list lengths including empty list"
    },
    {
      "input": "2\n[1]\n[-1,-5,0,4,-8]",
      "output": "[1]\n[-8,4,0,-5,-1]",
      "hidden": true,
      "explanation": "Edge cases including a single node list and a list with negative values"
    }
  ]
} 