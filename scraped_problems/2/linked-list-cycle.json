{
  "title": "Linked List Cycle",
  "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. A cycle occurs when a node in the linked list can be reached again by continuously following the next pointer.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains an array of integers representing the linked list nodes in order.\n  - The second line contains a single integer pos, which is the position (0-indexed) in the linked list where the tail connects to form a cycle. If pos is -1, then there is no cycle.\n\nOutput Format:\n- For each test case, print \"true\" if there is a cycle in the linked list, or \"false\" otherwise.\n\nNote: In the provided code template, the linked list is implemented for you, including the cycle creation based on the pos value.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the list is in the range [0, 10^4]",
    "-10^5 <= Node.val <= 10^5",
    "pos is -1 or a valid index in the linked list"
  ],
  "examples": [
    {
      "input": "3\n[3,2,0,-4]\n1\n[1,2]\n0\n[1]\n-1",
      "output": "true\ntrue\nfalse",
      "explanation": "Test case 1: The linked list has a cycle where the tail connects to the second node (0-indexed).\nTest case 2: The linked list has a cycle where the tail connects to the first node (0-indexed).\nTest case 3: The linked list has no cycle."
    }
  ],
  "type": "programming",
  "difficultyLevel": "easy",
  "marks": 5,
  "tags": ["Linked List", "Two Pointers", "Hash Table"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg"],
  "hints": [
    "Consider using two pointers moving at different speeds (e.g., one slow and one fast)",
    "If there is a cycle, the fast pointer will eventually meet the slow pointer",
    "Another approach is to use a hash set/map to track visited nodes"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Determine if the linked list has a cycle.\n     * @param head The head of the linked list.\n     * @return true if there is a cycle, false otherwise.\n     */\n    public boolean hasCycle(ListNode head) {\n        // Implement your solution here\n        return false; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                int pos = Integer.parseInt(br.readLine().trim());\n                \n                // Create the linked list, possibly with a cycle\n                ListNode head = createLinkedList(line, pos);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                boolean result = sol.hasCycle(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(result);\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line, int pos) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode[] nodes = new ListNode[values.length];\n        \n        // Create all nodes\n        for (int i = 0; i < values.length; i++) {\n            nodes[i] = new ListNode(Integer.parseInt(values[i].trim()));\n        }\n        \n        // Connect nodes\n        for (int i = 0; i < values.length - 1; i++) {\n            nodes[i].next = nodes[i + 1];\n        }\n        \n        // Create cycle if pos is valid\n        if (pos >= 0 && pos < values.length) {\n            nodes[values.length - 1].next = nodes[pos];\n        }\n        \n        return nodes[0];\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Determine if the linked list has a cycle.\n     * @param head The head of the linked list.\n     * @return true if there is a cycle, false otherwise.\n     */\n    public boolean hasCycle(ListNode head) {\n        // Floyd's Cycle-Finding Algorithm (Tortoise and Hare)\n        if (head == null || head.next == null) {\n            return false; // Empty list or single node can't have a cycle\n        }\n        \n        ListNode slow = head; // Tortoise - moves one step at a time\n        ListNode fast = head; // Hare - moves two steps at a time\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;          // Move slow pointer one step\n            fast = fast.next.next;      // Move fast pointer two steps\n            \n            if (slow == fast) {\n                return true;  // Cycle detected - pointers meet\n            }\n        }\n        \n        return false;  // Fast pointer reached the end - no cycle\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                int pos = Integer.parseInt(br.readLine().trim());\n                \n                // Create the linked list, possibly with a cycle\n                ListNode head = createLinkedList(line, pos);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                boolean result = sol.hasCycle(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(result);\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line, int pos) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode[] nodes = new ListNode[values.length];\n        \n        // Create all nodes\n        for (int i = 0; i < values.length; i++) {\n            nodes[i] = new ListNode(Integer.parseInt(values[i].trim()));\n        }\n        \n        // Connect nodes\n        for (int i = 0; i < values.length - 1; i++) {\n            nodes[i].next = nodes[i + 1];\n        }\n        \n        // Create cycle if pos is valid\n        if (pos >= 0 && pos < values.length) {\n            nodes[values.length - 1].next = nodes[pos];\n        }\n        \n        return nodes[0];\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        // Implement your solution here\n        return false; // Replace with your implementation\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line, int pos) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    std::vector<ListNode*> nodes;\n    \n    // Create all nodes\n    while (std::getline(ss, token, ',')) {\n        nodes.push_back(new ListNode(std::stoi(token)));\n    }\n    \n    // Connect nodes\n    for (size_t i = 0; i < nodes.size() - 1; i++) {\n        nodes[i]->next = nodes[i + 1];\n    }\n    \n    // Create cycle if pos is valid\n    if (pos >= 0 && pos < static_cast<int>(nodes.size())) {\n        nodes.back()->next = nodes[pos];\n    }\n    \n    return nodes.empty() ? nullptr : nodes[0];\n}\n\n// Free memory allocated for the linked list (with cycle handling)\nvoid cleanupLinkedList(ListNode* head) {\n    std::unordered_set<ListNode*> visited;\n    \n    while (head && visited.find(head) == visited.end()) {\n        visited.insert(head);\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        int pos;\n        std::cin >> pos;\n        std::cin.ignore(); // Consume newline\n        \n        ListNode* head = createLinkedList(line, pos);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        bool result = sol.hasCycle(head);\n        /*RUNTIME CALC END*/\n        \n        std::cout << (result ? \"true\" : \"false\");\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(head);\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_set>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        // Floyd's Cycle-Finding Algorithm (Tortoise and Hare)\n        if (head == nullptr || head->next == nullptr) {\n            return false; // Empty list or single node can't have a cycle\n        }\n        \n        ListNode* slow = head; // Tortoise - moves one step at a time\n        ListNode* fast = head; // Hare - moves two steps at a time\n        \n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;          // Move slow pointer one step\n            fast = fast->next->next;     // Move fast pointer two steps\n            \n            if (slow == fast) {\n                return true;  // Cycle detected - pointers meet\n            }\n        }\n        \n        return false;  // Fast pointer reached the end - no cycle\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line, int pos) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    std::vector<ListNode*> nodes;\n    \n    // Create all nodes\n    while (std::getline(ss, token, ',')) {\n        nodes.push_back(new ListNode(std::stoi(token)));\n    }\n    \n    // Connect nodes\n    for (size_t i = 0; i < nodes.size() - 1; i++) {\n        nodes[i]->next = nodes[i + 1];\n    }\n    \n    // Create cycle if pos is valid\n    if (pos >= 0 && pos < static_cast<int>(nodes.size())) {\n        nodes.back()->next = nodes[pos];\n    }\n    \n    return nodes.empty() ? nullptr : nodes[0];\n}\n\n// Free memory allocated for the linked list (with cycle handling)\nvoid cleanupLinkedList(ListNode* head) {\n    std::unordered_set<ListNode*> visited;\n    \n    while (head && visited.find(head) == visited.end()) {\n        visited.insert(head);\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        int pos;\n        std::cin >> pos;\n        std::cin.ignore(); // Consume newline\n        \n        ListNode* head = createLinkedList(line, pos);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        bool result = sol.hasCycle(head);\n        /*RUNTIME CALC END*/\n        \n        std::cout << (result ? \"true\" : \"false\");\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(head);\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        # Implement your solution here\n        return False # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                pos = int(input().strip())\n                \n                # Create the linked list, possibly with a cycle\n                head = Main.create_linked_list(line, pos)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.hasCycle(head)\n                # RUNTIME CALC END\n                \n                results.append(str(result).lower())\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str, pos: int) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n        \n        values = line[1:-1].split(',')\n        nodes = []\n        \n        # Create all nodes\n        for val in values:\n            nodes.append(ListNode(int(val.strip())))\n        \n        # Connect nodes\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        \n        # Create cycle if pos is valid\n        if pos >= 0 and pos < len(nodes):\n            nodes[-1].next = nodes[pos]\n        \n        return nodes[0] if nodes else None\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        # Floyd's Cycle-Finding Algorithm (Tortoise and Hare)\n        if not head or not head.next:\n            return False  # Empty list or single node can't have a cycle\n        \n        slow = head  # Tortoise - moves one step at a time\n        fast = head  # Hare - moves two steps at a time\n        \n        while fast and fast.next:\n            slow = slow.next       # Move slow pointer one step\n            fast = fast.next.next  # Move fast pointer two steps\n            \n            if slow == fast:\n                return True  # Cycle detected - pointers meet\n        \n        return False  # Fast pointer reached the end - no cycle\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                pos = int(input().strip())\n                \n                # Create the linked list, possibly with a cycle\n                head = Main.create_linked_list(line, pos)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.hasCycle(head)\n                # RUNTIME CALC END\n                \n                results.append(str(result).lower())\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str, pos: int) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n        \n        values = line[1:-1].split(',')\n        nodes = []\n        \n        # Create all nodes\n        for val in values:\n            nodes.append(ListNode(int(val.strip())))\n        \n        # Connect nodes\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        \n        # Create cycle if pos is valid\n        if pos >= 0 and pos < len(nodes):\n            nodes[-1].next = nodes[pos]\n        \n        return nodes[0] if nodes else None\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "3\n[3,2,0,-4]\n1\n[1,2]\n0\n[1]\n-1",
      "output": "true\ntrue\nfalse",
      "hidden": false,
      "explanation": "Basic test cases with different cycle scenarios"
    },
    {
      "input": "3\n[]\n-1\n[1,2,3,4,5]\n-1\n[1,2,3,4,5,6,7,8,9,10]\n4",
      "output": "false\nfalse\ntrue",
      "hidden": true,
      "explanation": "Edge cases: empty list, list with no cycle, and a list with a cycle to the middle"
    }
  ]
} 