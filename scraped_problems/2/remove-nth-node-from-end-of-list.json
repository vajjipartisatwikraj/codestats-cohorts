{
  "title": "Remove Nth Node From End of List",
  "description": "Given the head of a linked list, remove the nth node from the end of the list and return the modified list's head.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains an array of integers representing the linked list nodes in order.\n  - The second line contains a single integer n, the position from the end to remove (1-indexed).\n\nOutput Format:\n- For each test case, print an array of integers representing the modified linked list after removal.\n\nNote: In the provided code template, the linked list is implemented for you. You just need to implement the removal algorithm.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the list is in the range [1, 30]",
    "0 <= Node.val <= 100",
    "1 <= n <= size of the linked list"
  ],
  "examples": [
    {
      "input": "2\n[1,2,3,4,5]\n2\n[1]\n1",
      "output": "[1,2,3,5]\n[]",
      "explanation": "Test case 1: Removing the 2nd node from the end, which is 4, results in [1,2,3,5].\nTest case 2: Removing the 1st node from the end of a list with only one node results in an empty list []."
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Linked List", "Two Pointers"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg"],
  "hints": [
    "Consider using two pointers with one pointer starting n nodes ahead",
    "A dummy head node can help simplify edge cases, especially when removing the first node",
    "Be careful about handling the case where n equals the length of the list"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Remove the nth node from the end of the list.\n     * @param head The head of the linked list.\n     * @param n The position from the end to remove (1-indexed).\n     * @return The head of the modified linked list.\n     */\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // Implement your solution here\n        return null; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                ListNode head = createLinkedList(line);\n                \n                // Parse n\n                int n = Integer.parseInt(br.readLine().trim());\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.removeNthFromEnd(head, n);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Remove the nth node from the end of the list.\n     * @param head The head of the linked list.\n     * @param n The position from the end to remove (1-indexed).\n     * @return The head of the modified linked list.\n     */\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // Create a dummy node to handle edge cases like removing the head\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        \n        // Two pointers approach\n        ListNode first = dummy;\n        ListNode second = dummy;\n        \n        // Move first pointer n+1 steps ahead\n        for (int i = 0; i <= n; i++) {\n            first = first.next;\n        }\n        \n        // Move both pointers until first reaches the end\n        while (first != null) {\n            first = first.next;\n            second = second.next;\n        }\n        \n        // Remove the nth node from the end\n        second.next = second.next.next;\n        \n        return dummy.next;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                ListNode head = createLinkedList(line);\n                \n                // Parse n\n                int n = Integer.parseInt(br.readLine().trim());\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.removeNthFromEnd(head, n);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        // Implement your solution here\n        return nullptr; // Replace with your implementation\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\nstd::string linkedListToString(ListNode* head) {\n    std::string result = \"[\";\n    \n    while (head) {\n        result += std::to_string(head->val);\n        if (head->next) {\n            result += \",\";\n        }\n        head = head->next;\n    }\n    \n    result += \"]\";\n    return result;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        ListNode* head = createLinkedList(line);\n        \n        int n;\n        std::cin >> n;\n        std::cin.ignore(); // Consume newline\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        ListNode* result = sol.removeNthFromEnd(head, n);\n        /*RUNTIME CALC END*/\n        \n        std::cout << linkedListToString(result);\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(result);\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        // Create a dummy node to handle edge cases like removing the head\n        ListNode dummy(0);\n        dummy.next = head;\n        \n        // Two pointers approach\n        ListNode* first = &dummy;\n        ListNode* second = &dummy;\n        \n        // Move first pointer n+1 steps ahead\n        for (int i = 0; i <= n; i++) {\n            first = first->next;\n        }\n        \n        // Move both pointers until first reaches the end\n        while (first != nullptr) {\n            first = first->next;\n            second = second->next;\n        }\n        \n        // Remove the nth node from the end\n        ListNode* temp = second->next;\n        second->next = second->next->next;\n        delete temp; // Free memory of the removed node\n        \n        return dummy.next;\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\nstd::string linkedListToString(ListNode* head) {\n    std::string result = \"[\";\n    \n    while (head) {\n        result += std::to_string(head->val);\n        if (head->next) {\n            result += \",\";\n        }\n        head = head->next;\n    }\n    \n    result += \"]\";\n    return result;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        ListNode* head = createLinkedList(line);\n        \n        int n;\n        std::cin >> n;\n        std::cin.ignore(); // Consume newline\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        ListNode* result = sol.removeNthFromEnd(head, n);\n        /*RUNTIME CALC END*/\n        \n        std::cout << linkedListToString(result);\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(result);\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # Implement your solution here\n        return None # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                head = Main.create_linked_list(line)\n                \n                # Parse n\n                n = int(input().strip())\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.removeNthFromEnd(head, n)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # Create a dummy node to handle edge cases like removing the head\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # Two pointers approach\n        first = dummy\n        second = dummy\n        \n        # Move first pointer n+1 steps ahead\n        for i in range(n + 1):\n            first = first.next\n        \n        # Move both pointers until first reaches the end\n        while first:\n            first = first.next\n            second = second.next\n        \n        # Remove the nth node from the end\n        second.next = second.next.next\n        \n        return dummy.next\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                head = Main.create_linked_list(line)\n                \n                # Parse n\n                n = int(input().strip())\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.removeNthFromEnd(head, n)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "2\n[1,2,3,4,5]\n2\n[1]\n1",
      "output": "[1,2,3,5]\n[]",
      "hidden": false,
      "explanation": "Basic test cases with removing from middle and removing the only node"
    },
    {
      "input": "3\n[1,2]\n1\n[1,2,3,4,5,6,7]\n7\n[5,4,3,2,1]\n3",
      "output": "[1]\n[2,3,4,5,6,7]\n[5,4,1]",
      "hidden": true,
      "explanation": "Edge cases: removing the last node, removing the first node, and removing from the middle of a reverse-ordered list"
    }
  ]
} 