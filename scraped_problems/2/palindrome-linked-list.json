{
  "title": "Palindrome Linked List",
  "description": "Given the head of a singly linked list, determine if the linked list is a palindrome. A palindrome is a sequence that reads the same forward and backward.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case, one line contains an array of integers representing the linked list.\n\nOutput Format:\n- For each test case, print \"true\" if the linked list is a palindrome, or \"false\" otherwise.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the list is in the range [1, 10^5]",
    "0 <= Node.val <= 9"
  ],
  "examples": [
    {
      "input": "3\n[1,2,2,1]\n[1,2]\n[1]",
      "output": "true\nfalse\ntrue",
      "explanation": "Test case 1: [1,2,2,1] reads the same forward and backward, so it's a palindrome.\nTest case 2: [1,2] doesn't read the same backward, so it's not a palindrome.\nTest case 3: A single element [1] is always a palindrome."
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Linked List", "Two Pointers", "Stack", "Recursion"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg"],
  "hints": [
    "Consider converting the linked list to an array, then check if the array is a palindrome",
    "You can use a stack to store the first half of the list, then compare with the second half",
    "A more efficient approach is to find the middle of the list, reverse the second half, and compare with the first half",
    "Be careful about handling odd and even length lists"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Determine if the linked list is a palindrome.\n     * @param head The head of the linked list.\n     * @return true if the linked list is a palindrome, false otherwise.\n     */\n    public boolean isPalindrome(ListNode head) {\n        // Implement your solution here\n        return false; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                ListNode head = createLinkedList(line);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                boolean result = sol.isPalindrome(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(result);\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Determine if the linked list is a palindrome.\n     * @param head The head of the linked list.\n     * @return true if the linked list is a palindrome, false otherwise.\n     */\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) {\n            return true; // Empty list or single node is a palindrome\n        }\n        \n        // Step 1: Find the middle of the linked list\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        // Step 2: Reverse the second half of the linked list\n        ListNode secondHalf = reverseList(slow);\n        ListNode firstHalf = head;\n        \n        // Step 3: Compare the first and second halves\n        while (secondHalf != null) {\n            if (firstHalf.val != secondHalf.val) {\n                return false; // Not a palindrome\n            }\n            firstHalf = firstHalf.next;\n            secondHalf = secondHalf.next;\n        }\n        \n        return true; // Palindrome confirmed\n    }\n    \n    private ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n        \n        while (current != null) {\n            ListNode next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n        \n        return prev;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list\n                String line = br.readLine().trim();\n                ListNode head = createLinkedList(line);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                boolean result = sol.isPalindrome(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(result);\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        // Implement your solution here\n        return false; // Replace with your implementation\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        ListNode* head = createLinkedList(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        bool result = sol.isPalindrome(head);\n        /*RUNTIME CALC END*/\n        \n        std::cout << (result ? \"true\" : \"false\");\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(head);\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// Definition for singly-linked list\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return true; // Empty list or single node is a palindrome\n        }\n        \n        // Step 1: Find the middle of the linked list\n        ListNode* slow = head;\n        ListNode* fast = head;\n        \n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        // Step 2: Reverse the second half of the linked list\n        ListNode* secondHalf = reverseList(slow);\n        ListNode* firstHalf = head;\n        \n        // Step 3: Compare the first and second halves\n        while (secondHalf != nullptr) {\n            if (firstHalf->val != secondHalf->val) {\n                return false; // Not a palindrome\n            }\n            firstHalf = firstHalf->next;\n            secondHalf = secondHalf->next;\n        }\n        \n        return true; // Palindrome confirmed\n    }\n    \nprivate:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* current = head;\n        \n        while (current != nullptr) {\n            ListNode* next = current->next;\n            current->next = prev;\n            prev = current;\n            current = next;\n        }\n        \n        return prev;\n    }\n};\n\n// Helper functions\nListNode* createLinkedList(const std::string& line) {\n    if (line == \"[]\" || line.empty()) {\n        return nullptr;\n    }\n    \n    std::string content = line.substr(1, line.length() - 2);\n    std::istringstream ss(content);\n    std::string token;\n    \n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    \n    while (std::getline(ss, token, ',')) {\n        current->next = new ListNode(std::stoi(token));\n        current = current->next;\n    }\n    \n    ListNode* head = dummy->next;\n    delete dummy;\n    return head;\n}\n\n// Free memory allocated for the linked list\nvoid cleanupLinkedList(ListNode* head) {\n    while (head) {\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        ListNode* head = createLinkedList(line);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        bool result = sol.isPalindrome(head);\n        /*RUNTIME CALC END*/\n        \n        std::cout << (result ? \"true\" : \"false\");\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n        \n        // Cleanup allocated memory\n        cleanupLinkedList(head);\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        # Implement your solution here\n        return False # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                head = Main.create_linked_list(line)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.isPalindrome(head)\n                # RUNTIME CALC END\n                \n                results.append(str(result).lower())\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional, List\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        if not head or not head.next:\n            return True  # Empty list or single node is a palindrome\n        \n        # Step 1: Find the middle of the linked list\n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Step 2: Reverse the second half of the linked list\n        second_half = self.reverse_list(slow)\n        first_half = head\n        \n        # Step 3: Compare the first and second halves\n        while second_half:\n            if first_half.val != second_half.val:\n                return False  # Not a palindrome\n            first_half = first_half.next\n            second_half = second_half.next\n        \n        return True  # Palindrome confirmed\n    \n    def reverse_list(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        current = head\n        \n        while current:\n            next_temp = current.next\n            current.next = prev\n            prev = current\n            current = next_temp\n        \n        return prev\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list\n                line = input().strip()\n                head = Main.create_linked_list(line)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.isPalindrome(head)\n                # RUNTIME CALC END\n                \n                results.append(str(result).lower())\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "3\n[1,2,2,1]\n[1,2]\n[1]",
      "output": "true\nfalse\ntrue",
      "hidden": false,
      "explanation": "Basic test cases with different palindrome scenarios"
    },
    {
      "input": "3\n[1,2,3,2,1]\n[1,0,1,0,1]\n[]",
      "output": "true\ntrue\ntrue",
      "hidden": true,
      "explanation": "Edge cases: odd length palindromes, alternating values, and empty list"
    }
  ]
} 