{
  "title": "Copy List with Random Pointer",
  "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\n\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains an integer n, the length of the linked list.\n  - The second line contains n space-separated integers representing the values of the nodes.\n  - The next n lines each contain an integer index representing where the random pointer of each node points to (0-indexed). A value of -1 indicates that the random pointer points to null.\n\nOutput Format:\n- For each test case, print the values of the nodes in the copied list, separated by spaces.\n- Then print the random pointer indices of each node in the copied list on a new line, separated by spaces.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "0 <= n <= 1000",
    "-10^4 <= Node.val <= 10^4",
    "Node.random is null or is pointing to some node in the linked list"
  ],
  "examples": [
    {
      "input": "2\n5\n7 13 11 10 1\n-1 0 4 2 0\n3\n3 3 3\n-1 -1 -1",
      "output": "7 13 11 10 1\n-1 0 4 2 0\n3 3 3\n-1 -1 -1",
      "explanation": "Test case 1: The original list is 7->13->11->10->1, where:\n- 7's random pointer is null\n- 13's random pointer points to 7\n- 11's random pointer points to 1\n- 10's random pointer points to 11\n- 1's random pointer points to 7\n\nTest case 2: The original list is 3->3->3, where all random pointers are null."
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 15,
  "tags": ["Linked List", "Hash Table", "Recursion"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg"],
  "hints": [
    "Consider using a hash map to map original nodes to their copies",
    "The solution can be approached in two passes: first to create copies of all nodes, then to set the pointers",
    "Alternatively, a three-step approach works: create nodes, map originals to copies, and then connect pointers",
    "Be careful about how the random pointers are handled to ensure deep copying"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n\nclass Solution {\n    /**\n     * Create a deep copy of the linked list with random pointers.\n     * @param head The head of the original linked list.\n     * @return The head of the copied linked list.\n     */\n    public Node copyRandomList(Node head) {\n        // Implement your solution here\n        return null; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list with random pointers\n                int n = Integer.parseInt(br.readLine().trim());\n                \n                if (n == 0) {\n                    output.append(\"\\n\");\n                    continue;\n                }\n                \n                String[] values = br.readLine().trim().split(\" \");\n                String[] randomIndices = new String[n];\n                \n                for (int j = 0; j < n; j++) {\n                    randomIndices[j] = br.readLine().trim();\n                }\n                \n                Node head = createLinkedListWithRandomPointers(values, randomIndices);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                Node copiedHead = sol.copyRandomList(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(copiedHead));\n                output.append(\"\\n\");\n                output.append(randomPointersToString(copiedHead));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static Node createLinkedListWithRandomPointers(String[] values, String[] randomIndices) {\n        if (values.length == 0) {\n            return null;\n        }\n        \n        // Create nodes\n        Node[] nodes = new Node[values.length];\n        for (int i = 0; i < values.length; i++) {\n            nodes[i] = new Node(Integer.parseInt(values[i]));\n        }\n        \n        // Connect next pointers\n        for (int i = 0; i < values.length - 1; i++) {\n            nodes[i].next = nodes[i + 1];\n        }\n        \n        // Connect random pointers\n        for (int i = 0; i < values.length; i++) {\n            int randomIndex = Integer.parseInt(randomIndices[i]);\n            if (randomIndex != -1) {\n                nodes[i].random = nodes[randomIndex];\n            }\n        }\n        \n        return nodes[0];\n    }\n    \n    private static String linkedListToString(Node head) {\n        StringBuilder sb = new StringBuilder();\n        \n        Node current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\" \");\n            }\n            current = current.next;\n        }\n        \n        return sb.toString();\n    }\n    \n    private static String randomPointersToString(Node head) {\n        StringBuilder sb = new StringBuilder();\n        Map<Node, Integer> nodeToIndex = new HashMap<>();\n        \n        // First, map each node to its index\n        Node current = head;\n        int index = 0;\n        while (current != null) {\n            nodeToIndex.put(current, index++);\n            current = current.next;\n        }\n        \n        // Then, get the random pointers' indices\n        current = head;\n        while (current != null) {\n            if (current.random == null) {\n                sb.append(\"-1\");\n            } else {\n                sb.append(nodeToIndex.get(current.random));\n            }\n            \n            if (current.next != null) {\n                sb.append(\" \");\n            }\n            \n            current = current.next;\n        }\n        \n        return sb.toString();\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n\nclass Solution {\n    /**\n     * Create a deep copy of the linked list with random pointers.\n     * @param head The head of the original linked list.\n     * @return The head of the copied linked list.\n     */\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n        \n        // Step 1: Create a map to store the mapping from original nodes to their copies\n        Map<Node, Node> map = new HashMap<>();\n        \n        // Step 2: First pass - Create a copy of each node and store in the map\n        Node current = head;\n        while (current != null) {\n            map.put(current, new Node(current.val));\n            current = current.next;\n        }\n        \n        // Step 3: Second pass - Link next and random pointers of the copied nodes\n        current = head;\n        while (current != null) {\n            // Get the corresponding copy of the current node\n            Node copy = map.get(current);\n            \n            // Set the next pointer of the copy\n            copy.next = map.get(current.next);  // Will be null if current.next is null\n            \n            // Set the random pointer of the copy\n            copy.random = map.get(current.random);  // Will be null if current.random is null\n            \n            // Move to the next node in the original list\n            current = current.next;\n        }\n        \n        // Return the head of the copied list\n        return map.get(head);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the linked list with random pointers\n                int n = Integer.parseInt(br.readLine().trim());\n                \n                if (n == 0) {\n                    output.append(\"\\n\");\n                    continue;\n                }\n                \n                String[] values = br.readLine().trim().split(\" \");\n                String[] randomIndices = new String[n];\n                \n                for (int j = 0; j < n; j++) {\n                    randomIndices[j] = br.readLine().trim();\n                }\n                \n                Node head = createLinkedListWithRandomPointers(values, randomIndices);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                Node copiedHead = sol.copyRandomList(head);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(copiedHead));\n                output.append(\"\\n\");\n                output.append(randomPointersToString(copiedHead));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static Node createLinkedListWithRandomPointers(String[] values, String[] randomIndices) {\n        if (values.length == 0) {\n            return null;\n        }\n        \n        // Create nodes\n        Node[] nodes = new Node[values.length];\n        for (int i = 0; i < values.length; i++) {\n            nodes[i] = new Node(Integer.parseInt(values[i]));\n        }\n        \n        // Connect next pointers\n        for (int i = 0; i < values.length - 1; i++) {\n            nodes[i].next = nodes[i + 1];\n        }\n        \n        // Connect random pointers\n        for (int i = 0; i < values.length; i++) {\n            int randomIndex = Integer.parseInt(randomIndices[i]);\n            if (randomIndex != -1) {\n                nodes[i].random = nodes[randomIndex];\n            }\n        }\n        \n        return nodes[0];\n    }\n    \n    private static String linkedListToString(Node head) {\n        StringBuilder sb = new StringBuilder();\n        \n        Node current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\" \");\n            }\n            current = current.next;\n        }\n        \n        return sb.toString();\n    }\n    \n    private static String randomPointersToString(Node head) {\n        StringBuilder sb = new StringBuilder();\n        Map<Node, Integer> nodeToIndex = new HashMap<>();\n        \n        // First, map each node to its index\n        Node current = head;\n        int index = 0;\n        while (current != null) {\n            nodeToIndex.put(current, index++);\n            current = current.next;\n        }\n        \n        // Then, get the random pointers' indices\n        current = head;\n        while (current != null) {\n            if (current.random == null) {\n                sb.append(\"-1\");\n            } else {\n                sb.append(nodeToIndex.get(current.random));\n            }\n            \n            if (current.next != null) {\n                sb.append(\" \");\n            }\n            \n            current = current.next;\n        }\n        \n        return sb.toString();\n    }\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional, Dict, List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.next = None\n        self.random = None\n        \nclass Solution:\n    def copyRandomList(self, head: Optional[Node]) -> Optional[Node]:\n        # Implement your solution here\n        return None # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list with random pointers\n                n = int(input().strip())\n                \n                if n == 0:\n                    results.append(\"\\n\")\n                    continue\n                \n                values = list(map(int, input().strip().split()))\n                random_indices = []\n                \n                for _ in range(n):\n                    random_indices.append(int(input().strip()))\n                \n                head = Main.create_linked_list_with_random_pointers(values, random_indices)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                copied_head = sol.copyRandomList(head)\n                # RUNTIME CALC END\n                \n                values_str = Main.linked_list_to_string(copied_head)\n                random_str = Main.random_pointers_to_string(copied_head)\n                \n                results.append(values_str + \"\\n\" + random_str)\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list_with_random_pointers(values: List[int], random_indices: List[int]) -> Optional[Node]:\n        if not values:\n            return None\n        \n        # Create nodes\n        nodes = [Node(val) for val in values]\n        \n        # Connect next pointers\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        \n        # Connect random pointers\n        for i in range(len(nodes)):\n            if random_indices[i] != -1:\n                nodes[i].random = nodes[random_indices[i]]\n        \n        return nodes[0]\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[Node]) -> str:\n        if not head:\n            return \"\"\n            \n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \" \".join(result)\n    \n    @staticmethod\n    def random_pointers_to_string(head: Optional[Node]) -> str:\n        if not head:\n            return \"\"\n            \n        # First, map each node to its index\n        node_to_index = {}\n        current = head\n        index = 0\n        \n        while current:\n            node_to_index[current] = index\n            index += 1\n            current = current.next\n        \n        # Then, get the random pointers' indices\n        result = []\n        current = head\n        \n        while current:\n            if current.random is None:\n                result.append(\"-1\")\n            else:\n                result.append(str(node_to_index[current.random]))\n            current = current.next\n        \n        return \" \".join(result)\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional, Dict, List\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.next = None\n        self.random = None\n        \nclass Solution:\n    def copyRandomList(self, head: Optional[Node]) -> Optional[Node]:\n        if not head:\n            return None\n        \n        # Step 1: Create a map to store the mapping from original nodes to their copies\n        node_map = {}\n        \n        # Step 2: First pass - Create a copy of each node and store in the map\n        current = head\n        while current:\n            node_map[current] = Node(current.val)\n            current = current.next\n        \n        # Step 3: Second pass - Link next and random pointers of the copied nodes\n        current = head\n        while current:\n            # Get the corresponding copy of the current node\n            copy = node_map[current]\n            \n            # Set the next pointer of the copy\n            copy.next = node_map.get(current.next)  # Will be None if current.next is None\n            \n            # Set the random pointer of the copy\n            copy.random = node_map.get(current.random)  # Will be None if current.random is None\n            \n            # Move to the next node in the original list\n            current = current.next\n        \n        # Return the head of the copied list\n        return node_map[head]\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the linked list with random pointers\n                n = int(input().strip())\n                \n                if n == 0:\n                    results.append(\"\\n\")\n                    continue\n                \n                values = list(map(int, input().strip().split()))\n                random_indices = []\n                \n                for _ in range(n):\n                    random_indices.append(int(input().strip()))\n                \n                head = Main.create_linked_list_with_random_pointers(values, random_indices)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                copied_head = sol.copyRandomList(head)\n                # RUNTIME CALC END\n                \n                values_str = Main.linked_list_to_string(copied_head)\n                random_str = Main.random_pointers_to_string(copied_head)\n                \n                results.append(values_str + \"\\n\" + random_str)\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list_with_random_pointers(values: List[int], random_indices: List[int]) -> Optional[Node]:\n        if not values:\n            return None\n        \n        # Create nodes\n        nodes = [Node(val) for val in values]\n        \n        # Connect next pointers\n        for i in range(len(nodes) - 1):\n            nodes[i].next = nodes[i + 1]\n        \n        # Connect random pointers\n        for i in range(len(nodes)):\n            if random_indices[i] != -1:\n                nodes[i].random = nodes[random_indices[i]]\n        \n        return nodes[0]\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[Node]) -> str:\n        if not head:\n            return \"\"\n            \n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \" \".join(result)\n    \n    @staticmethod\n    def random_pointers_to_string(head: Optional[Node]) -> str:\n        if not head:\n            return \"\"\n            \n        # First, map each node to its index\n        node_to_index = {}\n        current = head\n        index = 0\n        \n        while current:\n            node_to_index[current] = index\n            index += 1\n            current = current.next\n        \n        # Then, get the random pointers' indices\n        result = []\n        current = head\n        \n        while current:\n            if current.random is None:\n                result.append(\"-1\")\n            else:\n                result.append(str(node_to_index[current.random]))\n            current = current.next\n        \n        return \" \".join(result)\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "2\n5\n7 13 11 10 1\n-1\n0\n4\n2\n0\n3\n3 3 3\n-1\n-1\n-1",
      "output": "7 13 11 10 1\n-1 0 4 2 0\n3 3 3\n-1 -1 -1",
      "hidden": false,
      "explanation": "Test case 1: The original list is 7->13->11->10->1 with random pointers as described.\nTest case 2: The original list is 3->3->3 with all random pointers pointing to null."
    },
    {
      "input": "1\n0\n",
      "output": "\n",
      "hidden": true,
      "explanation": "An empty linked list is correctly copied as an empty linked list."
    }
  ]
} 