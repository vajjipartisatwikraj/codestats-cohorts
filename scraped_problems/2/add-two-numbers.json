{
  "title": "Add Two Numbers",
  "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains an array representing the first linked list.\n  - The second line contains an array representing the second linked list.\n\nOutput Format:\n- For each test case, print an array representing the result linked list.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in each linked list is in the range [1, 100]",
    "0 <= Node.val <= 9",
    "It is guaranteed that the list represents a number that does not have leading zeros"
  ],
  "examples": [
    {
      "input": "2\n[2,4,3]\n[5,6,4]\n[0]\n[0]",
      "output": "[7,0,8]\n[0]",
      "explanation": "Test case 1: 342 + 465 = 807, which is represented as [7,0,8] in reverse order.\nTest case 2: 0 + 0 = 0, which is represented as [0]."
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Linked List", "Math", "Recursion"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Adobe", "Bloomberg"],
  "hints": [
    "Traverse both linked lists simultaneously",
    "Keep track of a carry-over value when adding digits",
    "Handle cases where one list is longer than the other",
    "Don't forget to add the final carry-over as a new digit if it's non-zero"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Add two numbers represented by linked lists.\n     * @param l1 The head of the first linked list.\n     * @param l2 The head of the second linked list.\n     * @return The head of the sum linked list.\n     */\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        // Implement your solution here\n        return null; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the two linked lists\n                String line1 = br.readLine().trim();\n                String line2 = br.readLine().trim();\n                \n                ListNode l1 = createLinkedList(line1);\n                ListNode l2 = createLinkedList(line2);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.addTwoNumbers(l1, l2);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    /**\n     * Add two numbers represented by linked lists.\n     * @param l1 The head of the first linked list.\n     * @param l2 The head of the second linked list.\n     * @return The head of the sum linked list.\n     */\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyHead = new ListNode(0); // Dummy head to simplify code\n        ListNode current = dummyHead;\n        int carry = 0;\n        \n        // Traverse both lists while either has nodes\n        while (l1 != null || l2 != null) {\n            // Get values from each list (0 if list has ended)\n            int x = (l1 != null) ? l1.val : 0;\n            int y = (l2 != null) ? l2.val : 0;\n            \n            // Calculate sum with carry from previous position\n            int sum = x + y + carry;\n            carry = sum / 10; // Calculate new carry\n            \n            // Create a new node with the digit value (sum % 10)\n            current.next = new ListNode(sum % 10);\n            current = current.next;\n            \n            // Move to next nodes in both lists if available\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n        \n        // If there's a final carry, add it as a new node\n        if (carry > 0) {\n            current.next = new ListNode(carry);\n        }\n        \n        return dummyHead.next; // Skip the dummy head\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                // Parse the two linked lists\n                String line1 = br.readLine().trim();\n                String line2 = br.readLine().trim();\n                \n                ListNode l1 = createLinkedList(line1);\n                ListNode l2 = createLinkedList(line2);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                ListNode result = sol.addTwoNumbers(l1, l2);\n                /*RUNTIME CALC END*/\n                \n                // Print the result\n                output.append(linkedListToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static ListNode createLinkedList(String line) {\n        if (line.equals(\"[]\")) {\n            return null;\n        }\n        \n        String[] values = line.substring(1, line.length() - 1).split(\",\");\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        for (String val : values) {\n            current.next = new ListNode(Integer.parseInt(val.trim()));\n            current = current.next;\n        }\n        \n        return dummy.next;\n    }\n    \n    private static String linkedListToString(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        ListNode current = head;\n        while (current != null) {\n            sb.append(current.val);\n            if (current.next != null) {\n                sb.append(\",\");\n            }\n            current = current.next;\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import Optional\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        # Implement your solution here\n        return None # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the two linked lists\n                line1 = input().strip()\n                line2 = input().strip()\n                \n                l1 = Main.create_linked_list(line1)\n                l2 = Main.create_linked_list(line2)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.addTwoNumbers(l1, l2)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\nfrom typing import Optional\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy_head = ListNode(0)  # Dummy head to simplify code\n        current = dummy_head\n        carry = 0\n        \n        # Traverse both lists while either has nodes\n        while l1 or l2:\n            # Get values from each list (0 if list has ended)\n            x = l1.val if l1 else 0\n            y = l2.val if l2 else 0\n            \n            # Calculate sum with carry from previous position\n            total = x + y + carry\n            carry = total // 10  # Calculate new carry\n            \n            # Create a new node with the digit value (total % 10)\n            current.next = ListNode(total % 10)\n            current = current.next\n            \n            # Move to next nodes in both lists if available\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        # If there's a final carry, add it as a new node\n        if carry > 0:\n            current.next = ListNode(carry)\n        \n        return dummy_head.next  # Skip the dummy head\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                # Parse the two linked lists\n                line1 = input().strip()\n                line2 = input().strip()\n                \n                l1 = Main.create_linked_list(line1)\n                l2 = Main.create_linked_list(line2)\n                \n                # RUNTIME CALC START\n                sol = Solution()\n                result = sol.addTwoNumbers(l1, l2)\n                # RUNTIME CALC END\n                \n                results.append(Main.linked_list_to_string(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n    \n    @staticmethod\n    def create_linked_list(line: str) -> Optional[ListNode]:\n        if line == \"[]\":\n            return None\n            \n        values = line[1:-1].split(',')\n        dummy = ListNode(0)\n        current = dummy\n        \n        for val in values:\n            current.next = ListNode(int(val.strip()))\n            current = current.next\n        \n        return dummy.next\n    \n    @staticmethod\n    def linked_list_to_string(head: Optional[ListNode]) -> str:\n        result = []\n        current = head\n        \n        while current:\n            result.append(str(current.val))\n            current = current.next\n        \n        return \"[\" + \",\".join(result) + \"]\"\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "2\n[2,4,3]\n[5,6,4]\n[0]\n[0]",
      "output": "[7,0,8]\n[0]",
      "hidden": false,
      "explanation": "Test case 1: 342 + 465 = 807, which is represented as [7,0,8] in reverse order.\nTest case 2: 0 + 0 = 0, which is represented as [0]."
    },
    {
      "input": "3\n[9,9,9,9,9,9,9]\n[9,9,9,9]\n[1]\n[9,9]\n[0]\n[7,3]",
      "output": "[8,9,9,9,0,0,0,1]\n[0,0,1]\n[7,3]",
      "hidden": true,
      "explanation": "Test case 1: 9999999 + 9999 = 10009998, which is 8->9->9->9->0->0->0->1 in reverse order.\nTest case 2: 1 + 99 = 100, which is 0->0->1 in reverse order.\nTest case 3: 0 + 37 = 37, which is 7->3 in reverse order."
    }
  ]
} 