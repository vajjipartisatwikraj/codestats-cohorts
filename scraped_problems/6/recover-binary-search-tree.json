{
  "id": "recover-binary-search-tree",
  "title": "Recover Binary Search Tree",
  "description": "You are given the root of a binary search tree (BST), where exactly two nodes were swapped by mistake. Recover the tree without changing its structure.\n\nFollow up: Can you devise a constant space solution?",
  "difficulty": "Medium",
  "constraints": [
    "The number of nodes in the tree is in the range [2, 1000]",
    "-2^31 <= Node.val <= 2^31 - 1"
  ],
  "examples": [
    {
      "input": "root = [1,3,null,null,2]",
      "output": "[3,1,null,null,2]",
      "explanation": "The binary tree is:\n  1\n /\n3\n \\\n  2\nAfter swapping nodes 1 and 3, the tree becomes:\n  3\n /\n1\n \\\n  2"
    },
    {
      "input": "root = [3,1,4,null,null,2]",
      "output": "[2,1,4,null,null,3]",
      "explanation": "The binary tree is:\n  3\n / \\\n1   4\n   /\n  2\nAfter swapping nodes 2 and 3, the tree becomes:\n  2\n / \\\n1   4\n   /\n  3"
    }
  ],
  "approach": "In a correctly formed BST, an inorder traversal yields values in ascending order. When two nodes are swapped, this property is violated. During an inorder traversal, we can identify the two swapped nodes by finding pairs where the current node's value is less than the previous node's value. The first such violation marks the first swapped node, and the last violation marks the second swapped node. After identifying these nodes, we swap their values to recover the BST. For the follow-up, to achieve constant space complexity, we can use Morris Traversal instead of the standard recursive or stack-based inorder traversal.",
  "boilerplateCode": {
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void recoverTree(TreeNode root) {\n        // Your code here\n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        # Your code here\n        pass",
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void recoverTree(TreeNode* root) {\n        // Your code here\n    }\n};"
  },
  "solutionCode": {
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    // Using inorder traversal with recursion\n    private TreeNode firstMisplaced;\n    private TreeNode secondMisplaced;\n    private TreeNode prev;\n    \n    public void recoverTree(TreeNode root) {\n        firstMisplaced = null;\n        secondMisplaced = null;\n        prev = null;\n        \n        // Identify the misplaced nodes\n        inorder(root);\n        \n        // Swap the values of the misplaced nodes\n        int temp = firstMisplaced.val;\n        firstMisplaced.val = secondMisplaced.val;\n        secondMisplaced.val = temp;\n    }\n    \n    private void inorder(TreeNode root) {\n        if (root == null) return;\n        \n        // Visit left subtree\n        inorder(root.left);\n        \n        // Visit current node\n        if (prev != null && root.val < prev.val) {\n            // Found a violation in the BST property\n            if (firstMisplaced == null) {\n                // This is the first violation, mark both nodes\n                firstMisplaced = prev;\n                secondMisplaced = root;\n            } else {\n                // This is the second violation, update second node only\n                secondMisplaced = root;\n            }\n        }\n        \n        prev = root;\n        \n        // Visit right subtree\n        inorder(root.right);\n    }\n    \n    // Using Morris Traversal for O(1) space complexity\n    public void recoverTreeMorris(TreeNode root) {\n        TreeNode firstMisplaced = null;\n        TreeNode secondMisplaced = null;\n        TreeNode prev = null;\n        TreeNode curr = root;\n        TreeNode predecessor = null;\n        \n        while (curr != null) {\n            if (curr.left == null) {\n                // Process current node\n                if (prev != null && curr.val < prev.val) {\n                    if (firstMisplaced == null) {\n                        firstMisplaced = prev;\n                        secondMisplaced = curr;\n                    } else {\n                        secondMisplaced = curr;\n                    }\n                }\n                prev = curr;\n                curr = curr.right;\n            } else {\n                // Find the inorder predecessor of current\n                predecessor = curr.left;\n                while (predecessor.right != null && predecessor.right != curr) {\n                    predecessor = predecessor.right;\n                }\n                \n                if (predecessor.right == null) {\n                    // Make current as right child of its inorder predecessor\n                    predecessor.right = curr;\n                    curr = curr.left;\n                } else {\n                    // Revert the changes made and visit current node\n                    predecessor.right = null;\n                    \n                    // Process current node\n                    if (prev != null && curr.val < prev.val) {\n                        if (firstMisplaced == null) {\n                            firstMisplaced = prev;\n                            secondMisplaced = curr;\n                        } else {\n                            secondMisplaced = curr;\n                        }\n                    }\n                    prev = curr;\n                    curr = curr.right;\n                }\n            }\n        }\n        \n        // Swap the values of the misplaced nodes\n        int temp = firstMisplaced.val;\n        firstMisplaced.val = secondMisplaced.val;\n        secondMisplaced.val = temp;\n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # Using inorder traversal with recursion\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        self.first_misplaced = None\n        self.second_misplaced = None\n        self.prev = None\n        \n        # Identify the misplaced nodes\n        self.inorder(root)\n        \n        # Swap the values of the misplaced nodes\n        self.first_misplaced.val, self.second_misplaced.val = self.second_misplaced.val, self.first_misplaced.val\n    \n    def inorder(self, root):\n        if not root:\n            return\n        \n        # Visit left subtree\n        self.inorder(root.left)\n        \n        # Visit current node\n        if self.prev and root.val < self.prev.val:\n            # Found a violation in the BST property\n            if not self.first_misplaced:\n                # This is the first violation, mark both nodes\n                self.first_misplaced = self.prev\n                self.second_misplaced = root\n            else:\n                # This is the second violation, update second node only\n                self.second_misplaced = root\n        \n        self.prev = root\n        \n        # Visit right subtree\n        self.inorder(root.right)\n    \n    # Using Morris Traversal for O(1) space complexity\n    def recoverTreeMorris(self, root: Optional[TreeNode]) -> None:\n        first_misplaced = None\n        second_misplaced = None\n        prev = None\n        curr = root\n        \n        while curr:\n            if not curr.left:\n                # Process current node\n                if prev and curr.val < prev.val:\n                    if not first_misplaced:\n                        first_misplaced = prev\n                        second_misplaced = curr\n                    else:\n                        second_misplaced = curr\n                prev = curr\n                curr = curr.right\n            else:\n                # Find the inorder predecessor of current\n                predecessor = curr.left\n                while predecessor.right and predecessor.right != curr:\n                    predecessor = predecessor.right\n                \n                if not predecessor.right:\n                    # Make current as right child of its inorder predecessor\n                    predecessor.right = curr\n                    curr = curr.left\n                else:\n                    # Revert the changes made and visit current node\n                    predecessor.right = None\n                    \n                    # Process current node\n                    if prev and curr.val < prev.val:\n                        if not first_misplaced:\n                            first_misplaced = prev\n                            second_misplaced = curr\n                        else:\n                            second_misplaced = curr\n                    prev = curr\n                    curr = curr.right\n        \n        # Swap the values of the misplaced nodes\n        first_misplaced.val, second_misplaced.val = second_misplaced.val, first_misplaced.val",
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    TreeNode* firstMisplaced;\n    TreeNode* secondMisplaced;\n    TreeNode* prev;\n    \n    void inorder(TreeNode* root) {\n        if (root == nullptr) return;\n        \n        // Visit left subtree\n        inorder(root->left);\n        \n        // Visit current node\n        if (prev != nullptr && root->val < prev->val) {\n            // Found a violation in the BST property\n            if (firstMisplaced == nullptr) {\n                // This is the first violation, mark both nodes\n                firstMisplaced = prev;\n                secondMisplaced = root;\n            } else {\n                // This is the second violation, update second node only\n                secondMisplaced = root;\n            }\n        }\n        \n        prev = root;\n        \n        // Visit right subtree\n        inorder(root->right);\n    }\n    \npublic:\n    // Using inorder traversal with recursion\n    void recoverTree(TreeNode* root) {\n        firstMisplaced = nullptr;\n        secondMisplaced = nullptr;\n        prev = nullptr;\n        \n        // Identify the misplaced nodes\n        inorder(root);\n        \n        // Swap the values of the misplaced nodes\n        int temp = firstMisplaced->val;\n        firstMisplaced->val = secondMisplaced->val;\n        secondMisplaced->val = temp;\n    }\n    \n    // Using Morris Traversal for O(1) space complexity\n    void recoverTreeMorris(TreeNode* root) {\n        TreeNode* firstMisplaced = nullptr;\n        TreeNode* secondMisplaced = nullptr;\n        TreeNode* prev = nullptr;\n        TreeNode* curr = root;\n        TreeNode* predecessor = nullptr;\n        \n        while (curr != nullptr) {\n            if (curr->left == nullptr) {\n                // Process current node\n                if (prev != nullptr && curr->val < prev->val) {\n                    if (firstMisplaced == nullptr) {\n                        firstMisplaced = prev;\n                        secondMisplaced = curr;\n                    } else {\n                        secondMisplaced = curr;\n                    }\n                }\n                prev = curr;\n                curr = curr->right;\n            } else {\n                // Find the inorder predecessor of current\n                predecessor = curr->left;\n                while (predecessor->right != nullptr && predecessor->right != curr) {\n                    predecessor = predecessor->right;\n                }\n                \n                if (predecessor->right == nullptr) {\n                    // Make current as right child of its inorder predecessor\n                    predecessor->right = curr;\n                    curr = curr->left;\n                } else {\n                    // Revert the changes made and visit current node\n                    predecessor->right = nullptr;\n                    \n                    // Process current node\n                    if (prev != nullptr && curr->val < prev->val) {\n                        if (firstMisplaced == nullptr) {\n                            firstMisplaced = prev;\n                            secondMisplaced = curr;\n                        } else {\n                            secondMisplaced = curr;\n                        }\n                    }\n                    prev = curr;\n                    curr = curr->right;\n                }\n            }\n        }\n        \n        // Swap the values of the misplaced nodes\n        int temp = firstMisplaced->val;\n        firstMisplaced->val = secondMisplaced->val;\n        secondMisplaced->val = temp;\n    }\n};"
  },
  "testCases": {
    "visible": [
      {
        "input": {"root": [1,3,null,null,2]},
        "output": [3,1,null,null,2]
      },
      {
        "input": {"root": [3,1,4,null,null,2]},
        "output": [2,1,4,null,null,3]
      }
    ],
    "hidden": [
      {
        "input": {"root": [2,3,1]},
        "output": [2,1,3]
      },
      {
        "input": {"root": [5,3,9,1,4,8,10]},
        "output": [5,3,9,1,4,8,10]
      },
      {
        "input": {"root": [1,2,3]},
        "output": [2,1,3]
      }
    ]
  },
  "hints": [
    "In a valid BST, an inorder traversal yields values in ascending order",
    "When two nodes are swapped, the inorder traversal will have one or two positions where a value is smaller than the previous value",
    "If the swapped nodes are adjacent in the inorder traversal, there will be one position where the order is violated",
    "If the swapped nodes are not adjacent, there will be two positions where the order is violated",
    "To achieve O(1) space complexity, consider using Morris Traversal instead of the standard recursive inorder traversal"
  ],
  "companies": ["Facebook", "Amazon", "Microsoft", "Google", "Bloomberg", "Apple"],
  "tags": ["Binary Search Tree", "Tree", "Depth-First Search", "Binary Tree"],
  "timeComplexity": "O(n) - We need to traverse all nodes in the tree once, where n is the number of nodes.",
  "spaceComplexity": "O(h) for the recursive solution, where h is the height of the tree. For the Morris Traversal approach, the space complexity is O(1) since it doesn't use recursion or a stack."
} 