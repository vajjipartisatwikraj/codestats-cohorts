{
  "title": "Min Stack",
  "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the MinStack class:\n- MinStack() initializes the stack object.\n- void push(int val) pushes the element val onto the stack.\n- void pop() removes the element on the top of the stack.\n- int top() gets the top element of the stack.\n- int getMin() retrieves the minimum element in the stack.\n\nInput Format:\n- The first line contains a single integer n, the number of operations to perform.\n- Each of the next n lines contains an operation in one of the following formats:\n  - \"push x\" - Push integer x onto the stack.\n  - \"pop\" - Remove the top element from the stack.\n  - \"top\" - Get the top element of the stack.\n  - \"getMin\" - Retrieve the minimum element in the stack.\n\nOutput Format:\n- For each \"top\" operation, print the top element of the stack.\n- For each \"getMin\" operation, print the minimum element in the stack.\n- For \"push\" and \"pop\" operations, do not print anything.\n\nAll operations are guaranteed to be valid.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= n <= 3 * 10^4",
    "-2^31 <= val <= 2^31 - 1",
    "Methods pop, top and getMin operations will always be called on non-empty stacks"
  ],
  "examples": [
    {
      "input": "7\npush -2\npush 0\npush -3\ngetMin\npop\ntop\ngetMin",
      "output": "-3\n0\n-2",
      "explanation": "MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2"
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Stack", "Design"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "Apple", "Uber", "Bloomberg"],
  "hints": [
    "Consider using two stacks: one for the actual values and another to track minimums",
    "For getMin() to work in O(1) time, you need to keep track of the minimum at each step",
    "When you push a value, check if it's the new minimum and update accordingly",
    "When you pop a value, consider how to update the minimum if the popped value was the minimum"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass MinStack {\n    /**\n     * Initialize your data structure here.\n     */\n    public MinStack() {\n        // Implement initialization\n    }\n    \n    /**\n     * Push element val onto stack.\n     */\n    public void push(int val) {\n        // Implement push operation\n    }\n    \n    /**\n     * Removes the element on top of the stack.\n     */\n    public void pop() {\n        // Implement pop operation\n    }\n    \n    /**\n     * Get the top element of stack.\n     */\n    public int top() {\n        // Implement top operation\n        return 0; // Replace with actual implementation\n    }\n    \n    /**\n     * Retrieve the minimum element in the stack.\n     */\n    public int getMin() {\n        // Implement getMin operation\n        return 0; // Replace with actual implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            MinStack minStack = new MinStack();\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                String operation = command[0];\n                \n                switch (operation) {\n                    case \"push\":\n                        int val = Integer.parseInt(command[1]);\n                        minStack.push(val);\n                        break;\n                    case \"pop\":\n                        minStack.pop();\n                        break;\n                    case \"top\":\n                        output.append(minStack.top());\n                        output.append(\"\\n\");\n                        break;\n                    case \"getMin\":\n                        output.append(minStack.getMin());\n                        output.append(\"\\n\");\n                        break;\n                }\n            }\n            \n            // Remove trailing newline if any\n            if (output.length() > 0 && output.charAt(output.length() - 1) == '\\n') {\n                output.setLength(output.length() - 1);\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass MinStack {\n    private Stack<Integer> stack;      // Main stack to store values\n    private Stack<Integer> minStack;   // Stack to track minimum values\n    \n    /**\n     * Initialize your data structure here.\n     */\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n    \n    /**\n     * Push element val onto stack.\n     */\n    public void push(int val) {\n        stack.push(val);\n        \n        // If minStack is empty or val is less than or equal to current min,\n        // push to minStack\n        if (minStack.isEmpty() || val <= minStack.peek()) {\n            minStack.push(val);\n        }\n    }\n    \n    /**\n     * Removes the element on top of the stack.\n     */\n    public void pop() {\n        // If the popped element is the current minimum, remove from minStack too\n        if (stack.peek().equals(minStack.peek())) {\n            minStack.pop();\n        }\n        stack.pop();\n    }\n    \n    /**\n     * Get the top element of stack.\n     */\n    public int top() {\n        return stack.peek();\n    }\n    \n    /**\n     * Retrieve the minimum element in the stack.\n     */\n    public int getMin() {\n        return minStack.peek();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            MinStack minStack = new MinStack();\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                String operation = command[0];\n                \n                switch (operation) {\n                    case \"push\":\n                        int val = Integer.parseInt(command[1]);\n                        minStack.push(val);\n                        break;\n                    case \"pop\":\n                        minStack.pop();\n                        break;\n                    case \"top\":\n                        output.append(minStack.top());\n                        output.append(\"\\n\");\n                        break;\n                    case \"getMin\":\n                        output.append(minStack.getMin());\n                        output.append(\"\\n\");\n                        break;\n                }\n            }\n            \n            // Remove trailing newline if any\n            if (output.length() > 0 && output.charAt(output.length() - 1) == '\\n') {\n                output.setLength(output.length() - 1);\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <stack>\n#include <string>\n#include <sstream>\n\nclass MinStack {\nprivate:\n    // Define your data structure here\n    \npublic:\n    MinStack() {\n        // Implement initialization\n    }\n    \n    void push(int val) {\n        // Implement push operation\n    }\n    \n    void pop() {\n        // Implement pop operation\n    }\n    \n    int top() {\n        // Implement top operation\n        return 0; // Replace with actual implementation\n    }\n    \n    int getMin() {\n        // Implement getMin operation\n        return 0; // Replace with actual implementation\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    MinStack minStack;\n    std::string line, output;\n    \n    for (int i = 0; i < n; i++) {\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string operation;\n        iss >> operation;\n        \n        if (operation == \"push\") {\n            int val;\n            iss >> val;\n            minStack.push(val);\n        } else if (operation == \"pop\") {\n            minStack.pop();\n        } else if (operation == \"top\") {\n            output += std::to_string(minStack.top()) + \"\\n\";\n        } else if (operation == \"getMin\") {\n            output += std::to_string(minStack.getMin()) + \"\\n\";\n        }\n    }\n    \n    // Remove trailing newline if any\n    if (!output.empty() && output.back() == '\\n') {\n        output.pop_back();\n    }\n    \n    std::cout << output;\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <stack>\n#include <string>\n#include <sstream>\n\nclass MinStack {\nprivate:\n    std::stack<int> stack;      // Main stack to store values\n    std::stack<int> minStack;   // Stack to track minimum values\n    \npublic:\n    MinStack() {\n        // Nothing special to initialize\n    }\n    \n    void push(int val) {\n        stack.push(val);\n        \n        // If minStack is empty or val is less than or equal to current min,\n        // push to minStack\n        if (minStack.empty() || val <= minStack.top()) {\n            minStack.push(val);\n        }\n    }\n    \n    void pop() {\n        // If the popped element is the current minimum, remove from minStack too\n        if (stack.top() == minStack.top()) {\n            minStack.pop();\n        }\n        stack.pop();\n    }\n    \n    int top() {\n        return stack.top();\n    }\n    \n    int getMin() {\n        return minStack.top();\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    MinStack minStack;\n    std::string line, output;\n    \n    for (int i = 0; i < n; i++) {\n        std::getline(std::cin, line);\n        std::istringstream iss(line);\n        std::string operation;\n        iss >> operation;\n        \n        if (operation == \"push\") {\n            int val;\n            iss >> val;\n            minStack.push(val);\n        } else if (operation == \"pop\") {\n            minStack.pop();\n        } else if (operation == \"top\") {\n            output += std::to_string(minStack.top()) + \"\\n\";\n        } else if (operation == \"getMin\") {\n            output += std::to_string(minStack.getMin()) + \"\\n\";\n        }\n    }\n    \n    // Remove trailing newline if any\n    if (!output.empty() && output.back() == '\\n') {\n        output.pop_back();\n    }\n    \n    std::cout << output;\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\n\nclass MinStack:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        # Implement initialization\n        \n    def push(self, val: int) -> None:\n        \"\"\"\n        Push element val onto stack.\n        \"\"\"\n        # Implement push operation\n        \n    def pop(self) -> None:\n        \"\"\"\n        Removes the element on top of the stack.\n        \"\"\"\n        # Implement pop operation\n        \n    def top(self) -> int:\n        \"\"\"\n        Get the top element of stack.\n        \"\"\"\n        # Implement top operation\n        return 0  # Replace with actual implementation\n        \n    def getMin(self) -> int:\n        \"\"\"\n        Retrieve the minimum element in the stack.\n        \"\"\"\n        # Implement getMin operation\n        return 0  # Replace with actual implementation\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        min_stack = MinStack()\n        results = []\n        \n        for _ in range(n):\n            command = input().strip().split()\n            operation = command[0]\n            \n            if operation == \"push\":\n                val = int(command[1])\n                min_stack.push(val)\n            elif operation == \"pop\":\n                min_stack.pop()\n            elif operation == \"top\":\n                results.append(str(min_stack.top()))\n            elif operation == \"getMin\":\n                results.append(str(min_stack.getMin()))\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\n\nclass MinStack:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []       # Main stack to store values\n        self.min_stack = []   # Stack to track minimum values\n        \n    def push(self, val: int) -> None:\n        \"\"\"\n        Push element val onto stack.\n        \"\"\"\n        self.stack.append(val)\n        \n        # If min_stack is empty or val is less than or equal to current min,\n        # push to min_stack\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n        \n    def pop(self) -> None:\n        \"\"\"\n        Removes the element on top of the stack.\n        \"\"\"\n        # If the popped element is the current minimum, remove from min_stack too\n        if self.stack[-1] == self.min_stack[-1]:\n            self.min_stack.pop()\n        self.stack.pop()\n        \n    def top(self) -> int:\n        \"\"\"\n        Get the top element of stack.\n        \"\"\"\n        return self.stack[-1]\n        \n    def getMin(self) -> int:\n        \"\"\"\n        Retrieve the minimum element in the stack.\n        \"\"\"\n        return self.min_stack[-1]\n\ndef main():\n    try:\n        n = int(input().strip())\n        \n        min_stack = MinStack()\n        results = []\n        \n        for _ in range(n):\n            command = input().strip().split()\n            operation = command[0]\n            \n            if operation == \"push\":\n                val = int(command[1])\n                min_stack.push(val)\n            elif operation == \"pop\":\n                min_stack.pop()\n            elif operation == \"top\":\n                results.append(str(min_stack.top()))\n            elif operation == \"getMin\":\n                results.append(str(min_stack.getMin()))\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "7\npush -2\npush 0\npush -3\ngetMin\npop\ntop\ngetMin",
      "output": "-3\n0\n-2",
      "hidden": false,
      "explanation": "Basic operations with sequential push, getMin, pop, top, and getMin operations"
    },
    {
      "input": "10\npush 5\npush 7\npush 5\ntop\npop\npop\npush 4\npush 2\ntop\ngetMin",
      "output": "5\n2\n2",
      "hidden": true,
      "explanation": "More complex test case with repeated values and operations"
    }
  ]
} 