{
  "title": "Implement Stack using Queues",
  "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\n\nImplement the MyStack class:\n- void push(int x) Pushes element x to the top of the stack.\n- int pop() Removes the element on the top of the stack and returns it.\n- int top() Returns the element on the top of the stack.\n- boolean empty() Returns true if the stack is empty, false otherwise.\n\nNotes:\n- You must use only standard queue operations, which means that only push to back, peek/pop from front, size, and is empty operations are valid.\n- Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque as long as you use only a queue's standard operations.\n\nInput Format:\n- The first line contains a single integer n, the number of operations to perform.\n- Each of the next n lines contains an operation in one of the following formats:\n  - \"push x\" - Push integer x onto the stack.\n  - \"pop\" - Remove the top element from the stack and return it.\n  - \"top\" - Return the top element of the stack.\n  - \"empty\" - Return whether the stack is empty.\n\nOutput Format:\n- For each operation except \"push\", print the result of the operation on a new line.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= x <= 9",
    "At most 100 calls will be made to push, pop, top, and empty",
    "All the calls to pop and top are valid (i.e., there will always be an element in the stack when calling pop or top)",
    "1 <= n <= 100"
  ],
  "examples": [
    {
      "input": "7\npush 1\npush 2\ntop\npop\nempty\npush 3\nempty",
      "output": "2\n2\nfalse\nfalse",
      "explanation": "Stack operations:\npush 1 - Stack becomes [1]\npush 2 - Stack becomes [1, 2] (2 is at the top)\ntop - Returns 2, the top element\npop - Removes and returns 2, stack becomes [1]\nempty - Returns false (stack is not empty)\npush 3 - Stack becomes [1, 3]\nempty - Returns false (stack is not empty)"
    }
  ],
  "type": "programming",
  "difficultyLevel": "easy",
  "marks": 5,
  "tags": ["Stack", "Queue", "Design", "Data Structure"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "LinkedIn", "Bloomberg"],
  "hints": [
    "Remember that a stack follows LIFO (Last In First Out) principle",
    "A queue follows FIFO (First In First Out) principle",
    "One approach is to always keep the top of the stack at the front of the queue",
    "You can use two queues: one for storage and one as a buffer during operations",
    "You can also use one queue and reorder elements after each push operation"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass MyStack {\n    // Implement the stack using queues\n    \n    /** Initialize your data structure here. */\n    public MyStack() {\n        // Your implementation\n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n        // Your implementation\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        // Your implementation\n        return 0; // Replace with your implementation\n    }\n    \n    /** Get the top element. */\n    public int top() {\n        // Your implementation\n        return 0; // Replace with your implementation\n    }\n    \n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        // Your implementation\n        return false; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            MyStack stack = new MyStack();\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                \n                switch (command[0]) {\n                    case \"push\":\n                        /*RUNTIME CALC START*/\n                        stack.push(Integer.parseInt(command[1]));\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"pop\":\n                        /*RUNTIME CALC START*/\n                        output.append(stack.pop());\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"top\":\n                        /*RUNTIME CALC START*/\n                        output.append(stack.top());\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"empty\":\n                        /*RUNTIME CALC START*/\n                        output.append(stack.empty());\n                        /*RUNTIME CALC END*/\n                        break;\n                }\n                \n                // Add newline except for the last operation that produces output\n                if ((command[0].equals(\"pop\") || command[0].equals(\"top\") || command[0].equals(\"empty\")) \n                    && i < n - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass MyStack {\n    private Queue<Integer> q1; // Main queue\n    private Queue<Integer> q2; // Helper queue\n    \n    /** Initialize your data structure here. */\n    public MyStack() {\n        q1 = new LinkedList<>();\n        q2 = new LinkedList<>();\n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n        // Add the new element to the helper queue\n        q2.add(x);\n        \n        // Move all elements from main queue to helper queue\n        while (!q1.isEmpty()) {\n            q2.add(q1.remove());\n        }\n        \n        // Swap the queues\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        return q1.remove();\n    }\n    \n    /** Get the top element. */\n    public int top() {\n        return q1.peek();\n    }\n    \n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return q1.isEmpty();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            MyStack stack = new MyStack();\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                \n                switch (command[0]) {\n                    case \"push\":\n                        /*RUNTIME CALC START*/\n                        stack.push(Integer.parseInt(command[1]));\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"pop\":\n                        /*RUNTIME CALC START*/\n                        output.append(stack.pop());\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"top\":\n                        /*RUNTIME CALC START*/\n                        output.append(stack.top());\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"empty\":\n                        /*RUNTIME CALC START*/\n                        output.append(stack.empty());\n                        /*RUNTIME CALC END*/\n                        break;\n                }\n                \n                // Add newline except for the last operation that produces output\n                if ((command[0].equals(\"pop\") || command[0].equals(\"top\") || command[0].equals(\"empty\")) \n                    && i < n - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <queue>\n#include <string>\n#include <sstream>\n\nclass MyStack {\n    // Implement the stack using queues\n    \npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n        // Your implementation\n    }\n    \n    /** Push element x onto stack. */\n    void push(int x) {\n        // Your implementation\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        // Your implementation\n        return 0; // Replace with your implementation\n    }\n    \n    /** Get the top element. */\n    int top() {\n        // Your implementation\n        return 0; // Replace with your implementation\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        // Your implementation\n        return false; // Replace with your implementation\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    MyStack stack;\n    \n    for (int i = 0; i < n; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        std::istringstream iss(line);\n        std::string command;\n        iss >> command;\n        \n        if (command == \"push\") {\n            int x;\n            iss >> x;\n            /*RUNTIME CALC START*/\n            stack.push(x);\n            /*RUNTIME CALC END*/\n        } else if (command == \"pop\") {\n            /*RUNTIME CALC START*/\n            std::cout << stack.pop();\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        } else if (command == \"top\") {\n            /*RUNTIME CALC START*/\n            std::cout << stack.top();\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        } else if (command == \"empty\") {\n            /*RUNTIME CALC START*/\n            std::cout << (stack.empty() ? \"true\" : \"false\");\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <queue>\n#include <string>\n#include <sstream>\n\nclass MyStack {\nprivate:\n    std::queue<int> q1; // Main queue\n    std::queue<int> q2; // Helper queue\n    \npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n        // No initialization needed for STL queues\n    }\n    \n    /** Push element x onto stack. */\n    void push(int x) {\n        // Add the new element to the helper queue\n        q2.push(x);\n        \n        // Move all elements from main queue to helper queue\n        while (!q1.empty()) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        \n        // Swap the queues\n        std::swap(q1, q2);\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int topElement = q1.front();\n        q1.pop();\n        return topElement;\n    }\n    \n    /** Get the top element. */\n    int top() {\n        return q1.front();\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return q1.empty();\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    MyStack stack;\n    \n    for (int i = 0; i < n; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        std::istringstream iss(line);\n        std::string command;\n        iss >> command;\n        \n        if (command == \"push\") {\n            int x;\n            iss >> x;\n            /*RUNTIME CALC START*/\n            stack.push(x);\n            /*RUNTIME CALC END*/\n        } else if (command == \"pop\") {\n            /*RUNTIME CALC START*/\n            std::cout << stack.pop();\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        } else if (command == \"top\") {\n            /*RUNTIME CALC START*/\n            std::cout << stack.top();\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        } else if (command == \"empty\") {\n            /*RUNTIME CALC START*/\n            std::cout << (stack.empty() ? \"true\" : \"false\");\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom collections import deque\n\nclass MyStack:\n    # Implement the stack using queues\n    \n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        # Your implementation\n        \n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x onto stack.\n        \"\"\"\n        # Your implementation\n        \n    def pop(self) -> int:\n        \"\"\"\n        Removes the element on top of the stack and returns that element.\n        \"\"\"\n        # Your implementation\n        return 0  # Replace with your implementation\n        \n    def top(self) -> int:\n        \"\"\"\n        Get the top element.\n        \"\"\"\n        # Your implementation\n        return 0  # Replace with your implementation\n        \n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the stack is empty.\n        \"\"\"\n        # Your implementation\n        return False  # Replace with your implementation\n\ndef main():\n    try:\n        n = int(input().strip())\n        stack = MyStack()\n        \n        results = []\n        for _ in range(n):\n            command = input().strip().split()\n            \n            if command[0] == \"push\":\n                # RUNTIME CALC START\n                stack.push(int(command[1]))\n                # RUNTIME CALC END\n            elif command[0] == \"pop\":\n                # RUNTIME CALC START\n                results.append(str(stack.pop()))\n                # RUNTIME CALC END\n            elif command[0] == \"top\":\n                # RUNTIME CALC START\n                results.append(str(stack.top()))\n                # RUNTIME CALC END\n            elif command[0] == \"empty\":\n                # RUNTIME CALC START\n                results.append(str(stack.empty()).lower())\n                # RUNTIME CALC END\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.q1 = deque()  # Main queue\n        self.q2 = deque()  # Helper queue\n        \n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x onto stack.\n        \"\"\"\n        # Add new element to helper queue\n        self.q2.append(x)\n        \n        # Move all elements from main queue to helper queue\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        \n        # Swap the queues\n        self.q1, self.q2 = self.q2, self.q1\n        \n    def pop(self) -> int:\n        \"\"\"\n        Removes the element on top of the stack and returns that element.\n        \"\"\"\n        return self.q1.popleft()\n        \n    def top(self) -> int:\n        \"\"\"\n        Get the top element.\n        \"\"\"\n        return self.q1[0]\n        \n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the stack is empty.\n        \"\"\"\n        return len(self.q1) == 0\n\ndef main():\n    try:\n        n = int(input().strip())\n        stack = MyStack()\n        \n        results = []\n        for _ in range(n):\n            command = input().strip().split()\n            \n            if command[0] == \"push\":\n                # RUNTIME CALC START\n                stack.push(int(command[1]))\n                # RUNTIME CALC END\n            elif command[0] == \"pop\":\n                # RUNTIME CALC START\n                results.append(str(stack.pop()))\n                # RUNTIME CALC END\n            elif command[0] == \"top\":\n                # RUNTIME CALC START\n                results.append(str(stack.top()))\n                # RUNTIME CALC END\n            elif command[0] == \"empty\":\n                # RUNTIME CALC START\n                results.append(str(stack.empty()).lower())\n                # RUNTIME CALC END\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "7\npush 1\npush 2\ntop\npop\nempty\npush 3\nempty",
      "output": "2\n2\nfalse\nfalse",
      "hidden": false,
      "explanation": "Basic test for stack operations"
    },
    {
      "input": "9\npush 1\npush 2\npush 3\ntop\npop\ntop\npop\ntop\nempty",
      "output": "3\n3\n2\n2\n1\nfalse",
      "hidden": true,
      "explanation": "Tests multiple push and pop operations in sequence"
    }
  ]
} 