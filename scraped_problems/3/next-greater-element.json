{
  "title": "Next Greater Element",
  "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\n\nYou are given two arrays, nums1 and nums2, where nums1 is a subset of nums2. For each element in nums1, find the next greater element in nums2.\n\nThe next greater element for an element x is the first element to the right of x in nums2 that is greater than x. If there is no such element, the answer should be -1.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains an array of integers representing nums1.\n  - The second line contains an array of integers representing nums2.\n\nOutput Format:\n- For each test case, print an array where the ith element is the next greater element for nums1[i] in nums2.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= nums1.length <= 1000",
    "1 <= nums2.length <= 10^4",
    "0 <= nums1[i], nums2[i] <= 10^4",
    "All integers in nums1 and nums2 are unique",
    "All elements in nums1 exist in nums2",
    "1 <= T <= 100"
  ],
  "examples": [
    {
      "input": "2\n[4,1,2]\n[1,3,4,2]\n[2,4]\n[1,2,3,4]",
      "output": "[-1,3,-1]\n[3,-1]",
      "explanation": "Test case 1:\n- For 4 in nums1, there is no next greater element in nums2 to the right of its position, so the answer is -1.\n- For 1 in nums1, the next greater element in nums2 is 3.\n- For 2 in nums1, there is no next greater element in nums2 to the right of its position, so the answer is -1.\n\nTest case 2:\n- For 2 in nums1, the next greater element in nums2 is 3.\n- For 4 in nums1, there is no next greater element in nums2 to the right of its position, so the answer is -1."
    }
  ],
  "type": "programming",
  "difficultyLevel": "easy",
  "marks": 5,
  "tags": ["Stack", "Array", "Hash Table", "Monotonic Stack"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "Bloomberg", "Adobe", "Apple"],
  "hints": [
    "For each element in nums2, you can find its next greater element using a stack",
    "Use a hash map to store the next greater element for each number in nums2",
    "Then you can simply look up the next greater element for each number in nums1",
    "This approach is more efficient than brute force search for each element"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the next greater element for each element in nums1 from nums2\n     * @param nums1 A subset array of nums2\n     * @param nums2 The main array\n     * @return An array of next greater elements\n     */\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        // Implement your solution here\n        return new int[0]; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                String line1 = br.readLine().trim();\n                String line2 = br.readLine().trim();\n                \n                int[] nums1 = parseArray(line1);\n                int[] nums2 = parseArray(line2);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                int[] result = sol.nextGreaterElement(nums1, nums2);\n                /*RUNTIME CALC END*/\n                \n                output.append(arrayToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static int[] parseArray(String s) {\n        // Remove brackets and split by comma\n        s = s.substring(1, s.length() - 1);\n        String[] parts = s.split(\",\");\n        \n        // Handle empty array\n        if (parts.length == 1 && parts[0].isEmpty()) {\n            return new int[0];\n        }\n        \n        int[] result = new int[parts.length];\n        for (int i = 0; i < parts.length; i++) {\n            result[i] = Integer.parseInt(parts[i].trim());\n        }\n        \n        return result;\n    }\n    \n    private static String arrayToString(int[] arr) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        for (int i = 0; i < arr.length; i++) {\n            sb.append(arr[i]);\n            if (i < arr.length - 1) {\n                sb.append(\",\");\n            }\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the next greater element for each element in nums1 from nums2\n     * @param nums1 A subset array of nums2\n     * @param nums2 The main array\n     * @return An array of next greater elements\n     */\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        // Map to store the next greater element for each number in nums2\n        Map<Integer, Integer> nextGreater = new HashMap<>();\n        Stack<Integer> stack = new Stack<>();\n        \n        // Find the next greater element for each element in nums2\n        for (int num : nums2) {\n            // While stack is not empty and current element is greater than stack's top\n            while (!stack.isEmpty() && num > stack.peek()) {\n                // Current number is the next greater element for the popped number\n                nextGreater.put(stack.pop(), num);\n            }\n            stack.push(num);\n        }\n        \n        // Any remaining numbers in the stack have no next greater element\n        while (!stack.isEmpty()) {\n            nextGreater.put(stack.pop(), -1);\n        }\n        \n        // Build the result array using the map\n        int[] result = new int[nums1.length];\n        for (int i = 0; i < nums1.length; i++) {\n            result[i] = nextGreater.get(nums1[i]);\n        }\n        \n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                String line1 = br.readLine().trim();\n                String line2 = br.readLine().trim();\n                \n                int[] nums1 = parseArray(line1);\n                int[] nums2 = parseArray(line2);\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                int[] result = sol.nextGreaterElement(nums1, nums2);\n                /*RUNTIME CALC END*/\n                \n                output.append(arrayToString(result));\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static int[] parseArray(String s) {\n        // Remove brackets and split by comma\n        s = s.substring(1, s.length() - 1);\n        String[] parts = s.split(\",\");\n        \n        // Handle empty array\n        if (parts.length == 1 && parts[0].isEmpty()) {\n            return new int[0];\n        }\n        \n        int[] result = new int[parts.length];\n        for (int i = 0; i < parts.length; i++) {\n            result[i] = Integer.parseInt(parts[i].trim());\n        }\n        \n        return result;\n    }\n    \n    private static String arrayToString(int[] arr) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        \n        for (int i = 0; i < arr.length; i++) {\n            sb.append(arr[i]);\n            if (i < arr.length - 1) {\n                sb.append(\",\");\n            }\n        }\n        \n        sb.append(\"]\");\n        return sb.toString();\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <unordered_map>\n#include <sstream>\n\nclass Solution {\npublic:\n    /**\n     * Finds the next greater element for each element in nums1 from nums2\n     * @param nums1 A subset vector of nums2\n     * @param nums2 The main vector\n     * @return A vector of next greater elements\n     */\n    std::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {\n        // Implement your solution here\n        return {}; // Replace with your implementation\n    }\n};\n\n// Helper function to parse input array\nstd::vector<int> parseArray(const std::string& s) {\n    std::vector<int> result;\n    std::string content = s.substr(1, s.length() - 2); // Remove brackets\n    \n    if (content.empty()) {\n        return result;\n    }\n    \n    std::istringstream iss(content);\n    std::string token;\n    \n    while (std::getline(iss, token, ',')) {\n        result.push_back(std::stoi(token));\n    }\n    \n    return result;\n}\n\n// Helper function to convert array to string\nstd::string arrayToString(const std::vector<int>& arr) {\n    std::string result = \"[\";\n    \n    for (size_t i = 0; i < arr.size(); i++) {\n        result += std::to_string(arr[i]);\n        if (i < arr.size() - 1) {\n            result += \",\";\n        }\n    }\n    \n    result += \"]\";\n    return result;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line1, line2;\n        std::getline(std::cin, line1);\n        std::getline(std::cin, line2);\n        \n        std::vector<int> nums1 = parseArray(line1);\n        std::vector<int> nums2 = parseArray(line2);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        std::vector<int> result = sol.nextGreaterElement(nums1, nums2);\n        /*RUNTIME CALC END*/\n        \n        std::cout << arrayToString(result);\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <unordered_map>\n#include <sstream>\n\nclass Solution {\npublic:\n    /**\n     * Finds the next greater element for each element in nums1 from nums2\n     * @param nums1 A subset vector of nums2\n     * @param nums2 The main vector\n     * @return A vector of next greater elements\n     */\n    std::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {\n        // Map to store the next greater element for each number in nums2\n        std::unordered_map<int, int> nextGreater;\n        std::stack<int> stack;\n        \n        // Find the next greater element for each element in nums2\n        for (int num : nums2) {\n            // While stack is not empty and current element is greater than stack's top\n            while (!stack.empty() && num > stack.top()) {\n                // Current number is the next greater element for the popped number\n                nextGreater[stack.top()] = num;\n                stack.pop();\n            }\n            stack.push(num);\n        }\n        \n        // Any remaining numbers in the stack have no next greater element\n        while (!stack.empty()) {\n            nextGreater[stack.top()] = -1;\n            stack.pop();\n        }\n        \n        // Build the result vector using the map\n        std::vector<int> result(nums1.size());\n        for (size_t i = 0; i < nums1.size(); i++) {\n            result[i] = nextGreater[nums1[i]];\n        }\n        \n        return result;\n    }\n};\n\n// Helper function to parse input array\nstd::vector<int> parseArray(const std::string& s) {\n    std::vector<int> result;\n    std::string content = s.substr(1, s.length() - 2); // Remove brackets\n    \n    if (content.empty()) {\n        return result;\n    }\n    \n    std::istringstream iss(content);\n    std::string token;\n    \n    while (std::getline(iss, token, ',')) {\n        result.push_back(std::stoi(token));\n    }\n    \n    return result;\n}\n\n// Helper function to convert array to string\nstd::string arrayToString(const std::vector<int>& arr) {\n    std::string result = \"[\";\n    \n    for (size_t i = 0; i < arr.size(); i++) {\n        result += std::to_string(arr[i]);\n        if (i < arr.size() - 1) {\n            result += \",\";\n        }\n    }\n    \n    result += \"]\";\n    return result;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    std::cin.ignore(); // Consume newline\n    \n    for (int i = 0; i < t; i++) {\n        std::string line1, line2;\n        std::getline(std::cin, line1);\n        std::getline(std::cin, line2);\n        \n        std::vector<int> nums1 = parseArray(line1);\n        std::vector<int> nums2 = parseArray(line2);\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        std::vector<int> result = sol.nextGreaterElement(nums1, nums2);\n        /*RUNTIME CALC END*/\n        \n        std::cout << arrayToString(result);\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import List\n\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \"\"\"\n        Finds the next greater element for each element in nums1 from nums2\n        :param nums1: A subset list of nums2\n        :param nums2: The main list\n        :return: A list of next greater elements\n        \"\"\"\n        # Implement your solution here\n        return [] # Replace with your implementation\n\ndef parse_array(s: str) -> List[int]:\n    # Remove brackets and split by comma\n    s = s[1:-1]\n    if not s:\n        return []\n    return [int(x) for x in s.split(',')]\n\ndef array_to_string(arr: List[int]) -> str:\n    return \"[\" + \",\".join(map(str, arr)) + \"]\"\n\ndef main():\n    try:\n        # Read number of test cases\n        t = int(input().strip())\n        \n        results = []\n        for _ in range(t):\n            nums1 = parse_array(input().strip())\n            nums2 = parse_array(input().strip())\n            \n            # RUNTIME CALC START\n            sol = Solution()\n            result = sol.nextGreaterElement(nums1, nums2)\n            # RUNTIME CALC END\n            \n            results.append(array_to_string(result))\n        \n        # Output all results\n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\nfrom typing import List\n\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \"\"\"\n        Finds the next greater element for each element in nums1 from nums2\n        :param nums1: A subset list of nums2\n        :param nums2: The main list\n        :return: A list of next greater elements\n        \"\"\"\n        # Map to store the next greater element for each number in nums2\n        next_greater = {}\n        stack = []\n        \n        # Find the next greater element for each element in nums2\n        for num in nums2:\n            # While stack is not empty and current element is greater than stack's top\n            while stack and num > stack[-1]:\n                # Current number is the next greater element for the popped number\n                next_greater[stack.pop()] = num\n            stack.append(num)\n        \n        # Any remaining numbers in the stack have no next greater element\n        for num in stack:\n            next_greater[num] = -1\n        \n        # Build the result list using the map\n        return [next_greater[num] for num in nums1]\n\ndef parse_array(s: str) -> List[int]:\n    # Remove brackets and split by comma\n    s = s[1:-1]\n    if not s:\n        return []\n    return [int(x) for x in s.split(',')]\n\ndef array_to_string(arr: List[int]) -> str:\n    return \"[\" + \",\".join(map(str, arr)) + \"]\"\n\ndef main():\n    try:\n        # Read number of test cases\n        t = int(input().strip())\n        \n        results = []\n        for _ in range(t):\n            nums1 = parse_array(input().strip())\n            nums2 = parse_array(input().strip())\n            \n            # RUNTIME CALC START\n            sol = Solution()\n            result = sol.nextGreaterElement(nums1, nums2)\n            # RUNTIME CALC END\n            \n            results.append(array_to_string(result))\n        \n        # Output all results\n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "2\n[4,1,2]\n[1,3,4,2]\n[2,4]\n[1,2,3,4]",
      "output": "[-1,3,-1]\n[3,-1]",
      "hidden": false,
      "explanation": "Basic test cases with different array patterns"
    },
    {
      "input": "3\n[1,3,5,2,4]\n[6,5,4,3,2,1,7]\n[7,8,9]\n[1,2,3,4,5,6,7,8,9,10]\n[1,2,3,4,5]\n[5,4,3,2,1]",
      "output": "[7,7,7,7,7]\n[8,9,10]\n[-1,-1,-1,-1,-1]",
      "hidden": true,
      "explanation": "Additional test cases with various array patterns including monotonically increasing and decreasing arrays"
    }
  ]
} 