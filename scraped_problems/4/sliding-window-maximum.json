{
  "title": "Sliding Window Maximum",
  "description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n\nReturn the max sliding window.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains two integers: n (the size of the array) and k (the size of the sliding window).\n  - The second line contains n space-separated integers representing the array nums.\n\nOutput Format:\n- For each test case, print a single line containing the maximum element in each sliding window, separated by spaces.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= k <= nums.length <= 10^5",
    "-10^4 <= nums[i] <= 10^4",
    "1 <= T <= 10"
  ],
  "examples": [
    {
      "input": "2\n8 3\n1 3 -1 -3 5 3 6 7\n5 1\n1 2 3 4 5",
      "output": "3 3 5 5 6 7\n1 2 3 4 5",
      "explanation": "Test case 1:\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\nTest case 2:\nSince the window size is 1, each element is the maximum in its own window."
    }
  ],
  "type": "programming",
  "difficultyLevel": "hard",
  "marks": 15,
  "tags": ["Queue", "Deque", "Array", "Sliding Window", "Monotonic Queue"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "ByteDance", "Uber", "Adobe"],
  "hints": [
    "A naive approach would be to find the maximum in each sliding window, but this is inefficient",
    "Consider using a data structure that allows efficient additions, removals, and finding the maximum",
    "A deque (double-ended queue) can be used to maintain elements in decreasing order",
    "Only keep elements that could be the maximum in future windows",
    "This approach is known as a monotonic queue or monotonic deque"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Returns an array of maximum values in each sliding window\n     * @param nums Array of integers\n     * @param k Size of the sliding window\n     * @return Array of maximum values in each window\n     */\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        // Implement your solution here\n        return new int[0]; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                String[] firstLine = br.readLine().trim().split(\" \");\n                int n = Integer.parseInt(firstLine[0]);\n                int k = Integer.parseInt(firstLine[1]);\n                \n                String[] numsStr = br.readLine().trim().split(\" \");\n                int[] nums = new int[n];\n                for (int j = 0; j < n; j++) {\n                    nums[j] = Integer.parseInt(numsStr[j]);\n                }\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                int[] result = sol.maxSlidingWindow(nums, k);\n                /*RUNTIME CALC END*/\n                \n                for (int j = 0; j < result.length; j++) {\n                    output.append(result[j]);\n                    if (j < result.length - 1) {\n                        output.append(\" \");\n                    }\n                }\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Returns an array of maximum values in each sliding window\n     * @param nums Array of integers\n     * @param k Size of the sliding window\n     * @return Array of maximum values in each window\n     */\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums == null || nums.length == 0 || k <= 0) {\n            return new int[0];\n        }\n        \n        int n = nums.length;\n        int[] result = new int[n - k + 1];\n        \n        // Deque to store indices of elements in decreasing order\n        Deque<Integer> deque = new ArrayDeque<>();\n        \n        for (int i = 0; i < n; i++) {\n            // Remove elements outside the current window\n            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n                deque.pollFirst();\n            }\n            \n            // Remove smaller elements as they won't be the maximum\n            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n                deque.pollLast();\n            }\n            \n            // Add current element index\n            deque.offerLast(i);\n            \n            // Add to result if we have a complete window\n            if (i >= k - 1) {\n                result[i - k + 1] = nums[deque.peekFirst()];\n            }\n        }\n        \n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim());\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                String[] firstLine = br.readLine().trim().split(\" \");\n                int n = Integer.parseInt(firstLine[0]);\n                int k = Integer.parseInt(firstLine[1]);\n                \n                String[] numsStr = br.readLine().trim().split(\" \");\n                int[] nums = new int[n];\n                for (int j = 0; j < n; j++) {\n                    nums[j] = Integer.parseInt(numsStr[j]);\n                }\n                \n                /*RUNTIME CALC START*/\n                Solution sol = new Solution();\n                int[] result = sol.maxSlidingWindow(nums, k);\n                /*RUNTIME CALC END*/\n                \n                for (int j = 0; j < result.length; j++) {\n                    output.append(result[j]);\n                    if (j < result.length - 1) {\n                        output.append(\" \");\n                    }\n                }\n                \n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <string>\n#include <sstream>\n\nclass Solution {\npublic:\n    /**\n     * Returns a vector of maximum values in each sliding window\n     * @param nums Vector of integers\n     * @param k Size of the sliding window\n     * @return Vector of maximum values in each window\n     */\n    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\n        // Implement your solution here\n        return {}; // Replace with your implementation\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    for (int i = 0; i < t; i++) {\n        int n, k;\n        std::cin >> n >> k;\n        \n        std::vector<int> nums(n);\n        for (int j = 0; j < n; j++) {\n            std::cin >> nums[j];\n        }\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        std::vector<int> result = sol.maxSlidingWindow(nums, k);\n        /*RUNTIME CALC END*/\n        \n        for (int j = 0; j < result.size(); j++) {\n            std::cout << result[j];\n            if (j < result.size() - 1) {\n                std::cout << \" \";\n            }\n        }\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <string>\n#include <sstream>\n\nclass Solution {\npublic:\n    /**\n     * Returns a vector of maximum values in each sliding window\n     * @param nums Vector of integers\n     * @param k Size of the sliding window\n     * @return Vector of maximum values in each window\n     */\n    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\n        if (nums.empty() || k <= 0) {\n            return {};\n        }\n        \n        int n = nums.size();\n        std::vector<int> result(n - k + 1);\n        \n        // Deque to store indices of elements in decreasing order\n        std::deque<int> deque;\n        \n        for (int i = 0; i < n; i++) {\n            // Remove elements outside the current window\n            while (!deque.empty() && deque.front() < i - k + 1) {\n                deque.pop_front();\n            }\n            \n            // Remove smaller elements as they won't be the maximum\n            while (!deque.empty() && nums[deque.back()] < nums[i]) {\n                deque.pop_back();\n            }\n            \n            // Add current element index\n            deque.push_back(i);\n            \n            // Add to result if we have a complete window\n            if (i >= k - 1) {\n                result[i - k + 1] = nums[deque.front()];\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    for (int i = 0; i < t; i++) {\n        int n, k;\n        std::cin >> n >> k;\n        \n        std::vector<int> nums(n);\n        for (int j = 0; j < n; j++) {\n            std::cin >> nums[j];\n        }\n        \n        /*RUNTIME CALC START*/\n        Solution sol;\n        std::vector<int> result = sol.maxSlidingWindow(nums, k);\n        /*RUNTIME CALC END*/\n        \n        for (int j = 0; j < result.size(); j++) {\n            std::cout << result[j];\n            if (j < result.size() - 1) {\n                std::cout << \" \";\n            }\n        }\n        \n        if (i < t - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Returns a list of maximum values in each sliding window\n        :param nums: List of integers\n        :param k: Size of the sliding window\n        :return: List of maximum values in each window\n        \"\"\"\n        # Implement your solution here\n        return [] # Replace with your implementation\n\ndef main():\n    try:\n        t = int(input().strip())\n        \n        results = []\n        for _ in range(t):\n            line = input().strip().split()\n            n, k = int(line[0]), int(line[1])\n            \n            nums = list(map(int, input().strip().split()))\n            \n            # RUNTIME CALC START\n            sol = Solution()\n            result = sol.maxSlidingWindow(nums, k)\n            # RUNTIME CALC END\n            \n            results.append(' '.join(map(str, result)))\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\nfrom typing import List\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Returns a list of maximum values in each sliding window\n        :param nums: List of integers\n        :param k: Size of the sliding window\n        :return: List of maximum values in each window\n        \"\"\"\n        if not nums or k <= 0:\n            return []\n        \n        n = len(nums)\n        result = [0] * (n - k + 1)\n        \n        # Deque to store indices of elements in decreasing order\n        dq = deque()\n        \n        for i in range(n):\n            # Remove elements outside the current window\n            while dq and dq[0] < i - k + 1:\n                dq.popleft()\n            \n            # Remove smaller elements as they won't be the maximum\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            \n            # Add current element index\n            dq.append(i)\n            \n            # Add to result if we have a complete window\n            if i >= k - 1:\n                result[i - k + 1] = nums[dq[0]]\n        \n        return result\n\ndef main():\n    try:\n        t = int(input().strip())\n        \n        results = []\n        for _ in range(t):\n            line = input().strip().split()\n            n, k = int(line[0]), int(line[1])\n            \n            nums = list(map(int, input().strip().split()))\n            \n            # RUNTIME CALC START\n            sol = Solution()\n            result = sol.maxSlidingWindow(nums, k)\n            # RUNTIME CALC END\n            \n            results.append(' '.join(map(str, result)))\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "2\n8 3\n1 3 -1 -3 5 3 6 7\n5 1\n1 2 3 4 5",
      "output": "3 3 5 5 6 7\n1 2 3 4 5",
      "hidden": false,
      "explanation": "Basic test cases with different window sizes"
    },
    {
      "input": "3\n3 3\n1 2 3\n7 4\n1 4 2 6 2 5 1\n10 5\n-1 -2 -3 -4 -5 -6 -7 -8 -9 -10",
      "output": "3\n6 6 6 5\n-1 -2 -3 -4 -5 -6",
      "hidden": true,
      "explanation": "Test cases with window size equal to array length, larger window and negative numbers"
    }
  ]
} 