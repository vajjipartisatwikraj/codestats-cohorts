{
  "title": "Implement Queue using Stacks",
  "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\n\nImplement the MyQueue class:\n- void push(int x) Pushes element x to the back of the queue.\n- int pop() Removes the element from the front of the queue and returns it.\n- int peek() Returns the element at the front of the queue.\n- boolean empty() Returns true if the queue is empty, false otherwise.\n\nNotes:\n- You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\n- Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque as long as you use only a stack's standard operations.\n\nInput Format:\n- The first line contains a single integer n, the number of operations to perform.\n- Each of the next n lines contains an operation in one of the following formats:\n  - \"push x\" - Push integer x onto the queue.\n  - \"pop\" - Remove the front element from the queue and return it.\n  - \"peek\" - Return the front element of the queue.\n  - \"empty\" - Return whether the queue is empty.\n\nOutput Format:\n- For each operation except \"push\", print the result of the operation on a new line.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= x <= 9",
    "At most 100 calls will be made to push, pop, peek, and empty",
    "All the calls to pop and peek are valid (i.e., there will always be an element in the queue when calling pop or peek)",
    "1 <= n <= 100"
  ],
  "examples": [
    {
      "input": "8\npush 1\npush 2\npeek\npop\nempty\npush 3\nempty\npeek",
      "output": "1\n1\nfalse\nfalse\n3",
      "explanation": "MyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\nmyQueue.push(3); // queue is: [2, 3]\nmyQueue.empty(); // return false\nmyQueue.peek(); // return 2"
    }
  ],
  "type": "programming",
  "difficultyLevel": "easy",
  "marks": 5,
  "tags": ["Stack", "Queue", "Design", "Data Structure"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Twitter", "Bloomberg"],
  "hints": [
    "You need to use two stacks: one for pushing elements and one for popping elements",
    "When pushing, simply add to the push stack",
    "When popping or peeking, if the pop stack is empty, transfer all elements from push stack to pop stack",
    "This way, the elements in the pop stack will be in the reverse order of the push stack, which follows queue's FIFO property"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass MyQueue {\n    // Implement the queue using stacks\n    \n    /** Initialize your data structure here. */\n    public MyQueue() {\n        // Your implementation\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        // Your implementation\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        // Your implementation\n        return 0; // Replace with your implementation\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        // Your implementation\n        return 0; // Replace with your implementation\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        // Your implementation\n        return false; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            MyQueue queue = new MyQueue();\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                \n                switch (command[0]) {\n                    case \"push\":\n                        /*RUNTIME CALC START*/\n                        queue.push(Integer.parseInt(command[1]));\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"pop\":\n                        /*RUNTIME CALC START*/\n                        output.append(queue.pop());\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"peek\":\n                        /*RUNTIME CALC START*/\n                        output.append(queue.peek());\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"empty\":\n                        /*RUNTIME CALC START*/\n                        output.append(queue.empty());\n                        /*RUNTIME CALC END*/\n                        break;\n                }\n                \n                // Add newline except for the last operation that produces output\n                if ((command[0].equals(\"pop\") || command[0].equals(\"peek\") || command[0].equals(\"empty\")) \n                    && i < n - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass MyQueue {\n    private Stack<Integer> stackPush; // For push operations\n    private Stack<Integer> stackPop;  // For pop/peek operations\n    \n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stackPush = new Stack<>();\n        stackPop = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stackPush.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        // If stackPop is empty, transfer all elements from stackPush\n        if (stackPop.isEmpty()) {\n            transferElements();\n        }\n        return stackPop.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        // If stackPop is empty, transfer all elements from stackPush\n        if (stackPop.isEmpty()) {\n            transferElements();\n        }\n        return stackPop.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stackPush.isEmpty() && stackPop.isEmpty();\n    }\n    \n    /** Helper method to transfer elements from stackPush to stackPop */\n    private void transferElements() {\n        while (!stackPush.isEmpty()) {\n            stackPop.push(stackPush.pop());\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            MyQueue queue = new MyQueue();\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                \n                switch (command[0]) {\n                    case \"push\":\n                        /*RUNTIME CALC START*/\n                        queue.push(Integer.parseInt(command[1]));\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"pop\":\n                        /*RUNTIME CALC START*/\n                        output.append(queue.pop());\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"peek\":\n                        /*RUNTIME CALC START*/\n                        output.append(queue.peek());\n                        /*RUNTIME CALC END*/\n                        break;\n                    case \"empty\":\n                        /*RUNTIME CALC START*/\n                        output.append(queue.empty());\n                        /*RUNTIME CALC END*/\n                        break;\n                }\n                \n                // Add newline except for the last operation that produces output\n                if ((command[0].equals(\"pop\") || command[0].equals(\"peek\") || command[0].equals(\"empty\")) \n                    && i < n - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <stack>\n#include <string>\n#include <sstream>\n\nclass MyQueue {\n    // Implement the queue using stacks\n    \npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        // Your implementation\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        // Your implementation\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        // Your implementation\n        return 0; // Replace with your implementation\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        // Your implementation\n        return 0; // Replace with your implementation\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        // Your implementation\n        return false; // Replace with your implementation\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    MyQueue queue;\n    \n    for (int i = 0; i < n; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        std::istringstream iss(line);\n        std::string command;\n        iss >> command;\n        \n        if (command == \"push\") {\n            int x;\n            iss >> x;\n            /*RUNTIME CALC START*/\n            queue.push(x);\n            /*RUNTIME CALC END*/\n        } else if (command == \"pop\") {\n            /*RUNTIME CALC START*/\n            std::cout << queue.pop();\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        } else if (command == \"peek\") {\n            /*RUNTIME CALC START*/\n            std::cout << queue.peek();\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        } else if (command == \"empty\") {\n            /*RUNTIME CALC START*/\n            std::cout << (queue.empty() ? \"true\" : \"false\");\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <stack>\n#include <string>\n#include <sstream>\n\nclass MyQueue {\nprivate:\n    std::stack<int> stackPush; // For push operations\n    std::stack<int> stackPop;  // For pop/peek operations\n    \n    // Helper method to transfer elements from stackPush to stackPop\n    void transferElements() {\n        while (!stackPush.empty()) {\n            stackPop.push(stackPush.top());\n            stackPush.pop();\n        }\n    }\n    \npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        // No initialization needed for STL stacks\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stackPush.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        // If stackPop is empty, transfer all elements from stackPush\n        if (stackPop.empty()) {\n            transferElements();\n        }\n        int frontElement = stackPop.top();\n        stackPop.pop();\n        return frontElement;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        // If stackPop is empty, transfer all elements from stackPush\n        if (stackPop.empty()) {\n            transferElements();\n        }\n        return stackPop.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stackPush.empty() && stackPop.empty();\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    MyQueue queue;\n    \n    for (int i = 0; i < n; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        std::istringstream iss(line);\n        std::string command;\n        iss >> command;\n        \n        if (command == \"push\") {\n            int x;\n            iss >> x;\n            /*RUNTIME CALC START*/\n            queue.push(x);\n            /*RUNTIME CALC END*/\n        } else if (command == \"pop\") {\n            /*RUNTIME CALC START*/\n            std::cout << queue.pop();\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        } else if (command == \"peek\") {\n            /*RUNTIME CALC START*/\n            std::cout << queue.peek();\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        } else if (command == \"empty\") {\n            /*RUNTIME CALC START*/\n            std::cout << (queue.empty() ? \"true\" : \"false\");\n            /*RUNTIME CALC END*/\n            if (i < n - 1) {\n                std::cout << \"\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\n\nclass MyQueue:\n    # Implement the queue using stacks\n    \n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        # Your implementation\n        \n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        # Your implementation\n        \n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # Your implementation\n        return 0  # Replace with your implementation\n        \n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        # Your implementation\n        return 0  # Replace with your implementation\n        \n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        # Your implementation\n        return False  # Replace with your implementation\n\ndef main():\n    try:\n        n = int(input().strip())\n        queue = MyQueue()\n        \n        results = []\n        for _ in range(n):\n            command = input().strip().split()\n            \n            if command[0] == \"push\":\n                # RUNTIME CALC START\n                queue.push(int(command[1]))\n                # RUNTIME CALC END\n            elif command[0] == \"pop\":\n                # RUNTIME CALC START\n                results.append(str(queue.pop()))\n                # RUNTIME CALC END\n            elif command[0] == \"peek\":\n                # RUNTIME CALC START\n                results.append(str(queue.peek()))\n                # RUNTIME CALC END\n            elif command[0] == \"empty\":\n                # RUNTIME CALC START\n                results.append(str(queue.empty()).lower())\n                # RUNTIME CALC END\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\n\nclass MyQueue:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack_push = []  # For push operations\n        self.stack_pop = []   # For pop/peek operations\n        \n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack_push.append(x)\n        \n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # If stack_pop is empty, transfer all elements from stack_push\n        if not self.stack_pop:\n            self._transfer_elements()\n        return self.stack_pop.pop()\n        \n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        # If stack_pop is empty, transfer all elements from stack_push\n        if not self.stack_pop:\n            self._transfer_elements()\n        return self.stack_pop[-1]\n        \n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack_push) == 0 and len(self.stack_pop) == 0\n    \n    def _transfer_elements(self):\n        \"\"\"\n        Helper method to transfer elements from stack_push to stack_pop\n        \"\"\"\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n\ndef main():\n    try:\n        n = int(input().strip())\n        queue = MyQueue()\n        \n        results = []\n        for _ in range(n):\n            command = input().strip().split()\n            \n            if command[0] == \"push\":\n                # RUNTIME CALC START\n                queue.push(int(command[1]))\n                # RUNTIME CALC END\n            elif command[0] == \"pop\":\n                # RUNTIME CALC START\n                results.append(str(queue.pop()))\n                # RUNTIME CALC END\n            elif command[0] == \"peek\":\n                # RUNTIME CALC START\n                results.append(str(queue.peek()))\n                # RUNTIME CALC END\n            elif command[0] == \"empty\":\n                # RUNTIME CALC START\n                results.append(str(queue.empty()).lower())\n                # RUNTIME CALC END\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "8\npush 1\npush 2\npeek\npop\nempty\npush 3\nempty\npeek",
      "output": "1\n1\nfalse\nfalse\n3",
      "hidden": false,
      "explanation": "Basic test for queue operations"
    },
    {
      "input": "9\npush 1\npush 2\npush 3\npeek\npop\npeek\npop\npeek\nempty",
      "output": "1\n1\n2\n2\n3\nfalse",
      "hidden": true,
      "explanation": "Tests multiple push and pop operations in sequence"
    }
  ]
} 