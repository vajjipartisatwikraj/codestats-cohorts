{
  "title": "Design Circular Queue",
  "description": "Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\".\n\nOne of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.\n\nImplement the MyCircularQueue class:\n- MyCircularQueue(k) Initializes the object with the size of the queue to be k.\n- int Front() Gets the front item from the queue. If the queue is empty, return -1.\n- int Rear() Gets the last item from the queue. If the queue is empty, return -1.\n- boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.\n- boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.\n- boolean isEmpty() Checks whether the circular queue is empty or not.\n- boolean isFull() Checks whether the circular queue is full or not.\n\nInput Format:\n- The first line contains two integers n and k, where n is the number of operations to perform and k is the size of the circular queue.\n- Each of the next n lines contains an operation in one of the following formats:\n  - \"enQueue x\" - Insert element x into the circular queue.\n  - \"deQueue\" - Delete an element from the circular queue.\n  - \"Front\" - Get the front item from the queue.\n  - \"Rear\" - Get the last item from the queue.\n  - \"isEmpty\" - Check if the queue is empty.\n  - \"isFull\" - Check if the queue is full.\n\nOutput Format:\n- For each operation except initialization, print the result on a new line.\n  - For enQueue and deQueue operations, print \"true\" or \"false\".\n  - For Front and Rear operations, print the element or -1 if the queue is empty.\n  - For isEmpty and isFull operations, print \"true\" or \"false\".",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= k <= 1000",
    "0 <= value <= 1000",
    "1 <= n <= 1000",
    "At most 1000 calls will be made to enQueue, deQueue, Front, Rear, isEmpty, and isFull"
  ],
  "examples": [
    {
      "input": "10 3\nenQueue 1\nenQueue 2\nenQueue 3\nenQueue 4\nRear\nisFull\ndeQueue\nenQueue 4\nRear\nFront",
      "output": "true\ntrue\ntrue\nfalse\n3\ntrue\ntrue\ntrue\n4\n2",
      "explanation": "MyCircularQueue circularQueue = new MyCircularQueue(3);\ncircularQueue.enQueue(1); // return true\ncircularQueue.enQueue(2); // return true\ncircularQueue.enQueue(3); // return true\ncircularQueue.enQueue(4); // return false, the queue is full\ncircularQueue.Rear(); // return 3\ncircularQueue.isFull(); // return true\ncircularQueue.deQueue(); // return true\ncircularQueue.enQueue(4); // return true\ncircularQueue.Rear(); // return 4\ncircularQueue.Front(); // return 2"
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Queue", "Design", "Array", "Data Structure"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Apple", "Google", "Facebook", "Bloomberg", "Oracle"],
  "hints": [
    "Consider using an array to implement the circular queue",
    "You need to track front and rear pointers to know where the queue starts and ends",
    "When the queue is full, (rear + 1) % capacity == front",
    "When the queue is empty, front == -1 or a special marker",
    "Be careful with the handling of wrapping around in a circular manner"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass MyCircularQueue {\n    // Your implementation here\n    \n    /**\n     * Initialize your data structure here. Set the size of the queue to be k.\n     */\n    public MyCircularQueue(int k) {\n        // Implement initialization\n    }\n    \n    /**\n     * Insert an element into the circular queue. Return true if the operation is successful.\n     */\n    public boolean enQueue(int value) {\n        // Implement enQueue operation\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Delete an element from the circular queue. Return true if the operation is successful.\n     */\n    public boolean deQueue() {\n        // Implement deQueue operation\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Get the front item from the queue.\n     */\n    public int Front() {\n        // Implement Front operation\n        return -1; // Replace with your implementation\n    }\n    \n    /**\n     * Get the last item from the queue.\n     */\n    public int Rear() {\n        // Implement Rear operation\n        return -1; // Replace with your implementation\n    }\n    \n    /**\n     * Checks whether the circular queue is empty or not.\n     */\n    public boolean isEmpty() {\n        // Implement isEmpty operation\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Checks whether the circular queue is full or not.\n     */\n    public boolean isFull() {\n        // Implement isFull operation\n        return false; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] firstLine = br.readLine().trim().split(\" \");\n            int n = Integer.parseInt(firstLine[0]);\n            int k = Integer.parseInt(firstLine[1]);\n            \n            MyCircularQueue queue = new MyCircularQueue(k);\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                \n                switch (command[0]) {\n                    case \"enQueue\":\n                        boolean enqueueResult = queue.enQueue(Integer.parseInt(command[1]));\n                        output.append(enqueueResult ? \"true\" : \"false\");\n                        break;\n                    case \"deQueue\":\n                        boolean dequeueResult = queue.deQueue();\n                        output.append(dequeueResult ? \"true\" : \"false\");\n                        break;\n                    case \"Front\":\n                        output.append(queue.Front());\n                        break;\n                    case \"Rear\":\n                        output.append(queue.Rear());\n                        break;\n                    case \"isEmpty\":\n                        output.append(queue.isEmpty() ? \"true\" : \"false\");\n                        break;\n                    case \"isFull\":\n                        output.append(queue.isFull() ? \"true\" : \"false\");\n                        break;\n                }\n                \n                if (i < n - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass MyCircularQueue {\n    private int[] queue;\n    private int front; // Index of the front element\n    private int rear;  // Index of the last element\n    private int size;  // Current size of the queue\n    private int capacity; // Maximum capacity of the queue\n    \n    /**\n     * Initialize your data structure here. Set the size of the queue to be k.\n     */\n    public MyCircularQueue(int k) {\n        queue = new int[k];\n        front = -1;\n        rear = -1;\n        size = 0;\n        capacity = k;\n    }\n    \n    /**\n     * Insert an element into the circular queue. Return true if the operation is successful.\n     */\n    public boolean enQueue(int value) {\n        // Check if queue is full\n        if (isFull()) {\n            return false;\n        }\n        \n        // If queue is empty, set front to 0\n        if (isEmpty()) {\n            front = 0;\n        }\n        \n        // Move rear pointer circularly\n        rear = (rear + 1) % capacity;\n        queue[rear] = value;\n        size++;\n        \n        return true;\n    }\n    \n    /**\n     * Delete an element from the circular queue. Return true if the operation is successful.\n     */\n    public boolean deQueue() {\n        // Check if queue is empty\n        if (isEmpty()) {\n            return false;\n        }\n        \n        // If there's only one element, reset the queue\n        if (front == rear) {\n            front = -1;\n            rear = -1;\n        } else {\n            // Move front pointer circularly\n            front = (front + 1) % capacity;\n        }\n        \n        size--;\n        return true;\n    }\n    \n    /**\n     * Get the front item from the queue.\n     */\n    public int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return queue[front];\n    }\n    \n    /**\n     * Get the last item from the queue.\n     */\n    public int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return queue[rear];\n    }\n    \n    /**\n     * Checks whether the circular queue is empty or not.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n    \n    /**\n     * Checks whether the circular queue is full or not.\n     */\n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] firstLine = br.readLine().trim().split(\" \");\n            int n = Integer.parseInt(firstLine[0]);\n            int k = Integer.parseInt(firstLine[1]);\n            \n            MyCircularQueue queue = new MyCircularQueue(k);\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                \n                switch (command[0]) {\n                    case \"enQueue\":\n                        boolean enqueueResult = queue.enQueue(Integer.parseInt(command[1]));\n                        output.append(enqueueResult ? \"true\" : \"false\");\n                        break;\n                    case \"deQueue\":\n                        boolean dequeueResult = queue.deQueue();\n                        output.append(dequeueResult ? \"true\" : \"false\");\n                        break;\n                    case \"Front\":\n                        output.append(queue.Front());\n                        break;\n                    case \"Rear\":\n                        output.append(queue.Rear());\n                        break;\n                    case \"isEmpty\":\n                        output.append(queue.isEmpty() ? \"true\" : \"false\");\n                        break;\n                    case \"isFull\":\n                        output.append(queue.isFull() ? \"true\" : \"false\");\n                        break;\n                }\n                \n                if (i < n - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <string>\n#include <sstream>\n\nclass MyCircularQueue {\n    // Your implementation here\n    \npublic:\n    /**\n     * Initialize your data structure here. Set the size of the queue to be k.\n     */\n    MyCircularQueue(int k) {\n        // Implement initialization\n    }\n    \n    /**\n     * Insert an element into the circular queue. Return true if the operation is successful.\n     */\n    bool enQueue(int value) {\n        // Implement enQueue operation\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Delete an element from the circular queue. Return true if the operation is successful.\n     */\n    bool deQueue() {\n        // Implement deQueue operation\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Get the front item from the queue.\n     */\n    int Front() {\n        // Implement Front operation\n        return -1; // Replace with your implementation\n    }\n    \n    /**\n     * Get the last item from the queue.\n     */\n    int Rear() {\n        // Implement Rear operation\n        return -1; // Replace with your implementation\n    }\n    \n    /**\n     * Checks whether the circular queue is empty or not.\n     */\n    bool isEmpty() {\n        // Implement isEmpty operation\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Checks whether the circular queue is full or not.\n     */\n    bool isFull() {\n        // Implement isFull operation\n        return false; // Replace with your implementation\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, k;\n    std::cin >> n >> k;\n    std::cin.ignore(); // Consume newline\n    \n    MyCircularQueue queue(k);\n    \n    for (int i = 0; i < n; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        std::istringstream iss(line);\n        std::string command;\n        iss >> command;\n        \n        if (command == \"enQueue\") {\n            int value;\n            iss >> value;\n            bool result = queue.enQueue(value);\n            std::cout << (result ? \"true\" : \"false\");\n        } else if (command == \"deQueue\") {\n            bool result = queue.deQueue();\n            std::cout << (result ? \"true\" : \"false\");\n        } else if (command == \"Front\") {\n            std::cout << queue.Front();\n        } else if (command == \"Rear\") {\n            std::cout << queue.Rear();\n        } else if (command == \"isEmpty\") {\n            std::cout << (queue.isEmpty() ? \"true\" : \"false\");\n        } else if (command == \"isFull\") {\n            std::cout << (queue.isFull() ? \"true\" : \"false\");\n        }\n        \n        if (i < n - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nclass MyCircularQueue {\nprivate:\n    std::vector<int> queue;\n    int front;     // Index of the front element\n    int rear;      // Index of the last element\n    int size;      // Current size of the queue\n    int capacity;  // Maximum capacity of the queue\n    \npublic:\n    /**\n     * Initialize your data structure here. Set the size of the queue to be k.\n     */\n    MyCircularQueue(int k) {\n        queue.resize(k);\n        front = -1;\n        rear = -1;\n        size = 0;\n        capacity = k;\n    }\n    \n    /**\n     * Insert an element into the circular queue. Return true if the operation is successful.\n     */\n    bool enQueue(int value) {\n        // Check if queue is full\n        if (isFull()) {\n            return false;\n        }\n        \n        // If queue is empty, set front to 0\n        if (isEmpty()) {\n            front = 0;\n        }\n        \n        // Move rear pointer circularly\n        rear = (rear + 1) % capacity;\n        queue[rear] = value;\n        size++;\n        \n        return true;\n    }\n    \n    /**\n     * Delete an element from the circular queue. Return true if the operation is successful.\n     */\n    bool deQueue() {\n        // Check if queue is empty\n        if (isEmpty()) {\n            return false;\n        }\n        \n        // If there's only one element, reset the queue\n        if (front == rear) {\n            front = -1;\n            rear = -1;\n        } else {\n            // Move front pointer circularly\n            front = (front + 1) % capacity;\n        }\n        \n        size--;\n        return true;\n    }\n    \n    /**\n     * Get the front item from the queue.\n     */\n    int Front() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return queue[front];\n    }\n    \n    /**\n     * Get the last item from the queue.\n     */\n    int Rear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return queue[rear];\n    }\n    \n    /**\n     * Checks whether the circular queue is empty or not.\n     */\n    bool isEmpty() {\n        return size == 0;\n    }\n    \n    /**\n     * Checks whether the circular queue is full or not.\n     */\n    bool isFull() {\n        return size == capacity;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, k;\n    std::cin >> n >> k;\n    std::cin.ignore(); // Consume newline\n    \n    MyCircularQueue queue(k);\n    \n    for (int i = 0; i < n; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        std::istringstream iss(line);\n        std::string command;\n        iss >> command;\n        \n        if (command == \"enQueue\") {\n            int value;\n            iss >> value;\n            bool result = queue.enQueue(value);\n            std::cout << (result ? \"true\" : \"false\");\n        } else if (command == \"deQueue\") {\n            bool result = queue.deQueue();\n            std::cout << (result ? \"true\" : \"false\");\n        } else if (command == \"Front\") {\n            std::cout << queue.Front();\n        } else if (command == \"Rear\") {\n            std::cout << queue.Rear();\n        } else if (command == \"isEmpty\") {\n            std::cout << (queue.isEmpty() ? \"true\" : \"false\");\n        } else if (command == \"isFull\") {\n            std::cout << (queue.isFull() ? \"true\" : \"false\");\n        }\n        \n        if (i < n - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\n\nclass MyCircularQueue:\n    # Your implementation here\n    \n    def __init__(self, k: int):\n        \"\"\"\n        Initialize your data structure here. Set the size of the queue to be k.\n        \"\"\"\n        # Implement initialization\n        \n    def enQueue(self, value: int) -> bool:\n        \"\"\"\n        Insert an element into the circular queue. Return true if the operation is successful.\n        \"\"\"\n        # Implement enQueue operation\n        return False  # Replace with your implementation\n        \n    def deQueue(self) -> bool:\n        \"\"\"\n        Delete an element from the circular queue. Return true if the operation is successful.\n        \"\"\"\n        # Implement deQueue operation\n        return False  # Replace with your implementation\n        \n    def Front(self) -> int:\n        \"\"\"\n        Get the front item from the queue.\n        \"\"\"\n        # Implement Front operation\n        return -1  # Replace with your implementation\n        \n    def Rear(self) -> int:\n        \"\"\"\n        Get the last item from the queue.\n        \"\"\"\n        # Implement Rear operation\n        return -1  # Replace with your implementation\n        \n    def isEmpty(self) -> bool:\n        \"\"\"\n        Checks whether the circular queue is empty or not.\n        \"\"\"\n        # Implement isEmpty operation\n        return False  # Replace with your implementation\n        \n    def isFull(self) -> bool:\n        \"\"\"\n        Checks whether the circular queue is full or not.\n        \"\"\"\n        # Implement isFull operation\n        return False  # Replace with your implementation\n\ndef main():\n    try:\n        line = input().strip().split()\n        n, k = int(line[0]), int(line[1])\n        \n        queue = MyCircularQueue(k)\n        results = []\n        \n        for _ in range(n):\n            command = input().strip().split()\n            \n            if command[0] == \"enQueue\":\n                result = queue.enQueue(int(command[1]))\n                results.append(str(result).lower())\n            elif command[0] == \"deQueue\":\n                result = queue.deQueue()\n                results.append(str(result).lower())\n            elif command[0] == \"Front\":\n                results.append(str(queue.Front()))\n            elif command[0] == \"Rear\":\n                results.append(str(queue.Rear()))\n            elif command[0] == \"isEmpty\":\n                result = queue.isEmpty()\n                results.append(str(result).lower())\n            elif command[0] == \"isFull\":\n                result = queue.isFull()\n                results.append(str(result).lower())\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\n\nclass MyCircularQueue:\n    def __init__(self, k: int):\n        \"\"\"\n        Initialize your data structure here. Set the size of the queue to be k.\n        \"\"\"\n        self.queue = [0] * k\n        self.front = -1  # Index of the front element\n        self.rear = -1   # Index of the last element\n        self.size = 0    # Current size of the queue\n        self.capacity = k  # Maximum capacity of the queue\n        \n    def enQueue(self, value: int) -> bool:\n        \"\"\"\n        Insert an element into the circular queue. Return true if the operation is successful.\n        \"\"\"\n        # Check if queue is full\n        if self.isFull():\n            return False\n        \n        # If queue is empty, set front to 0\n        if self.isEmpty():\n            self.front = 0\n        \n        # Move rear pointer circularly\n        self.rear = (self.rear + 1) % self.capacity\n        self.queue[self.rear] = value\n        self.size += 1\n        \n        return True\n        \n    def deQueue(self) -> bool:\n        \"\"\"\n        Delete an element from the circular queue. Return true if the operation is successful.\n        \"\"\"\n        # Check if queue is empty\n        if self.isEmpty():\n            return False\n        \n        # If there's only one element, reset the queue\n        if self.front == self.rear:\n            self.front = -1\n            self.rear = -1\n        else:\n            # Move front pointer circularly\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size -= 1\n        return True\n        \n    def Front(self) -> int:\n        \"\"\"\n        Get the front item from the queue.\n        \"\"\"\n        if self.isEmpty():\n            return -1\n        return self.queue[self.front]\n        \n    def Rear(self) -> int:\n        \"\"\"\n        Get the last item from the queue.\n        \"\"\"\n        if self.isEmpty():\n            return -1\n        return self.queue[self.rear]\n        \n    def isEmpty(self) -> bool:\n        \"\"\"\n        Checks whether the circular queue is empty or not.\n        \"\"\"\n        return self.size == 0\n        \n    def isFull(self) -> bool:\n        \"\"\"\n        Checks whether the circular queue is full or not.\n        \"\"\"\n        return self.size == self.capacity\n\ndef main():\n    try:\n        line = input().strip().split()\n        n, k = int(line[0]), int(line[1])\n        \n        queue = MyCircularQueue(k)\n        results = []\n        \n        for _ in range(n):\n            command = input().strip().split()\n            \n            if command[0] == \"enQueue\":\n                result = queue.enQueue(int(command[1]))\n                results.append(str(result).lower())\n            elif command[0] == \"deQueue\":\n                result = queue.deQueue()\n                results.append(str(result).lower())\n            elif command[0] == \"Front\":\n                results.append(str(queue.Front()))\n            elif command[0] == \"Rear\":\n                results.append(str(queue.Rear()))\n            elif command[0] == \"isEmpty\":\n                result = queue.isEmpty()\n                results.append(str(result).lower())\n            elif command[0] == \"isFull\":\n                result = queue.isFull()\n                results.append(str(result).lower())\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "10 3\nenQueue 1\nenQueue 2\nenQueue 3\nenQueue 4\nRear\nisFull\ndeQueue\nenQueue 4\nRear\nFront",
      "output": "true\ntrue\ntrue\nfalse\n3\ntrue\ntrue\ntrue\n4\n2",
      "hidden": false,
      "explanation": "Basic test case for circular queue operations"
    },
    {
      "input": "8 5\nisEmpty\nenQueue 1\nisFull\ndeQueue\nenQueue 2\nFront\nRear\nisEmpty",
      "output": "true\ntrue\nfalse\ntrue\ntrue\n2\n2\nfalse",
      "hidden": true,
      "explanation": "Tests edge cases with empty and single element queue"
    }
  ]
} 