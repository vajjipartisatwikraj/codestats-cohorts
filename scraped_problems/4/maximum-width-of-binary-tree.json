{
  "title": "Maximum Width of Binary Tree",
  "description": "Given the root of a binary tree, return the maximum width of the given tree.\n\nThe maximum width of a tree is the maximum width among all levels.\n\nThe width of one level is defined as the length between the leftmost and the rightmost nodes in the level. The length is the number of nodes between them, including the leftmost and rightmost nodes.\n\nIt is guaranteed that the answer will not exceed 32-bit signed integer range.\n\nInput Format:\n- The first line contains a single integer n, the number of nodes in the binary tree.\n- The second line contains n space-separated integers representing the values of the nodes. A value of -1 indicates a null node.\n- The input follows level order traversal of the binary tree.\n\nOutput Format:\n- A single integer representing the maximum width of the binary tree.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "The number of nodes in the tree is in the range [1, 3000]",
    "-100 <= Node.val <= 100"
  ],
  "examples": [
    {
      "input": "7\n1 3 2 5 3 -1 9",
      "output": "4",
      "explanation": "The binary tree is:\n        1\n       / \\\n      3   2\n     / \\   \\\n    5   3   9\nThe maximum width is at the third level with 4 nodes from 5 to 9 (inclusive)."
    },
    {
      "input": "9\n1 3 2 5 -1 -1 9 6 -1 -1 -1 -1 -1 7 -1",
      "output": "7",
      "explanation": "The binary tree is:\n        1\n       / \\\n      3   2\n     /     \\\n    5       9\n   /       /\n  6       7\nThe maximum width is at the fourth level with 7 nodes from 6 to 7 (inclusive)."
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Queue", "Tree", "Binary Tree", "Breadth-First Search"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Facebook", "Amazon", "Microsoft", "Google", "Bloomberg"],
  "hints": [
    "Use level order traversal (BFS) to go through the tree level by level",
    "Assign positions to nodes: for a node at position p, its left child is at 2*p and right child at 2*p+1",
    "For each level, the width is the difference between the leftmost and rightmost nodes' positions plus 1",
    "Be careful about integer overflow when calculating node positions",
    "You can use null nodes in the input to represent an incomplete binary tree"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode(int x) {\n        val = x;\n    }\n}\n\nclass Solution {\n    /**\n     * Calculates the maximum width of the binary tree\n     * @param root Root of the binary tree\n     * @return The maximum width\n     */\n    public int widthOfBinaryTree(TreeNode root) {\n        // Implement your solution here\n        return 0; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            String[] values = br.readLine().trim().split(\" \");\n            TreeNode root = buildTree(values);\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            int result = sol.widthOfBinaryTree(root);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(result);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0 || values[0].equals(\"-1\")) {\n            return null;\n        }\n        \n        TreeNode root = new TreeNode(Integer.parseInt(values[0]));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length && !values[i].equals(\"-1\")) {\n                curr.left = new TreeNode(Integer.parseInt(values[i]));\n                queue.offer(curr.left);\n            }\n            i++;\n            \n            // Right child\n            if (i < values.length && !values[i].equals(\"-1\")) {\n                curr.right = new TreeNode(Integer.parseInt(values[i]));\n                queue.offer(curr.right);\n            }\n            i++;\n        }\n        \n        return root;\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode(int x) {\n        val = x;\n    }\n}\n\nclass Solution {\n    /**\n     * Calculates the maximum width of the binary tree\n     * @param root Root of the binary tree\n     * @return The maximum width\n     */\n    public int widthOfBinaryTree(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        \n        // Queue for level-order traversal, storing node and its position\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\n        queue.offer(new Pair<>(root, 0)); // Root has position 0\n        \n        int maxWidth = 0;\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            int leftmostPosition = queue.peek().getValue(); // Position of leftmost node in the level\n            int position = 0; // Will be updated to the position of rightmost node in the level\n            \n            // Process all nodes at the current level\n            for (int i = 0; i < levelSize; i++) {\n                Pair<TreeNode, Integer> pair = queue.poll();\n                TreeNode node = pair.getKey();\n                position = pair.getValue(); // Position in the level\n                \n                // Add left child with position 2*i\n                if (node.left != null) {\n                    queue.offer(new Pair<>(node.left, 2 * position));\n                }\n                \n                // Add right child with position 2*i + 1\n                if (node.right != null) {\n                    queue.offer(new Pair<>(node.right, 2 * position + 1));\n                }\n            }\n            \n            // Update max width with the width of the current level\n            // Width = rightmost position - leftmost position + 1\n            maxWidth = Math.max(maxWidth, position - leftmostPosition + 1);\n        }\n        \n        return maxWidth;\n    }\n    \n    // Simple Pair class to hold a node and its position\n    private static class Pair<K, V> {\n        private K key;\n        private V value;\n        \n        public Pair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n        \n        public K getKey() {\n            return key;\n        }\n        \n        public V getValue() {\n            return value;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine().trim());\n            \n            String[] values = br.readLine().trim().split(\" \");\n            TreeNode root = buildTree(values);\n            \n            /*RUNTIME CALC START*/\n            Solution sol = new Solution();\n            int result = sol.widthOfBinaryTree(root);\n            /*RUNTIME CALC END*/\n            \n            System.out.println(result);\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    private static TreeNode buildTree(String[] values) {\n        if (values == null || values.length == 0 || values[0].equals(\"-1\")) {\n            return null;\n        }\n        \n        TreeNode root = new TreeNode(Integer.parseInt(values[0]));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        int i = 1;\n        while (i < values.length) {\n            TreeNode curr = queue.poll();\n            \n            // Left child\n            if (i < values.length && !values[i].equals(\"-1\")) {\n                curr.left = new TreeNode(Integer.parseInt(values[i]));\n                queue.offer(curr.left);\n            }\n            i++;\n            \n            // Right child\n            if (i < values.length && !values[i].equals(\"-1\")) {\n                curr.right = new TreeNode(Integer.parseInt(values[i]));\n                queue.offer(curr.right);\n            }\n            i++;\n        }\n        \n        return root;\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n#include <utility>\n\n// Definition for a binary tree node\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Calculates the maximum width of the binary tree\n     * @param root Root of the binary tree\n     * @return The maximum width\n     */\n    int widthOfBinaryTree(TreeNode* root) {\n        // Implement your solution here\n        return 0; // Replace with your implementation\n    }\n};\n\n// Function to build the binary tree from input\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty() || values[0] == \"-1\") {\n        return nullptr;\n    }\n    \n    TreeNode* root = new TreeNode(std::stoi(values[0]));\n    std::queue<TreeNode*> queue;\n    queue.push(root);\n    \n    int i = 1;\n    while (i < values.size()) {\n        TreeNode* curr = queue.front();\n        queue.pop();\n        \n        // Left child\n        if (i < values.size() && values[i] != \"-1\") {\n            curr->left = new TreeNode(std::stoi(values[i]));\n            queue.push(curr->left);\n        }\n        i++;\n        \n        // Right child\n        if (i < values.size() && values[i] != \"-1\") {\n            curr->right = new TreeNode(std::stoi(values[i]));\n            queue.push(curr->right);\n        }\n        i++;\n    }\n    \n    return root;\n}\n\n// Function to free memory allocated for the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    std::string line;\n    std::getline(std::cin, line);\n    std::istringstream iss(line);\n    \n    std::vector<std::string> values(n);\n    for (int i = 0; i < n; i++) {\n        iss >> values[i];\n    }\n    \n    TreeNode* root = buildTree(values);\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    int result = sol.widthOfBinaryTree(root);\n    /*RUNTIME CALC END*/\n    \n    std::cout << result << std::endl;\n    \n    // Free memory\n    deleteTree(root);\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <sstream>\n#include <utility>\n\n// Definition for a binary tree node\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    /**\n     * Calculates the maximum width of the binary tree\n     * @param root Root of the binary tree\n     * @return The maximum width\n     */\n    int widthOfBinaryTree(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        \n        // Queue for level-order traversal, storing node and its position\n        std::queue<std::pair<TreeNode*, unsigned long long>> queue;\n        queue.push({root, 0}); // Root has position 0\n        \n        int maxWidth = 0;\n        \n        while (!queue.empty()) {\n            int levelSize = queue.size();\n            unsigned long long leftmost = queue.front().second; // Position of leftmost node\n            unsigned long long position = 0; // Will be updated to the position of rightmost node\n            \n            // Process all nodes at the current level\n            for (int i = 0; i < levelSize; i++) {\n                auto [node, pos] = queue.front();\n                queue.pop();\n                \n                position = pos; // Position in the level\n                \n                // Add left child with position 2*i\n                if (node->left != nullptr) {\n                    queue.push({node->left, 2 * pos});\n                }\n                \n                // Add right child with position 2*i + 1\n                if (node->right != nullptr) {\n                    queue.push({node->right, 2 * pos + 1});\n                }\n            }\n            \n            // Update max width with the width of the current level\n            maxWidth = std::max(maxWidth, static_cast<int>(position - leftmost + 1));\n        }\n        \n        return maxWidth;\n    }\n};\n\n// Function to build the binary tree from input\nTreeNode* buildTree(const std::vector<std::string>& values) {\n    if (values.empty() || values[0] == \"-1\") {\n        return nullptr;\n    }\n    \n    TreeNode* root = new TreeNode(std::stoi(values[0]));\n    std::queue<TreeNode*> queue;\n    queue.push(root);\n    \n    int i = 1;\n    while (i < values.size()) {\n        TreeNode* curr = queue.front();\n        queue.pop();\n        \n        // Left child\n        if (i < values.size() && values[i] != \"-1\") {\n            curr->left = new TreeNode(std::stoi(values[i]));\n            queue.push(curr->left);\n        }\n        i++;\n        \n        // Right child\n        if (i < values.size() && values[i] != \"-1\") {\n            curr->right = new TreeNode(std::stoi(values[i]));\n            queue.push(curr->right);\n        }\n        i++;\n    }\n    \n    return root;\n}\n\n// Function to free memory allocated for the tree\nvoid deleteTree(TreeNode* root) {\n    if (root == nullptr) {\n        return;\n    }\n    deleteTree(root->left);\n    deleteTree(root->right);\n    delete root;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    std::cin.ignore(); // Consume newline\n    \n    std::string line;\n    std::getline(std::cin, line);\n    std::istringstream iss(line);\n    \n    std::vector<std::string> values(n);\n    for (int i = 0; i < n; i++) {\n        iss >> values[i];\n    }\n    \n    TreeNode* root = buildTree(values);\n    \n    /*RUNTIME CALC START*/\n    Solution sol;\n    int result = sol.widthOfBinaryTree(root);\n    /*RUNTIME CALC END*/\n    \n    std::cout << result << std::endl;\n    \n    // Free memory\n    deleteTree(root);\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\nfrom collections import deque\nfrom typing import List, Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Calculates the maximum width of the binary tree\n        :param root: Root of the binary tree\n        :return: The maximum width\n        \"\"\"\n        # Implement your solution here\n        return 0  # Replace with your implementation\n\ndef build_tree(values: List[str]) -> Optional[TreeNode]:\n    if not values or values[0] == \"-1\":\n        return None\n    \n    root = TreeNode(int(values[0]))\n    queue = deque([root])\n    i = 1\n    \n    while i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values) and values[i] != \"-1\":\n            node.left = TreeNode(int(values[i]))\n            queue.append(node.left)\n        i += 1\n        \n        # Right child\n        if i < len(values) and values[i] != \"-1\":\n            node.right = TreeNode(int(values[i]))\n            queue.append(node.right)\n        i += 1\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        values = input().strip().split()\n        \n        root = build_tree(values)\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.widthOfBinaryTree(root)\n        # RUNTIME CALC END\n        \n        print(result)\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\nfrom collections import deque\nfrom typing import List, Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Calculates the maximum width of the binary tree\n        :param root: Root of the binary tree\n        :return: The maximum width\n        \"\"\"\n        if not root:\n            return 0\n        \n        # Queue for level-order traversal, storing (node, position)\n        queue = deque([(root, 0)])\n        max_width = 0\n        \n        while queue:\n            level_length = len(queue)\n            _, level_start = queue[0]  # Position of leftmost node\n            \n            # Process all nodes at the current level\n            for i in range(level_length):\n                node, position = queue.popleft()\n                \n                # Add left child with position 2*pos\n                if node.left:\n                    queue.append((node.left, position * 2))\n                \n                # Add right child with position 2*pos + 1\n                if node.right:\n                    queue.append((node.right, position * 2 + 1))\n            \n            # Calculate width of current level: rightmost - leftmost + 1\n            # The rightmost position is saved in 'position' after the loop\n            max_width = max(max_width, position - level_start + 1)\n        \n        return max_width\n\ndef build_tree(values: List[str]) -> Optional[TreeNode]:\n    if not values or values[0] == \"-1\":\n        return None\n    \n    root = TreeNode(int(values[0]))\n    queue = deque([root])\n    i = 1\n    \n    while i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values) and values[i] != \"-1\":\n            node.left = TreeNode(int(values[i]))\n            queue.append(node.left)\n        i += 1\n        \n        # Right child\n        if i < len(values) and values[i] != \"-1\":\n            node.right = TreeNode(int(values[i]))\n            queue.append(node.right)\n        i += 1\n    \n    return root\n\ndef main():\n    try:\n        n = int(input().strip())\n        values = input().strip().split()\n        \n        root = build_tree(values)\n        \n        # RUNTIME CALC START\n        sol = Solution()\n        result = sol.widthOfBinaryTree(root)\n        # RUNTIME CALC END\n        \n        print(result)\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "7\n1 3 2 5 3 -1 9",
      "output": "4",
      "hidden": false,
      "explanation": "The binary tree has a maximum width of 4 at the third level"
    },
    {
      "input": "9\n1 3 2 5 -1 -1 9 6 -1 -1 -1 -1 -1 7 -1",
      "output": "7",
      "hidden": false,
      "explanation": "The binary tree has a maximum width of 7 at the fourth level"
    },
    {
      "input": "15\n1 3 2 5 -1 -1 9 6 -1 -1 -1 -1 -1 7 8",
      "output": "8",
      "hidden": true,
      "explanation": "Test case with more complex tree structure"
    }
  ]
} 