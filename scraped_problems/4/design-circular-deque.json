{
  "title": "Design Circular Deque",
  "description": "Design your implementation of the circular double-ended queue (deque).\n\nImplement the MyCircularDeque class:\n- MyCircularDeque(int k) Initializes the deque with a maximum size of k.\n- boolean insertFront(int value) Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise.\n- boolean insertLast(int value) Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise.\n- boolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise.\n- boolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise.\n- int getFront() Returns the front item from the Deque. Returns -1 if the deque is empty.\n- int getRear() Returns the last item from the Deque. Returns -1 if the deque is empty.\n- boolean isEmpty() Returns true if the deque is empty, or false otherwise.\n- boolean isFull() Returns true if the deque is full, or false otherwise.\n\nInput Format:\n- The first line contains two integers n and k, where n is the number of operations to perform and k is the size of the deque.\n- Each of the next n lines contains an operation in one of the following formats:\n  - \"insertFront x\" - Insert integer x at the front of the deque.\n  - \"insertLast x\" - Insert integer x at the rear of the deque.\n  - \"deleteFront\" - Delete an item from the front of the deque.\n  - \"deleteLast\" - Delete an item from the rear of the deque.\n  - \"getFront\" - Get the front item of the deque.\n  - \"getRear\" - Get the rear item of the deque.\n  - \"isEmpty\" - Check if the deque is empty.\n  - \"isFull\" - Check if the deque is full.\n\nOutput Format:\n- For each operation except the initialization, print the result on a new line:\n  - For insertFront and insertLast operations, print \"true\" or \"false\".\n  - For deleteFront and deleteLast operations, print \"true\" or \"false\".\n  - For getFront and getRear operations, print the element or -1 if the deque is empty.\n  - For isEmpty and isFull operations, print \"true\" or \"false\".",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "constraintsDesc": [
    "1 <= k <= 1000",
    "0 <= value <= 1000",
    "1 <= n <= 2000",
    "At most 2000 calls will be made to the operations"
  ],
  "examples": [
    {
      "input": "9 3\ninsertLast 1\ninsertLast 2\ninsertFront 3\nisFull\ndeleteLast\ngetRear\ndeleteFront\nisEmpty\ninsertFront 4",
      "output": "true\ntrue\ntrue\ntrue\ntrue\n1\ntrue\nfalse\ntrue",
      "explanation": "MyCircularDeque circularDeque = new MyCircularDeque(3);\ncircularDeque.insertLast(1);  // return true\ncircularDeque.insertLast(2);  // return true\ncircularDeque.insertFront(3); // return true\ncircularDeque.isFull();       // return true\ncircularDeque.deleteLast();   // return true\ncircularDeque.getRear();      // return 1\ncircularDeque.deleteFront();  // return true\ncircularDeque.isEmpty();      // return false\ncircularDeque.insertFront(4); // return true"
    }
  ],
  "type": "programming",
  "difficultyLevel": "medium",
  "marks": 10,
  "tags": ["Queue", "Deque", "Design", "Data Structure"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["Amazon", "Microsoft", "Google", "Facebook", "Apple", "Uber", "LinkedIn"],
  "hints": [
    "Use an array to implement the circular deque with front and rear pointers",
    "Be careful with handling the wraparound when the pointers reach the array bounds",
    "Keep track of the current size to determine if the deque is empty or full",
    "Remember to handle special cases like when the deque is initially empty"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass MyCircularDeque {\n    // Implement your circular deque here\n    \n    /**\n     * Initialize your data structure here. Set the size of the deque to be k.\n     */\n    public MyCircularDeque(int k) {\n        // Implement initialization\n    }\n    \n    /**\n     * Adds an item at the front of Deque. Return true if the operation is successful.\n     */\n    public boolean insertFront(int value) {\n        // Implement insertFront\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Adds an item at the rear of Deque. Return true if the operation is successful.\n     */\n    public boolean insertLast(int value) {\n        // Implement insertLast\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Deletes an item from the front of Deque. Return true if the operation is successful.\n     */\n    public boolean deleteFront() {\n        // Implement deleteFront\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Deletes an item from the rear of Deque. Return true if the operation is successful.\n     */\n    public boolean deleteLast() {\n        // Implement deleteLast\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Get the front item from the deque.\n     */\n    public int getFront() {\n        // Implement getFront\n        return -1; // Replace with your implementation\n    }\n    \n    /**\n     * Get the last item from the deque.\n     */\n    public int getRear() {\n        // Implement getRear\n        return -1; // Replace with your implementation\n    }\n    \n    /**\n     * Checks whether the circular deque is empty or not.\n     */\n    public boolean isEmpty() {\n        // Implement isEmpty\n        return false; // Replace with your implementation\n    }\n    \n    /**\n     * Checks whether the circular deque is full or not.\n     */\n    public boolean isFull() {\n        // Implement isFull\n        return false; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] firstLine = br.readLine().trim().split(\" \");\n            int n = Integer.parseInt(firstLine[0]);\n            int k = Integer.parseInt(firstLine[1]);\n            \n            MyCircularDeque deque = new MyCircularDeque(k);\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                String operation = command[0];\n                \n                switch (operation) {\n                    case \"insertFront\":\n                        int frontValue = Integer.parseInt(command[1]);\n                        output.append(deque.insertFront(frontValue) ? \"true\" : \"false\");\n                        break;\n                    case \"insertLast\":\n                        int lastValue = Integer.parseInt(command[1]);\n                        output.append(deque.insertLast(lastValue) ? \"true\" : \"false\");\n                        break;\n                    case \"deleteFront\":\n                        output.append(deque.deleteFront() ? \"true\" : \"false\");\n                        break;\n                    case \"deleteLast\":\n                        output.append(deque.deleteLast() ? \"true\" : \"false\");\n                        break;\n                    case \"getFront\":\n                        output.append(deque.getFront());\n                        break;\n                    case \"getRear\":\n                        output.append(deque.getRear());\n                        break;\n                    case \"isEmpty\":\n                        output.append(deque.isEmpty() ? \"true\" : \"false\");\n                        break;\n                    case \"isFull\":\n                        output.append(deque.isFull() ? \"true\" : \"false\");\n                        break;\n                }\n                \n                if (i < n - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass MyCircularDeque {\n    private int[] arr;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n    \n    /**\n     * Initialize your data structure here. Set the size of the deque to be k.\n     */\n    public MyCircularDeque(int k) {\n        arr = new int[k];\n        front = -1;\n        rear = -1;\n        size = 0;\n        capacity = k;\n    }\n    \n    /**\n     * Adds an item at the front of Deque. Return true if the operation is successful.\n     */\n    public boolean insertFront(int value) {\n        if (isFull()) {\n            return false;\n        }\n        \n        // If deque is empty\n        if (isEmpty()) {\n            front = 0;\n            rear = 0;\n        } else {\n            // Move front pointer to previous position circularly\n            front = (front - 1 + capacity) % capacity;\n        }\n        \n        arr[front] = value;\n        size++;\n        return true;\n    }\n    \n    /**\n     * Adds an item at the rear of Deque. Return true if the operation is successful.\n     */\n    public boolean insertLast(int value) {\n        if (isFull()) {\n            return false;\n        }\n        \n        // If deque is empty\n        if (isEmpty()) {\n            front = 0;\n            rear = 0;\n        } else {\n            // Move rear pointer to next position circularly\n            rear = (rear + 1) % capacity;\n        }\n        \n        arr[rear] = value;\n        size++;\n        return true;\n    }\n    \n    /**\n     * Deletes an item from the front of Deque. Return true if the operation is successful.\n     */\n    public boolean deleteFront() {\n        if (isEmpty()) {\n            return false;\n        }\n        \n        // If this is the last element\n        if (front == rear) {\n            front = -1;\n            rear = -1;\n        } else {\n            // Move front pointer to next position circularly\n            front = (front + 1) % capacity;\n        }\n        \n        size--;\n        return true;\n    }\n    \n    /**\n     * Deletes an item from the rear of Deque. Return true if the operation is successful.\n     */\n    public boolean deleteLast() {\n        if (isEmpty()) {\n            return false;\n        }\n        \n        // If this is the last element\n        if (front == rear) {\n            front = -1;\n            rear = -1;\n        } else {\n            // Move rear pointer to previous position circularly\n            rear = (rear - 1 + capacity) % capacity;\n        }\n        \n        size--;\n        return true;\n    }\n    \n    /**\n     * Get the front item from the deque.\n     */\n    public int getFront() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return arr[front];\n    }\n    \n    /**\n     * Get the last item from the deque.\n     */\n    public int getRear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return arr[rear];\n    }\n    \n    /**\n     * Checks whether the circular deque is empty or not.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n    \n    /**\n     * Checks whether the circular deque is full or not.\n     */\n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] firstLine = br.readLine().trim().split(\" \");\n            int n = Integer.parseInt(firstLine[0]);\n            int k = Integer.parseInt(firstLine[1]);\n            \n            MyCircularDeque deque = new MyCircularDeque(k);\n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < n; i++) {\n                String[] command = br.readLine().trim().split(\" \");\n                String operation = command[0];\n                \n                switch (operation) {\n                    case \"insertFront\":\n                        int frontValue = Integer.parseInt(command[1]);\n                        output.append(deque.insertFront(frontValue) ? \"true\" : \"false\");\n                        break;\n                    case \"insertLast\":\n                        int lastValue = Integer.parseInt(command[1]);\n                        output.append(deque.insertLast(lastValue) ? \"true\" : \"false\");\n                        break;\n                    case \"deleteFront\":\n                        output.append(deque.deleteFront() ? \"true\" : \"false\");\n                        break;\n                    case \"deleteLast\":\n                        output.append(deque.deleteLast() ? \"true\" : \"false\");\n                        break;\n                    case \"getFront\":\n                        output.append(deque.getFront());\n                        break;\n                    case \"getRear\":\n                        output.append(deque.getRear());\n                        break;\n                    case \"isEmpty\":\n                        output.append(deque.isEmpty() ? \"true\" : \"false\");\n                        break;\n                    case \"isFull\":\n                        output.append(deque.isFull() ? \"true\" : \"false\");\n                        break;\n                }\n                \n                if (i < n - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nclass MyCircularDeque {\nprivate:\n    // Implement your data structure here\n\npublic:\n    /** Initialize your data structure here. Set the size of the deque to be k. */\n    MyCircularDeque(int k) {\n        // Implement initialization\n    }\n    \n    /** Adds an item at the front of Deque. Return true if the operation is successful. */\n    bool insertFront(int value) {\n        // Implement insertFront\n        return false; // Replace with your implementation\n    }\n    \n    /** Adds an item at the rear of Deque. Return true if the operation is successful. */\n    bool insertLast(int value) {\n        // Implement insertLast\n        return false; // Replace with your implementation\n    }\n    \n    /** Deletes an item from the front of Deque. Return true if the operation is successful. */\n    bool deleteFront() {\n        // Implement deleteFront\n        return false; // Replace with your implementation\n    }\n    \n    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */\n    bool deleteLast() {\n        // Implement deleteLast\n        return false; // Replace with your implementation\n    }\n    \n    /** Get the front item from the deque. */\n    int getFront() {\n        // Implement getFront\n        return -1; // Replace with your implementation\n    }\n    \n    /** Get the last item from the deque. */\n    int getRear() {\n        // Implement getRear\n        return -1; // Replace with your implementation\n    }\n    \n    /** Checks whether the circular deque is empty or not. */\n    bool isEmpty() {\n        // Implement isEmpty\n        return false; // Replace with your implementation\n    }\n    \n    /** Checks whether the circular deque is full or not. */\n    bool isFull() {\n        // Implement isFull\n        return false; // Replace with your implementation\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, k;\n    std::cin >> n >> k;\n    std::cin.ignore(); // Consume newline\n    \n    MyCircularDeque deque(k);\n    \n    for (int i = 0; i < n; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        std::istringstream iss(line);\n        std::string operation;\n        iss >> operation;\n        \n        if (operation == \"insertFront\") {\n            int value;\n            iss >> value;\n            std::cout << (deque.insertFront(value) ? \"true\" : \"false\");\n        } else if (operation == \"insertLast\") {\n            int value;\n            iss >> value;\n            std::cout << (deque.insertLast(value) ? \"true\" : \"false\");\n        } else if (operation == \"deleteFront\") {\n            std::cout << (deque.deleteFront() ? \"true\" : \"false\");\n        } else if (operation == \"deleteLast\") {\n            std::cout << (deque.deleteLast() ? \"true\" : \"false\");\n        } else if (operation == \"getFront\") {\n            std::cout << deque.getFront();\n        } else if (operation == \"getRear\") {\n            std::cout << deque.getRear();\n        } else if (operation == \"isEmpty\") {\n            std::cout << (deque.isEmpty() ? \"true\" : \"false\");\n        } else if (operation == \"isFull\") {\n            std::cout << (deque.isFull() ? \"true\" : \"false\");\n        }\n        \n        if (i < n - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nclass MyCircularDeque {\nprivate:\n    std::vector<int> arr;\n    int front;\n    int rear;\n    int size;\n    int capacity;\n\npublic:\n    /** Initialize your data structure here. Set the size of the deque to be k. */\n    MyCircularDeque(int k) {\n        arr.resize(k);\n        front = -1;\n        rear = -1;\n        size = 0;\n        capacity = k;\n    }\n    \n    /** Adds an item at the front of Deque. Return true if the operation is successful. */\n    bool insertFront(int value) {\n        if (isFull()) {\n            return false;\n        }\n        \n        // If deque is empty\n        if (isEmpty()) {\n            front = 0;\n            rear = 0;\n        } else {\n            // Move front pointer to previous position circularly\n            front = (front - 1 + capacity) % capacity;\n        }\n        \n        arr[front] = value;\n        size++;\n        return true;\n    }\n    \n    /** Adds an item at the rear of Deque. Return true if the operation is successful. */\n    bool insertLast(int value) {\n        if (isFull()) {\n            return false;\n        }\n        \n        // If deque is empty\n        if (isEmpty()) {\n            front = 0;\n            rear = 0;\n        } else {\n            // Move rear pointer to next position circularly\n            rear = (rear + 1) % capacity;\n        }\n        \n        arr[rear] = value;\n        size++;\n        return true;\n    }\n    \n    /** Deletes an item from the front of Deque. Return true if the operation is successful. */\n    bool deleteFront() {\n        if (isEmpty()) {\n            return false;\n        }\n        \n        // If this is the last element\n        if (front == rear) {\n            front = -1;\n            rear = -1;\n        } else {\n            // Move front pointer to next position circularly\n            front = (front + 1) % capacity;\n        }\n        \n        size--;\n        return true;\n    }\n    \n    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */\n    bool deleteLast() {\n        if (isEmpty()) {\n            return false;\n        }\n        \n        // If this is the last element\n        if (front == rear) {\n            front = -1;\n            rear = -1;\n        } else {\n            // Move rear pointer to previous position circularly\n            rear = (rear - 1 + capacity) % capacity;\n        }\n        \n        size--;\n        return true;\n    }\n    \n    /** Get the front item from the deque. */\n    int getFront() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return arr[front];\n    }\n    \n    /** Get the last item from the deque. */\n    int getRear() {\n        if (isEmpty()) {\n            return -1;\n        }\n        return arr[rear];\n    }\n    \n    /** Checks whether the circular deque is empty or not. */\n    bool isEmpty() {\n        return size == 0;\n    }\n    \n    /** Checks whether the circular deque is full or not. */\n    bool isFull() {\n        return size == capacity;\n    }\n};\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, k;\n    std::cin >> n >> k;\n    std::cin.ignore(); // Consume newline\n    \n    MyCircularDeque deque(k);\n    \n    for (int i = 0; i < n; i++) {\n        std::string line;\n        std::getline(std::cin, line);\n        \n        std::istringstream iss(line);\n        std::string operation;\n        iss >> operation;\n        \n        if (operation == \"insertFront\") {\n            int value;\n            iss >> value;\n            std::cout << (deque.insertFront(value) ? \"true\" : \"false\");\n        } else if (operation == \"insertLast\") {\n            int value;\n            iss >> value;\n            std::cout << (deque.insertLast(value) ? \"true\" : \"false\");\n        } else if (operation == \"deleteFront\") {\n            std::cout << (deque.deleteFront() ? \"true\" : \"false\");\n        } else if (operation == \"deleteLast\") {\n            std::cout << (deque.deleteLast() ? \"true\" : \"false\");\n        } else if (operation == \"getFront\") {\n            std::cout << deque.getFront();\n        } else if (operation == \"getRear\") {\n            std::cout << deque.getRear();\n        } else if (operation == \"isEmpty\") {\n            std::cout << (deque.isEmpty() ? \"true\" : \"false\");\n        } else if (operation == \"isFull\") {\n            std::cout << (deque.isFull() ? \"true\" : \"false\");\n        }\n        \n        if (i < n - 1) {\n            std::cout << \"\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        \"\"\"\n        Initialize your data structure here. Set the size of the deque to be k.\n        \"\"\"\n        # Implement initialization\n        \n    def insertFront(self, value: int) -> bool:\n        \"\"\"\n        Adds an item at the front of Deque. Return true if the operation is successful.\n        \"\"\"\n        # Implement insertFront\n        return False # Replace with your implementation\n        \n    def insertLast(self, value: int) -> bool:\n        \"\"\"\n        Adds an item at the rear of Deque. Return true if the operation is successful.\n        \"\"\"\n        # Implement insertLast\n        return False # Replace with your implementation\n        \n    def deleteFront(self) -> bool:\n        \"\"\"\n        Deletes an item from the front of Deque. Return true if the operation is successful.\n        \"\"\"\n        # Implement deleteFront\n        return False # Replace with your implementation\n        \n    def deleteLast(self) -> bool:\n        \"\"\"\n        Deletes an item from the rear of Deque. Return true if the operation is successful.\n        \"\"\"\n        # Implement deleteLast\n        return False # Replace with your implementation\n        \n    def getFront(self) -> int:\n        \"\"\"\n        Get the front item from the deque.\n        \"\"\"\n        # Implement getFront\n        return -1 # Replace with your implementation\n        \n    def getRear(self) -> int:\n        \"\"\"\n        Get the last item from the deque.\n        \"\"\"\n        # Implement getRear\n        return -1 # Replace with your implementation\n        \n    def isEmpty(self) -> bool:\n        \"\"\"\n        Checks whether the circular deque is empty or not.\n        \"\"\"\n        # Implement isEmpty\n        return False # Replace with your implementation\n        \n    def isFull(self) -> bool:\n        \"\"\"\n        Checks whether the circular deque is full or not.\n        \"\"\"\n        # Implement isFull\n        return False # Replace with your implementation\n\ndef main():\n    try:\n        line = input().strip().split()\n        n, k = int(line[0]), int(line[1])\n        \n        deque = MyCircularDeque(k)\n        results = []\n        \n        for _ in range(n):\n            command = input().strip().split()\n            operation = command[0]\n            \n            if operation == \"insertFront\":\n                value = int(command[1])\n                results.append(str(deque.insertFront(value)).lower())\n            elif operation == \"insertLast\":\n                value = int(command[1])\n                results.append(str(deque.insertLast(value)).lower())\n            elif operation == \"deleteFront\":\n                results.append(str(deque.deleteFront()).lower())\n            elif operation == \"deleteLast\":\n                results.append(str(deque.deleteLast()).lower())\n            elif operation == \"getFront\":\n                results.append(str(deque.getFront()))\n            elif operation == \"getRear\":\n                results.append(str(deque.getRear()))\n            elif operation == \"isEmpty\":\n                results.append(str(deque.isEmpty()).lower())\n            elif operation == \"isFull\":\n                results.append(str(deque.isFull()).lower())\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
      "solutionCode": "import sys\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        \"\"\"\n        Initialize your data structure here. Set the size of the deque to be k.\n        \"\"\"\n        self.arr = [0] * k\n        self.front = -1\n        self.rear = -1\n        self.size = 0\n        self.capacity = k\n        \n    def insertFront(self, value: int) -> bool:\n        \"\"\"\n        Adds an item at the front of Deque. Return true if the operation is successful.\n        \"\"\"\n        if self.isFull():\n            return False\n        \n        # If deque is empty\n        if self.isEmpty():\n            self.front = 0\n            self.rear = 0\n        else:\n            # Move front pointer to previous position circularly\n            self.front = (self.front - 1 + self.capacity) % self.capacity\n        \n        self.arr[self.front] = value\n        self.size += 1\n        return True\n        \n    def insertLast(self, value: int) -> bool:\n        \"\"\"\n        Adds an item at the rear of Deque. Return true if the operation is successful.\n        \"\"\"\n        if self.isFull():\n            return False\n        \n        # If deque is empty\n        if self.isEmpty():\n            self.front = 0\n            self.rear = 0\n        else:\n            # Move rear pointer to next position circularly\n            self.rear = (self.rear + 1) % self.capacity\n        \n        self.arr[self.rear] = value\n        self.size += 1\n        return True\n        \n    def deleteFront(self) -> bool:\n        \"\"\"\n        Deletes an item from the front of Deque. Return true if the operation is successful.\n        \"\"\"\n        if self.isEmpty():\n            return False\n        \n        # If this is the last element\n        if self.front == self.rear:\n            self.front = -1\n            self.rear = -1\n        else:\n            # Move front pointer to next position circularly\n            self.front = (self.front + 1) % self.capacity\n        \n        self.size -= 1\n        return True\n        \n    def deleteLast(self) -> bool:\n        \"\"\"\n        Deletes an item from the rear of Deque. Return true if the operation is successful.\n        \"\"\"\n        if self.isEmpty():\n            return False\n        \n        # If this is the last element\n        if self.front == self.rear:\n            self.front = -1\n            self.rear = -1\n        else:\n            # Move rear pointer to previous position circularly\n            self.rear = (self.rear - 1 + self.capacity) % self.capacity\n        \n        self.size -= 1\n        return True\n        \n    def getFront(self) -> int:\n        \"\"\"\n        Get the front item from the deque.\n        \"\"\"\n        if self.isEmpty():\n            return -1\n        return self.arr[self.front]\n        \n    def getRear(self) -> int:\n        \"\"\"\n        Get the last item from the deque.\n        \"\"\"\n        if self.isEmpty():\n            return -1\n        return self.arr[self.rear]\n        \n    def isEmpty(self) -> bool:\n        \"\"\"\n        Checks whether the circular deque is empty or not.\n        \"\"\"\n        return self.size == 0\n        \n    def isFull(self) -> bool:\n        \"\"\"\n        Checks whether the circular deque is full or not.\n        \"\"\"\n        return self.size == self.capacity\n\ndef main():\n    try:\n        line = input().strip().split()\n        n, k = int(line[0]), int(line[1])\n        \n        deque = MyCircularDeque(k)\n        results = []\n        \n        for _ in range(n):\n            command = input().strip().split()\n            operation = command[0]\n            \n            if operation == \"insertFront\":\n                value = int(command[1])\n                results.append(str(deque.insertFront(value)).lower())\n            elif operation == \"insertLast\":\n                value = int(command[1])\n                results.append(str(deque.insertLast(value)).lower())\n            elif operation == \"deleteFront\":\n                results.append(str(deque.deleteFront()).lower())\n            elif operation == \"deleteLast\":\n                results.append(str(deque.deleteLast()).lower())\n            elif operation == \"getFront\":\n                results.append(str(deque.getFront()))\n            elif operation == \"getRear\":\n                results.append(str(deque.getRear()))\n            elif operation == \"isEmpty\":\n                results.append(str(deque.isEmpty()).lower())\n            elif operation == \"isFull\":\n                results.append(str(deque.isFull()).lower())\n        \n        print('\\n'.join(results))\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "9 3\ninsertLast 1\ninsertLast 2\ninsertFront 3\nisFull\ndeleteLast\ngetRear\ndeleteFront\nisEmpty\ninsertFront 4",
      "output": "true\ntrue\ntrue\ntrue\ntrue\n1\ntrue\nfalse\ntrue",
      "hidden": false,
      "explanation": "Basic test case with various deque operations"
    },
    {
      "input": "10 2\nisEmpty\ninsertFront 5\nisFull\ninsertLast 10\nisFull\ngetFront\ngetRear\ndeleteFront\ngetFront\nisEmpty",
      "output": "true\ntrue\nfalse\ntrue\ntrue\n5\n10\ntrue\n10\nfalse",
      "hidden": true,
      "explanation": "Test case checking edge cases with a small capacity deque"
    }
  ]
} 