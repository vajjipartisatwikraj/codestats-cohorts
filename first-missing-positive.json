{
  "title": "First Missing Positive",
  "description": "Given an unsorted integer array nums, return the smallest positive integer that is not present in nums.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - A single line containing an array of integers in the format [x1,x2,...,xn].\n\nOutput Format:\n- For each test case, print a single integer representing the smallest positive integer that is missing from the array.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "examples": [
    {
      "input": "3\n[1,2,0]\n[3,4,-1,1]\n[7,8,9,11,12]",
      "output": "3\n2\n1",
      "explanation": "For test case 1: The numbers in the range [1,2] are all in the array, so the first missing positive is 3.\nFor test case 2: 1 is in the array but 2 is missing, so the answer is 2.\nFor test case 3: The smallest positive integer 1 is missing."
    }
  ],
  "type": "programming",
  "difficultyLevel": "hard",
  "marks": 15,
  "tags": ["Arrays", "Hashing", "In-place Modification"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["x", "y"],
  "hints": [
    "Use in-place array modification to achieve O(1) space complexity",
    "Think about how you can use the array indices as a hash table",
    "Consider marking presence by sign flipping or value placement"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the first missing positive integer in the array.\n     * @param nums The input array.\n     * @return The smallest positive integer that is not in nums.\n     */\n    public int firstMissingPositive(int[] nums) {\n        // Implement your solution here\n        // The solution must run in O(n) time and use O(1) extra space\n        return 0; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        /*RUNTIME CALC START*/\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine().trim()); // Read number of test cases\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int i = 0; i < t; i++) {\n            String line = br.readLine().trim();\n            if (line.length() <= 2) { // Handle empty arrays\n                int[] nums = new int[0];\n                Solution sol = new Solution();\n                int result = sol.firstMissingPositive(nums);\n                output.append(result);\n            } else {\n                String[] strNums = line.substring(1, line.length() - 1).split(\",\");\n                \n                int[] nums = new int[strNums.length];\n                for (int j = 0; j < strNums.length; j++) {\n                    nums[j] = Integer.parseInt(strNums[j].trim());\n                }\n                \n                Solution sol = new Solution();\n                int result = sol.firstMissingPositive(nums);\n                \n                output.append(result);\n            }\n            \n            if (i < t - 1) {\n                output.append(\"\\n\");\n            }\n        }\n        \n        System.out.println(output.toString());\n        /*RUNTIME CALC END*/\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the first missing positive integer in the array.\n     * @param nums The input array.\n     * @return The smallest positive integer that is not in nums.\n     */\n    public int firstMissingPositive(int[] nums) {\n        for(int i=0;i<nums.length;i++){\n            while(nums[i] > 0 && nums[i] <= nums.length && nums[nums[i] - 1] != nums[i]){\n                int temp = nums[nums[i]-1];\n                nums[nums[i]-1] = nums[i];\n                nums[i] = temp;\n            }\n        }\n        int i=0;\n        for(i=0;i<nums.length;i++){\n            if(nums[i] != i+1){\n                return i+1;\n            }\n        }\n        return i+1;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        /*RUNTIME CALC START*/\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim()); // Read number of test cases\n            \n            StringBuilder output = new StringBuilder();\n            \n            for (int i = 0; i < t; i++) {\n                String line = br.readLine().trim();\n                int[] nums;\n                \n                // Parse the array based on its length\n                if (line.length() <= 2) { // [], [, ] or empty string\n                    nums = new int[0];\n                } else {\n                    // Remove brackets\n                    String content = line.substring(1, line.length() - 1).trim();\n                    String[] strNums = content.split(\",\");\n                    nums = new int[strNums.length];\n                    for (int j = 0; j < strNums.length; j++) {\n                        nums[j] = Integer.parseInt(strNums[j].trim());\n                    }\n                }\n                \n                Solution sol = new Solution();\n                int result = sol.firstMissingPositive(nums);\n                \n                output.append(result);\n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            \n            System.out.println(output.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        /*RUNTIME CALC END*/\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <chrono>  // For runtime calculation\n#include <limits>  // For numeric limits\n\nclass Solution {\npublic:\n    int firstMissingPositive(std::vector<int>& nums) {\n        // Your code here\n        // The solution must run in O(n) time and use O(1) extra space\n        return 0;  // Replace with your implementation\n    }\n};\n\nclass Main {\npublic:\n    static void main() {\n        /*RUNTIME CALC START*/\n        try {\n            // Read number of test cases\n            int t;\n            std::cin >> t;\n            std::cin.ignore(); // Consume newline\n            \n            for (int i = 0; i < t; i++) {\n                std::string line;\n                std::getline(std::cin, line);\n                \n                // Parse the array\n                std::vector<int> nums = parseArray(line);\n                \n                // Solve the problem\n                Solution sol;\n                int result = sol.firstMissingPositive(nums);\n                \n                // Output result\n                std::cout << result << std::endl; // Always add a newline to separate results\n            }\n        } catch (const std::exception& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n        }\n        /*RUNTIME CALC END*/\n    }\n\nprivate:\n    // Helper function to parse array from string\n    static std::vector<int> parseArray(const std::string& str) {\n        std::vector<int> result;\n        std::string content = str;\n        \n        // Remove brackets\n        if (content.length() >= 2) {\n            content = content.substr(1, content.length() - 2);\n        }\n        \n        if (content.empty()) {\n            return result;\n        }\n        \n        std::stringstream ss(content);\n        std::string item;\n        while (std::getline(ss, item, ',')) {\n            result.push_back(std::stoi(item));\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Main::main();\n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <chrono>  // For runtime calculation\n#include <limits>  // For numeric limits\n\nclass Solution {\npublic:\n    int firstMissingPositive(std::vector<int>& nums) {\n        // Filter positive numbers\n        std::vector<int> filteredNums;\n        for (int n : nums) {\n            if (n > 0) {\n                filteredNums.push_back(n);\n            }\n        }\n        \n        // Sort the filtered array\n        std::sort(filteredNums.begin(), filteredNums.end());\n        \n        // Find the first missing positive\n        int target = 1;\n        for (int n : filteredNums) {\n            if (n == target) {\n                target++;\n            } else if (n > target) {\n                return target;\n            }\n        }\n        \n        return target;\n    }\n};\n\nclass Main {\npublic:\n    static void main() {\n        /*RUNTIME CALC START*/\n        try {\n            // Read number of test cases\n            int t;\n            std::cin >> t;\n            std::cin.ignore(); // Consume newline\n            \n            for (int i = 0; i < t; i++) {\n                std::string line;\n                std::getline(std::cin, line);\n                \n                // Parse the array\n                std::vector<int> nums = parseArray(line);\n                \n                // Solve the problem\n                Solution sol;\n                int result = sol.firstMissingPositive(nums);\n                \n                // Output result\n                std::cout << result << std::endl; // Always add a newline to separate results\n            }\n        } catch (const std::exception& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n        }\n        /*RUNTIME CALC END*/\n    }\n\nprivate:\n    // Helper function to parse array from string\n    static std::vector<int> parseArray(const std::string& str) {\n        std::vector<int> result;\n        std::string content = str;\n        \n        // Remove brackets\n        if (content.length() >= 2) {\n            content = content.substr(1, content.length() - 2);\n        }\n        \n        if (content.empty()) {\n            return result;\n        }\n        \n        std::stringstream ss(content);\n        std::string item;\n        while (std::getline(ss, item, ',')) {\n            result.push_back(std::stoi(item));\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Main::main();\n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\n\nclass Solution:\n    def firstMissingPositive(self, nums):\n        # Your code here\n        # The solution must run in O(n) time and use O(1) extra space\n        return 0  # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        \"\"\"RUNTIME CALC START\"\"\"\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                line = input().strip()\n                \n                # Parse the array\n                if line in [\"[]\", \"[\", \"]\", \"\"]:\n                    nums = []\n                else:\n                    # Remove brackets and split by comma\n                    content = line[1:-1].strip()\n                    nums = [int(x.strip()) for x in content.split(',')]\n                \n                # Solve the problem\n                sol = Solution()\n                result = sol.firstMissingPositive(nums)\n                \n                results.append(str(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n        \"\"\"RUNTIME CALC END\"\"\"\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\n\nclass Solution:\n    def firstMissingPositive(self, nums):\n        # Filter positive numbers\n        filtered_nums = [n for n in nums if n > 0]\n        \n        # Sort the filtered array\n        filtered_nums.sort()\n        \n        # Find the first missing positive\n        target = 1\n        for n in filtered_nums:\n            if n == target:\n                target += 1\n            elif n > target:\n                return target\n        \n        return target\n\nclass Main:\n    @staticmethod\n    def main():\n        \"\"\"RUNTIME CALC START\"\"\"\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n            \n            results = []\n            for _ in range(t):\n                line = input().strip()\n                \n                # Parse the array\n                if line in [\"[]\", \"[\", \"]\", \"\"]:\n                    nums = []\n                else:\n                    # Remove brackets and split by comma\n                    content = line[1:-1].strip()\n                    nums = [int(x.strip()) for x in content.split(',')]\n                \n                # Solve the problem\n                sol = Solution()\n                result = sol.firstMissingPositive(nums)\n                \n                results.append(str(result))\n            \n            # Output all results\n            print('\\n'.join(results))\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n        \"\"\"RUNTIME CALC END\"\"\"\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "3\n[1,2,0]\n[3,4,-1,1]\n[7,8,9,11,12]",
      "output": "3\n2\n1",
      "hidden": false,
      "explanation": "Multiple test cases"
    },
    {
      "input": "4\n[1,1]\n[1,2,3,4,5]\n[]\n[-5,-3,-1,0,1]",
      "output": "2\n6\n1\n2",
      "hidden": true,
      "explanation": "Edge cases including duplicate, empty, and negative numbers"
    }
  ]
} 