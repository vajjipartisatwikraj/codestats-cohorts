{
  "title": "First Missing Positive",
  "description": "Given an unsorted integer array nums, return the smallest positive integer that is not present in nums.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n\nInput Format:\n- The first line contains a single integer T, the number of test cases.\n- For each test case:\n  - The first line contains an integer n, the size of the array.\n  - The second line contains an array of integers in the format [x1,x2,...,xn].\n\nOutput Format:\n- For each test case, print a single integer representing the smallest positive integer that is missing from the array.",
  "constraints": {
    "timeLimit": 1000,
    "memoryLimit": 256
  },
  "examples": [
    {
      "input": "3\n3\n[1,2,0]\n4\n[3,4,-1,1]\n5\n[7,8,9,11,12]",
      "output": "3\n2\n1",
      "explanation": "For test case 1: The numbers in the range [1,2] are all in the array, so the first missing positive is 3.\nFor test case 2: 1 is in the array but 2 is missing, so the answer is 2.\nFor test case 3: The smallest positive integer 1 is missing."
    }
  ],
  "type": "programming",
  "difficultyLevel": "hard",
  "marks": 15,
  "tags": ["Arrays", "Hashing", "In-place Modification"],
  "maintag": "Data Structures & Algorithms",
  "companies": ["x", "y"],
  "hints": [
    "Use in-place array modification to achieve O(1) space complexity",
    "Think about how you can use the array indices as a hash table",
    "Consider marking presence by sign flipping or value placement"
  ],
  "languages": [
    {
      "name": "java",
      "version": "15.0.2",
      "boilerplateCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the first missing positive integer in the array.\n     * @param nums The input array.\n     * @return The smallest positive integer that is not in nums.\n     */\n    public int firstMissingPositive(int[] nums) {\n        // Implement your solution here\n        // The solution must run in O(n) time and use O(1) extra space\n        return 0; // Replace with your implementation\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim()); // Read number of test cases\n            \n            int[][] allInputs = new int[t][];\n            for (int i = 0; i < t; i++) {\n                String n = br.readLine(); //Not used\n                String line = br.readLine().trim();\n                if (line.length() <= 2) { // [], [, ] or empty string\n                    allInputs[i] = new int[0];\n                } else {\n                    // Remove brackets\n                    String content = line.substring(1, line.length() - 1).trim();\n                    String[] strNums = content.split(\",\");\n                    int[] nums = new int[strNums.length];\n                    for (int j = 0; j < strNums.length; j++) {\n                        nums[j] = Integer.parseInt(strNums[j].trim());\n                    }\n                    allInputs[i] = nums;\n                }\n            }\n            \n            Solution sol = new Solution();\n            StringBuilder output = new StringBuilder();\n            \n            /*RUNTIME CALC START*/\n            \n            for (int i = 0; i < t; i++) {\n                int result = sol.firstMissingPositive(allInputs[i]);\n                output.append(result);\n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            System.out.println(output.toString());\n\n            \n            /*RUNTIME CALC END*/\n            \n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "solutionCode": "import java.util.*;\nimport java.io.*;\n\nclass Solution {\n    /**\n     * Finds the first missing positive integer in the array.\n     * @param nums The input array.\n     * @return The smallest positive integer that is not in nums.\n     */\n    public int firstMissingPositive(int[] nums) {\n        for(int i=0;i<nums.length;i++){\n            while(nums[i] > 0 && nums[i] <= nums.length && nums[nums[i] - 1] != nums[i]){\n                int temp = nums[nums[i]-1];\n                nums[nums[i]-1] = nums[i];\n                nums[i] = temp;\n            }\n        }\n        int i=0;\n        for(i=0;i<nums.length;i++){\n            if(nums[i] != i+1){\n                return i+1;\n            }\n        }\n        return i+1;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine().trim()); // Read number of test cases\n            \n            int[][] allInputs = new int[t][];\n            for (int i = 0; i < t; i++) {\n                String n = br.readLine(); //Not used\n                String line = br.readLine().trim();\n                if (line.length() <= 2) { // [], [, ] or empty string\n                    allInputs[i] = new int[0];\n                } else {\n                    // Remove brackets\n                    String content = line.substring(1, line.length() - 1).trim();\n                    String[] strNums = content.split(\",\");\n                    int[] nums = new int[strNums.length];\n                    for (int j = 0; j < strNums.length; j++) {\n                        nums[j] = Integer.parseInt(strNums[j].trim());\n                    }\n                    allInputs[i] = nums;\n                }\n            }\n            \n            Solution sol = new Solution();\n            StringBuilder output = new StringBuilder();\n            \n            /*RUNTIME CALC START*/\n            \n            for (int i = 0; i < t; i++) {\n                int result = sol.firstMissingPositive(allInputs[i]);\n                output.append(result);\n                if (i < t - 1) {\n                    output.append(\"\\n\");\n                }\n            }\n            System.out.println(output.toString());\n\n            \n            /*RUNTIME CALC END*/\n            \n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "name": "cpp",
      "version": "17",
      "boilerplateCode": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <chrono>  // For runtime calculation\n\nclass Solution {\npublic:\n    int firstMissingPositive(std::vector<int>& nums) {\n        // Your code here\n        // The solution must run in O(n) time and use O(1) extra space\n        return 0;  // Replace with your implementation\n    }\n};\n\n// Helper function to parse array from string\nstd::vector<int> parseArray(const std::string& str) {\n    std::vector<int> result;\n    std::string num;\n    for (char ch : str) {\n        if ((ch >= '0' && ch <= '9') || ch == '-') {\n            num += ch;\n        } else if (!num.empty()) {\n            result.push_back(std::stoi(num));\n            num.clear();\n        }\n    }\n    if (!num.empty()) {\n        result.push_back(std::stoi(num));\n    }\n    return result;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    /*RUNTIME CALC START*/\n    \n\n    int t;\n    std::cin >> t;\n    std::cin.ignore();\n\n    for (int i = 0; i < t; ++i) {\n        int n; // Read size but do not use it\n        std::cin >> n;\n        std::cin.ignore();\n\n        std::string line;\n        std::getline(std::cin, line);\n        std::vector<int> nums = parseArray(line);\n\n        Solution sol;\n        int result = sol.firstMissingPositive(nums);\n        std::cout << result << '\\n';  // Only result, no time printed\n    }\n\n    /*RUNTIME CALC END*/\n    \n\n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <chrono>  // For runtime calculation\n\nclass Solution {\npublic:\n    int firstMissingPositive(std::vector<int>& nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            while (nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i] - 1] != nums[i]) {\n                std::swap(nums[nums[i] - 1], nums[i]);\n            }\n        }\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        \n        return nums.size() + 1;\n    }\n};\n\n// Helper to parse array string like \"[1, 2, 3]\"\nstd::vector<int> parseArray(const std::string& str) {\n    std::vector<int> result;\n    std::string num;\n    for (char ch : str) {\n        if ((ch >= '0' && ch <= '9') || ch == '-') {\n            num += ch;\n        } else if (!num.empty()) {\n            result.push_back(std::stoi(num));\n            num.clear();\n        }\n    }\n    if (!num.empty()) {\n        result.push_back(std::stoi(num));\n    }\n    return result;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    /*RUNTIME CALC START*/\n    \n\n    int t;\n    std::cin >> t;\n    std::cin.ignore();\n\n    for (int i = 0; i < t; ++i) {\n        int n; // Read size but do not use it\n        std::cin >> n;\n        std::cin.ignore();\n\n        std::string line;\n        std::getline(std::cin, line);\n        std::vector<int> nums = parseArray(line);\n\n        Solution sol;\n        int result = sol.firstMissingPositive(nums);\n        std::cout << result << '\\n';  // Only output result\n    }\n\n    /*RUNTIME CALC END*/\n    \n\n    return 0;\n}"
    },
    {
      "name": "python",
      "version": "3.9.0",
      "boilerplateCode": "import sys\n\nclass Solution:\n    def firstMissingPositive(self, nums):\n        # Your code here\n        # The solution must run in O(n) time and use O(1) extra space\n        return 0  # Replace with your implementation\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n\n            inputs = []\n            for _ in range(t):\n                n = input()  # Read size but do not use it\n                line = input().strip()\n                # Parse the array\n                if line in [\"[]\", \"[\", \"]\", \"\"]:\n                    nums = []\n                else:\n                    # Remove brackets and split by comma\n                    content = line[1:-1].strip()\n                    nums = [int(x.strip()) for x in content.split(',')]\n                inputs.append(nums)\n\n            # Runtime calculation will be inserted here with correct indentation\n            # RUNTIME CALC START\n            \n            results = []\n            for nums in inputs:\n                sol = Solution()\n                result = sol.firstMissingPositive(nums)\n                results.append(str(result))\n\n            print('\\n'.join(results))\n            # RUNTIME CALC END\n\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()",
      "solutionCode": "import sys\n\nclass Solution:\n    def firstMissingPositive(self, nums):\n        n = len(nums)\n        \n        # Step 1: Mark numbers <= 0 and > n as n+1\n        for i in range(n):\n            if nums[i] <= 0 or nums[i] > n:\n                nums[i] = n + 1\n        \n        # Step 2: Mark present numbers by making the value at index (number-1) negative\n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        # Step 3: Find the first positive number's index\n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        # If all numbers from 1 to n are present\n        return n + 1\n\nclass Main:\n    @staticmethod\n    def main():\n        try:\n            # Read number of test cases\n            t = int(input().strip())\n\n            inputs = []\n            for _ in range(t):\n                n = input()  # Read size but do not use it\n                line = input().strip()\n                # Parse the array\n                if line in [\"[]\", \"[\", \"]\", \"\"]:\n                    nums = []\n                else:\n                    # Remove brackets and split by comma\n                    content = line[1:-1].strip()\n                    nums = [int(x.strip()) for x in content.split(',')]\n                inputs.append(nums)\n\n            # Runtime calculation will be inserted here with correct indentation\n            # RUNTIME CALC START\n            \n            results = []\n            for nums in inputs:\n                sol = Solution()\n                result = sol.firstMissingPositive(nums)\n                results.append(str(result))\n\n            print('\\n'.join(results))\n            # RUNTIME CALC END\n\n        except Exception as e:\n            print(f\"Error: {e}\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    Main.main()"
    }
  ],
  "defaultLanguage": "java",
  "testCases": [
    {
      "input": "3\n3\n[1,2,0]\n4\n[3,4,-1,1]\n5\n[7,8,9,11,12]",
      "output": "3\n2\n1",
      "hidden": false,
      "explanation": "Multiple test cases"
    },
    {
      "input": "4\n2\n[1,1]\n5\n[1,2,3,4,5]\n0\n[]\n5\n[-5,-3,-1,0,1]",
      "output": "2\n6\n1\n2",
      "hidden": true,
      "explanation": "Edge cases including duplicate, empty, and negative numbers"
    }
  ]
} 